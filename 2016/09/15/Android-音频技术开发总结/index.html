<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Android 音频技术开发总结 | 箫鉴哥博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要： 在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。 1、概念理解 采样率：即采样频率，百科的解释是，每秒从连续信号中提取并组成离散信号的采样个数，单位 赫兹（Hz）。通俗的讲采样频率是指计算机每秒钟采集多少个声音样本，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。好吧，感觉…

在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。
1、概念理解采样率：即">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 音频技术开发总结">
<meta property="og:url" content="http://G96968586.github.io/2016/09/15/Android-音频技术开发总结/index.html">
<meta property="og:site_name" content="箫鉴哥博客">
<meta property="og:description" content="摘要： 在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。 1、概念理解 采样率：即采样频率，百科的解释是，每秒从连续信号中提取并组成离散信号的采样个数，单位 赫兹（Hz）。通俗的讲采样频率是指计算机每秒钟采集多少个声音样本，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。好吧，感觉…

在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。
1、概念理解采样率：即">
<meta property="og:image" content="http://s4.51cto.com/wyfs02/M02/7C/F6/wKioL1bdXQviw_TBAAAVYm_x3gk862.gif">
<meta property="og:image" content="http://www.liuhaihua.cn/wp-content/uploads/2016/03/b2qAVfa.png">
<meta property="og:image" content="http://upload.wikimedia.org/math/8/e/a/8eae7519d0c9f264e89ececeaaeb1d05.png">
<meta property="og:image" content="http://upload.wikimedia.org/math/9/0/2/9023cb5d56a945e9332196fabacb463a.png">
<meta property="og:updated_time" content="2016-09-15T15:17:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 音频技术开发总结">
<meta name="twitter:description" content="摘要： 在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。 1、概念理解 采样率：即采样频率，百科的解释是，每秒从连续信号中提取并组成离散信号的采样个数，单位 赫兹（Hz）。通俗的讲采样频率是指计算机每秒钟采集多少个声音样本，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。好吧，感觉…

在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。
1、概念理解采样率：即">
<meta name="twitter:image" content="http://s4.51cto.com/wyfs02/M02/7C/F6/wKioL1bdXQviw_TBAAAVYm_x3gk862.gif">
  
    <link rel="alternative" href="/atom.xml" title="箫鉴哥博客" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://gw.alicdn.com/tps/TB1mZsZNXXXXXXDXVXXXXXXXXXX-200-200.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">箫鉴哥</a></h1>
		</hgroup>

		
		<p class="header-subtitle">如果没能一次成功，那就叫它1.0版吧</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>

				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/G96968586" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1813501992" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:huijian.xhj@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>

				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/代码/" style="font-size: 10px;">代码</a> <a href="/tags/样式/" style="font-size: 10px;">样式</a> <a href="/tags/每周总结/" style="font-size: 20px;">每周总结</a> <a href="/tags/热修复/" style="font-size: 10px;">热修复</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a>
					</div>
				</section>
				

				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">技术只是解决问题的选择，而不是解决问题的根本。</div>
				</section>
				
			</div>
		</div>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">箫鉴哥</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="nullhttps://gw.alicdn.com/tps/TB1mZsZNXXXXXXDXVXXXXXXXXXX-200-200.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
				
			</div>
			<hgroup>
			  <h1 class="header-author">箫鉴哥</h1>
			</hgroup>
			
			<p class="header-subtitle">如果没能一次成功，那就叫它1.0版吧</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/G96968586" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1813501992" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:huijian.xhj@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Android-音频技术开发总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/15/Android-音频技术开发总结/" class="article-date">
  	<time datetime="2016-09-14T17:11:06.000Z" itemprop="datePublished">2016-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android 音频技术开发总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>摘要： 在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。 1、概念理解 采样率：即采样频率，百科的解释是，每秒从连续信号中提取并组成离散信号的采样个数，单位 赫兹（Hz）。通俗的讲采样频率是指计算机每秒钟采集多少个声音样本，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。好吧，感觉…</p>
</blockquote>
<p>在文章开头，我们先来了解几个概念，这样有利于对后面内容的理解。</p>
<h4 id="1、概念理解"><a href="#1、概念理解" class="headerlink" title="1、概念理解"></a>1、概念理解</h4><p><strong>采样率</strong>：即采样频率，百科的解释是，每秒从<a href="http://baike.baidu.com/view/1910376.htm" target="_blank" rel="external">连续信号</a>中提取并组成离散信号的采样个数，单位 <a href="http://baike.baidu.com/subview/19996/7461726.htm" target="_blank" rel="external">赫兹</a>（Hz）。通俗的讲采样频率是指计算机每秒钟采集多少个声音样本，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。好吧，感觉这样还是不太理解，那我们来看看下面的解释：</p>
<p>如图，</p>
<p><img src="http://s4.51cto.com/wyfs02/M02/7C/F6/wKioL1bdXQviw_TBAAAVYm_x3gk862.gif" alt=""></p>
<p>采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用 0101 来表示的数字信号，上图蓝色代表模拟音频信号，而红色的点代表采样得到的量化数值。红色点之间的间隔越小，表示采样频率越高，同时音频质量也就越高。</p>
<p><strong>通道数</strong>：一般表示声音录制时的音源数量或回放时相应的扬声器数量。单声道（Mono）和双声道（Stereo）比较常见。</p>
<p><strong>量化精度（位宽）</strong>：上图中的每一个红色点，都有一个数值来表示其大小，这个数值的数据类型有：4bit、8bit、16bit、32bit等，位数越多，表示得就越精细，声音质量也就越好。</p>
<p><strong>音频帧（frame）</strong>：音频数据是流式的，本身并没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取 2.5 ms ~ 60 ms为单位的数据量为一帧音频。 这个时间被称之为“采样时间”，其长度没有特别的标准。我们可以计算一下一帧音频帧的大小：</p>
<p>假设某通道的音频信号是采样率为 8 kHz，位宽为16 bit，20 ms 一帧，双通道，则一帧音频数据的大小为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int size = 8000 x 16bit x 0.02s  x 2 = 5120 bit = 640 byte</div></pre></td></tr></table></figure>
<p><strong>音频编码</strong>：模拟的音频信号转换为数字信号需要经过采样和量化，量化的过程被称之为编码。根据不同的量化策略，产生了许多不同的编码方式。</p>
<h4 id="2、音频采集"><a href="#2、音频采集" class="headerlink" title="2、音频采集"></a>2、音频采集</h4><p>在 Android 开发中，官方 SDK 提供了两套音频录制的 API，一个是 MediaRecorder ，另一个是 AudioRecord。前者会对录入的音频数据进行编码压缩(如 AMR，3GP等)，  而后者是更加偏向底层的 API，录入的是一帧帧 的 PCM 音频数据，是无损没有经过压缩的。如果你对音频格式没有特殊的要求，只是简单的想做一个录音功能，那推荐你使用 MediaRecorder 。MediaRecorder 支持的输出方式有：amr_nb，amr_wb, default, mpeg_4, raw_amr, three_gpp。如果需要对音频数据进行额外的算法处理，则建议使用更加灵活的 AudioRecord API。比如，我想要录制一个 MP3 格式的音频文件， Android SDK 本身是不支持直接录制 MP3 格式的文件，我们就可以通过 AudioRecord 来采集音频数据，并通过第三方库来进行编码。下面我将会介绍怎么在 Android 上使用 AudioRecord 录制 MP3 和 WAV 格式的音频文件。</p>
<h5 id="2-1-MP3-音频录制"><a href="#2-1-MP3-音频录制" class="headerlink" title="2.1 MP3 音频录制"></a>2.1 MP3 音频录制</h5><p>LAME 是目前最出色的 MP3 编码引擎。我们要在 Android 平台上使用它，需要下载 <a href="http://lame.sourceforge.net/links.php" target="_blank" rel="external">lame</a> 源码并将其编译成 so 库，然后通过 jni 来调用。这里有一个开源项目 <a href="https://github.com/GavinCT/AndroidMP3Recorder" target="_blank" rel="external">AndroidMP3Recorder</a> 帮我们省去了这一步骤，而且这个库封装了底层的 MP3 编码，我们直接拿过来使用就可以了。作者具体的实现思路，可以参考这里 <a href="http://www.cnblogs.com/ct2011/p/4080193.html" target="_blank" rel="external">实现思路讲解</a>。</p>
<p>我简要说下怎么引入这个库和使用，以及本人踩过的坑。</p>
<p>在 Android studio 上集成这个库:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> dependencies &#123;</div><div class="line">    compile &apos;com.czt.mp3recorder:library:1.0.2&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，因为上面的集成会自动引入多种 so 库，如果只需要其中的几种，可以在gradle中添加下面的配置（比如）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">  arm &#123;</div><div class="line">    ndk &#123;</div><div class="line">      abiFilters &quot;armeabi-v7a&quot;, &quot;armeabi&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  x86 &#123;</div><div class="line">    ndk &#123;</div><div class="line">      abiFilter &quot;x86&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在编译时就只会在 arm 中接入 armeabi-v7a armeabi 包，在 x86 上接入 x86 的包，而不会接入其他的包。最后还需要在 gradle.properties 中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android.useDeprecatedNdk = true</div></pre></td></tr></table></figure>
<p>这样就可以正常使用了。如果不过滤不需要的 so 库，在编译时就会报这个错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.UnsatisfiedLinkError</div></pre></td></tr></table></figure>
<p>举个例子，使用无线保镖 SDK 时，我们会接入 armeabi-v7a 和 x86 这两个包的 so 文件，但由于我们使用了 AndroidMP3Recorder 这个库，它会产生额外的诸如 armeabi、armeabi-v8a、mips等多个文件夹，这些文件夹里面都有 liblame.so 文件，但没有无线保镖的 so 文件，这样就会引发java.lang.UnsatisfiedLinkError 错误，导致编译不通过。</p>
<p>OK，剩下的就是开始使用这个库了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建 MP3Recorder 实例， 传入录音文件的保存路径和文件名</div><div class="line">MP3Recorder mRecorder = new MP3Recorder(new File(Environment.getExternalStorageDirectory(), &quot;demo.mp3&quot;));</div><div class="line"></div><div class="line">// 开始录音</div><div class="line">mRecorder.start();</div><div class="line"></div><div class="line">// 停止录音</div><div class="line">mRecorder.stop();</div></pre></td></tr></table></figure>
<p>是不是很简单，转码的事情通通不用操心，全帮你做了。</p>
<p>踩到的坑：</p>
<p>后面我发现在小米4、锤子 T2 等手机上打开接入了这个库的 app 直接闪退了。经过分析发现，在小米 4、锤子 T2 等手机上运行我们的 app ，系统会先去找 arm64-v8a 这个目录下的 so 文件，如果不存在还好，偏偏我的 app 存在 arm64-v8a 目录，此时因为找不到目录下无线保镖的 so 文件（前面说过，接入了无线保镖只会引入  armeabi-v7a 和 x86 这两个包的 so 文件），就直接报 java.lang.UnsatisfiedLinkError：couldn’t find “libsecuritysdk.so” 的错了。</p>
<p>这时候我就纳闷了，前面配置时我的确只保留了 armeabi-v7a 和 x86 这两个目录下的 so 文件，去掉了不需要的 so ，但为什么还会出现其他的 so 目录呢？后面发现，在打包 apk 时，这些 so 库还是会一并被打包进 apk ！而在测试时，刚好使用的 MX3 手机加载 so 文件正常，所以没发现这个问题。这时候你也许会问，为什么小米4、锤子 T2 等手机会先去找 arm64-v8a 这个目录呢？因为它们是 64 位设备呀，而 armeabi-v7a 和 x86 针对的都是 32 位的文件。综上所述，问题可以描述为怎么在 64 位的设备上运行 32 位的二进制文件，这里指 so 文件。</p>
<p>在 stackoverflow 上找到了解决的答案：</p>
<p>When you install an APK on Android, the system will look for native libraries directories (armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, mips64, mips) inside the lib folder of the APK, in the order determined by Build.SUPPORTED_ABIS.</p>
<p>If your app happen to have an arm64-v8a directory with missing libs, the missing libs will not be installed from another directory, the libs aren’t mixed. That means you have to provide the full set of your libraries for each architecture.</p>
<p>So, to solve your issue, you can remove your 64-bit libs from your build, or set abiFilters to package only 32-bit architectures:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ....</div><div class="line">    defaultConfig &#123;</div><div class="line">        ....</div><div class="line">        ndk &#123;</div><div class="line">            abiFilters &quot;x86&quot;, &quot;armeabi-v7a&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果照上面的配置，那打包时就只会把 “x86”, “armeabi-v7a” 这两个目录及其下的 so 文件打包进 apk 。我们的问题也解决了，因为系统也只能找这两个目录下的 so 文件了。</p>
<h5 id="2-2-WAV-音频录制"><a href="#2-2-WAV-音频录制" class="headerlink" title="2.2 WAV 音频录制"></a>2.2 WAV 音频录制</h5><p>因为 wav 是无损格式的音频文件，所以我们使用的还是 AudioRecord 这个 API。但在此之前，我们需要先了解一下怎么存储 wav 格式的文件。</p>
<p>wav 是微软公司开发的一种声音文件格式，整个文件分两部分，第一部分是”文件头”，包括：采样率、通道数、位宽等参数信息，第二部分是”数据块”：指一帧一帧的二进制音频数据。</p>
<p>见下图 wav 格式的文件头：</p>
<p><img src="http://www.liuhaihua.cn/wp-content/uploads/2016/03/b2qAVfa.png" alt=""></p>
<p>它主要分为三个部分：</p>
<p>第一部分，The “RIFF” chunk descriptor，通过 “ChunkID” 来表示这是一个 “RIFF” 格式的文件，通过 “Format” 填入 “WAVE” 来标识这是一个 wav 文件。而 “ChunkSize” 则记录了整个 wav 文件的字节数。</p>
<p>第二部分，The “fmt” sub-chunk，从图中可以看出记录了 wav 音频文件的详细音频参数信息，例如：通道数、采样率、位宽、编码方式、数据块对齐信息等等。</p>
<p>第三部分，The “data” sub-chunk，这部分是真正保存 wav 数据的地方，由“Subchunk2Size”这个字段来记录后面存储的二进制原始音频数据的长度。</p>
<p>OK，我们来看下 Java 代码是怎么实现往一个文件写入 wav “文件头”的。结合上图，你理解起来就不会很困难了。</p>
<p>关键代码来自 <a href="https://github.com/mobro/android/blob/master/src/com/testo/audio/ExtAudioRecorder.java" target="_blank" rel="external">ExtAudioRecorder</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">RandomAccessFile randomAccessWriter = null;</div><div class="line">...</div><div class="line"></div><div class="line">randomAccessWriter = new RandomAccessFile(filePath, &quot;rw&quot;);</div><div class="line"></div><div class="line">randomAccessWriter.setLength(0); // Set file length to 0, to prevent unexpected behavior in case the file already existed</div><div class="line">randomAccessWriter.writeBytes(&quot;RIFF&quot;);</div><div class="line">randomAccessWriter.writeInt(0); // Final file size not known yet, write 0</div><div class="line">randomAccessWriter.writeBytes(&quot;WAVE&quot;);</div><div class="line">randomAccessWriter.writeBytes(&quot;fmt &quot;);</div><div class="line">randomAccessWriter.writeInt(Integer.reverseBytes(16)); // Sub-chunk size, 16 for PCM</div><div class="line">randomAccessWriter.writeShort(Short.reverseBytes((short) 1)); // AudioFormat, 1 for PCM</div><div class="line">randomAccessWriter.writeShort(Short.reverseBytes(nChannels));// Number of channels, 1 for mono, 2 for stereo</div><div class="line">randomAccessWriter.writeInt(Integer.reverseBytes(sRate)); // Sample rate</div><div class="line">randomAccessWriter.writeInt(Integer.reverseBytes(sRate*bSamples*nChannels/8)); // Byte rate, SampleRate*NumberOfChannels*BitsPerSample/8</div><div class="line">randomAccessWriter.writeShort(Short.reverseBytes((short)(nChannels*bSamples/8))); // Block align, NumberOfChannels*BitsPerSample/8</div><div class="line">randomAccessWriter.writeShort(Short.reverseBytes(bSamples)); // Bits per sample</div><div class="line">randomAccessWriter.writeBytes(&quot;data&quot;);</div><div class="line">randomAccessWriter.writeInt(0); // Data chunk size not known yet, write 0</div></pre></td></tr></table></figure>
<p>filePath 是音频文件绝对路径，注意此时的录音还未开始，这里的思路是在准备阶段，先创建一个带有 wave 头部信息的文件，然后在录音进行时再不断从缓冲区取出音频数据写入到这个文件中，所以这里的 ChunkSize 一开始就设置为 0。</p>
<p>另外，再给一个 samsung 的实现思路，它是读取录制完后的音频文件再往文件头写入 wave 的头部信息，本质上是一样的，但相对好理解些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">private void rawToWave(final File rawFile, final File waveFile) throws IOException &#123;</div><div class="line"></div><div class="line">        byte[] rawData = new byte[(int) rawFile.length()];</div><div class="line">        DataInputStream input = null;</div><div class="line">        try &#123;</div><div class="line">            input = new DataInputStream(new FileInputStream(rawFile));</div><div class="line">            input.read(rawData);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (input != null) &#123;</div><div class="line">                input.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        DataOutputStream output = null;</div><div class="line">        try &#123;</div><div class="line">            output = new DataOutputStream(new FileOutputStream(waveFile));</div><div class="line">            // WAVE header</div><div class="line">            // see http://ccrma.stanford.edu/courses/422/projects/WaveFormat/</div><div class="line">            writeString(output, &quot;RIFF&quot;); // chunk id</div><div class="line">            writeInt(output, 36 + rawData.length); // chunk size</div><div class="line">            writeString(output, &quot;WAVE&quot;); // format</div><div class="line">            writeString(output, &quot;fmt &quot;); // subchunk 1 id</div><div class="line">            writeInt(output, 16); // subchunk 1 size</div><div class="line">            writeShort(output, (short) 1); // audio format (1 = PCM)</div><div class="line">            writeShort(output, (short) 1); // number of channels</div><div class="line">            writeInt(output, SAMPLE_RATE); // sample rate</div><div class="line">            writeInt(output, SAMPLE_RATE * 2); // byte rate</div><div class="line">            writeShort(output, (short) 2); // block align</div><div class="line">            writeShort(output, (short) 16); // bits per sample</div><div class="line">            writeString(output, &quot;data&quot;); // subchunk 2 id</div><div class="line">            writeInt(output, rawData.length); // subchunk 2 size</div><div class="line">            // Audio data (conversion big endian -&gt; little endian)</div><div class="line">            short[] shorts = new short[rawData.length / 2];</div><div class="line">            ByteBuffer.wrap(rawData).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().get(shorts);</div><div class="line">            ByteBuffer bytes = ByteBuffer.allocate(shorts.length * 2);</div><div class="line">            for (short s : shorts) &#123;</div><div class="line">                bytes.putShort(s);</div><div class="line">            &#125;</div><div class="line">            output.write(bytes.array());</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (output != null) &#123;</div><div class="line">                output.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="3-麦克风音量获取"><a href="#3-麦克风音量获取" class="headerlink" title="3.麦克风音量获取"></a>3.麦克风音量获取</h4><h5 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h5><p>度量声音强度的单位，大家最熟悉的就是分贝。计算公式如下：</p>
<p><img src="http://upload.wikimedia.org/math/8/e/a/8eae7519d0c9f264e89ececeaaeb1d05.png" alt=""></p>
<p>分子是测量值的声压，分母是参考值的声压（20微帕，人类所能听到的最小声压）。<br>在 Android 设备上传感器可以提供的物理量是场的幅值（amplitude），常用下列公式计算分贝值：</p>
<p><img src="http://upload.wikimedia.org/math/9/0/2/9023cb5d56a945e9332196fabacb463a.png" alt=""></p>
<p>从SDK中读取了某段音频数据的振幅后，取最大振幅或平均振幅（可以用平方和平均，或绝对值的和平均），代入上述公式的A1。这里的 A0 取值似情况而定，这里不做讨论。</p>
<p>MediaRecorder 有一个无参方法 getMaxAmplitude 即可获得一小段时间内音源数据中的最大振幅。而 AudioRecord 没有提供类似的方法，但是我们可以获得具体的音源数据值来进行换算。调用 AudioRecord 的 read(byte[] audioData, int offsetInBytes, int sizeInBytes) 方法从缓冲区读取到我们传入的字节数组buffer 后，便可以对其进行操作，如求平方和或绝对值的平均值。这样可以避免个别极端值的影响，使计算的结果更加稳定。求得平均值之后，如果是平方和则代入常数系数为 10 的公式中，如果是绝对值的则代入常数系数为 20 的公式中，算出分贝值。</p>
<p>我们先来获取振幅，关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">AudioRecord audioRecorder;</div><div class="line">byte[] buffer;</div><div class="line">int bufferSize;</div><div class="line">// 振幅</div><div class="line">int mAmplitude= 0;</div><div class="line">// Number of frames written to file on each output(only in uncompressed mode)</div><div class="line">private int framePeriod;</div><div class="line">...</div><div class="line">// 初始化,sampleRate 是采样率，这里我设置的是 44100 Hz，Google Android 文档明确表明只有以下3个参数是可以在所有设备上保证支持的，44100 Hz，AudioFormat.CHANNEL_IN_MONO(单声道)，AudioFormat.ENCODING_PCM_16BIT(位宽)</div><div class="line"></div><div class="line">bufferSize = AudioRecord.getMinBufferSize(sampleRate, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);</div><div class="line"></div><div class="line">// MediaRecorder.AudioSource.MIC,音频采集的输入源</div><div class="line">audioRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSize);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">buffer = new byte[framePeriod*bSamples/8*nChannels];</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// 开始录音</div><div class="line">audioRecorder.start();</div><div class="line">// 读取缓冲区音频数据</div><div class="line">audioRecorder.read(buffer, 0, buffer.length); // Fill buffer</div><div class="line">            try</div><div class="line">            &#123;</div><div class="line">                randomAccessWriter.write(buffer); // Write buffer to file</div><div class="line">                payloadSize += buffer.length;</div><div class="line">                    for (int i=0; i&lt;buffer.length/2; i++)</div><div class="line">                    &#123; // 16bit sample size</div><div class="line">                        short curSample = getShort(buffer[i*2], buffer[i*2+1]);</div><div class="line">                        if (curSample &gt; mAmplitude)</div><div class="line">                        &#123; // Check amplitude</div><div class="line">                            mAmplitude = curSample;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">              &#125;</div><div class="line">            catch (IOException e)</div><div class="line">            &#123;</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>上面的 mAmplitude 就是振幅了。现在我们需要换算成分贝，直接代入公式，只需简单的这么一句代码就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int mVolume = (int)(10 * Math.log10(amplitude));</div></pre></td></tr></table></figure>
<p>上面的 mAmplitude 时刻都在变化的，除非录音结束。所以，我们可以通过 mAmplitude 来实现诸如绘制声音频率图、声波图等效果。</p>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><ul>
<li><a href="http://blog.csdn.net/bluesoal/article/details/932395" target="_blank" rel="external">《wav文件格式分析详解》</a></li>
</ul>
<ul>
<li><a href="http://ju.outofmemory.cn/entry/247659" target="_blank" rel="external">《如何存储和解析wav文件》</a></li>
</ul>
<ul>
<li><a href="http://ticktick.blog.51cto.com/823160/1748506" target="_blank" rel="external">《Android 音频开发基础知识》</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/15/聊聊-Android-的-Service-组件/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          聊聊 Android 的 Service 组件
        
      </div>
    </a>
  
  
    <a href="/2016/09/14/Android-内存泄漏总结/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android 内存泄漏总结</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Android-音频技术开发总结" data-title="Android 音频技术开发总结" data-url="http://G96968586.github.io/2016/09/15/Android-音频技术开发总结/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"huijian"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 箫鉴哥
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>