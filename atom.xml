<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>箫鉴哥</title>
  <icon>https://www.gravatar.com/avatar/450d2f9c65192a3fc3f264439c8ae658</icon>
  <subtitle>如果没能一次成功，那就叫它1.0版吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://G96968586.github.io/"/>
  <updated>2018-05-06T15:43:11.916Z</updated>
  <id>http://G96968586.github.io/</id>
  
  <author>
    <name>箫鉴哥</name>
    <email>huijian.xhj@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有关 PWA 的几个宝贵实践经验</title>
    <link href="http://G96968586.github.io/2017/11/29/%E6%9C%89%E5%85%B3-PWA-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AE%9D%E8%B4%B5%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    <id>http://G96968586.github.io/2017/11/29/有关-PWA-的几个宝贵实践经验/</id>
    <published>2017-11-29T07:42:37.000Z</published>
    <updated>2018-05-06T15:43:11.916Z</updated>
    
    <content type="html"><![CDATA[<p>日常的技术调研、新技术的尝鲜，我们更多的关注点是在技术本身上。但是，如果涉及到技术的具体落地，关联到线上生产环境，我们要考虑的因素就多了。这里以 PWA 为例，如果我们的产品使用了 PWA 技术，在将其部署到生产环境之前，我们需要做什么准备呢？需要提前考虑到哪些因素呢？下面是总结饿了么 M 站的一些宝贵实践经验，这里拿来跟大家分享。<br><a id="more"></a></p><h2 id="提供降级方案"><a href="#提供降级方案" class="headerlink" title="提供降级方案"></a>提供降级方案</h2><p>Service Worker 直接在浏览器网络层工作，脱离页面生命周期，提供资源预加载和强大的离线缓存能力，因此，如果 Service Worker 内部存在 bug，很大情况下 bug 会被放大，比如：</p><ul><li>由于缓存的原因，bug 也被缓存起来了，不能及时的修复</li><li>如果 Service Worker 的缓存策略存在 bug，用户可能就无法更新页面了，这种情况开发者也不易察觉到</li><li>Service Worker 的错误可能会导致整个页面无法工作，给业务带来灾难性的影响</li></ul><p>而且，国内市面上各种各样的浏览器和系统，对 Service Worker 的能力支持各不相同，功能适配和兼容性问题给我们国内开发者写出 bug-free 代码带来了很大的难度。<br>所以，万一出现重大 bug 了，怎么在最短时间内解决呢？当然是降级啦，所以提供降级方案非常有必要！那 PWA 怎么降级呢？<br><a href="http://chuansong.me/n/1676119852913" target="_blank" rel="noopener">饿了么 M 站</a> 提供了一个简单又粗暴的方法，就是降级开关。一旦发现事情不妙，开启降级就可以了。具体做法是，页面先请求开关接口，若降级，则不安装并且<strong>注销</strong>所有 Service Worker。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (支持SW) &#123;</span><br><span class="line">  fetch(开关接口)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (降级) &#123;</span><br><span class="line">      <span class="comment">// 注销所有已安装的 SW</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 注册 SW</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几点要注意的：</p><ul><li>降级不是简单的不安装，而是要注销掉。原因是降级前可能已经有用户访问过网站，导致 Service Worker 被安装，不注销的话降级开关对这部分用户是不起作用的。</li><li>降级开关不能被缓存，需要具备即时性。服务端和 Service Worker 都不该缓存该接口。</li><li>出现问题并降级后，可能影响问题的排查，因此可以考虑加入对用户隐蔽的 debug 模式（如 url 传入特定字段），debug 模式中忽略降级接口。</li></ul><h2 id="接入错误监控"><a href="#接入错误监控" class="headerlink" title="接入错误监控"></a>接入错误监控</h2><p>由于 Service Worker 运行在 worker 线程里，所以抛出的错误页面是捕捉不到的，因此需要在 Service Worker 里引入错误监控方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'error'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上报错误信息</span></span><br><span class="line">  <span class="comment">// 常用的属性：</span></span><br><span class="line">  <span class="comment">// event.message</span></span><br><span class="line">  <span class="comment">// event.filename</span></span><br><span class="line">  <span class="comment">// event.lineno</span></span><br><span class="line">  <span class="comment">// event.colno</span></span><br><span class="line">  <span class="comment">// event.error.stack</span></span><br><span class="line">&#125;)</span><br><span class="line">self.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上报错误信息</span></span><br><span class="line">  <span class="comment">// 常用的属性：</span></span><br><span class="line">  <span class="comment">// event.reason</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>Service Worker 大部分 API 都是 promise-based 的，promise 里未处理的错误触发的不是 error 事件，而是 unhandledrejection 事件。</li><li>这两个事件都只能在 worker 线程的 initial 生命周期里注册。（否则会失败，控制台可看到警告）</li></ul><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>每一个产品都需要数据统计，目的是为了帮助我们更好的理解用户，为业务增长提供数据支撑。同时，其曲线抖动也可以辅助错误监控为生产环境提供监控保障。当然，数据也可以协助运营提供更加好的产品运营解决方案。</p><h2 id="开发单页面-PWA-应用"><a href="#开发单页面-PWA-应用" class="headerlink" title="开发单页面 PWA 应用"></a>开发单页面 PWA 应用</h2><p>前面的准备工作做完后，就可以开始专心写代码了。单页面架构的应用，你只需要：</p><ul><li>用几个 Service Worker 的库，比如：<a href="https://github.com/goldhand/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a></li><li>找个 manifest.json 抄一下，比如<a href="">饿了么 M 站</a>的 <a href="https://h5.ele.me/manifest.json" target="_blank" rel="noopener">manitest.json</a></li><li>使用 lighthouse 跑一下页面，按照提示改进</li><li>对比谷歌的 PWA <a href="https://developers.google.com/web/progressive-web-apps/checklist" target="_blank" rel="noopener">Checklist </a>，按照提示改进</li><li>国内各大浏览器 Debug 测试：微信、QQ 浏览器、UC 浏览器、百度浏览器、360 浏览器、猎豹浏览器</li><li>在 10 台安卓机上 Debug 以下系统自带的浏览器</li></ul><p>以上基本就 OK 了。</p><h2 id="开发多页面-PWA-应用"><a href="#开发多页面-PWA-应用" class="headerlink" title="开发多页面 PWA 应用"></a>开发多页面 PWA 应用</h2><p>多页应用会面临更多的问题，比如多页面切换成本高，即使对所有资源都进行了缓存，消除了网络延时，但浏览器销毁页面、解析 HTML、执行 JS、渲染新页面等一系列动作的耗时仍然很高，且几乎无法避免。所以多页应用页面渲染流程的优化，尽可能提高首屏渲染速度是首先要做的事情。</p><h2 id="用-App-Shell-提高首屏渲染速度"><a href="#用-App-Shell-提高首屏渲染速度" class="headerlink" title="用 App Shell 提高首屏渲染速度"></a>用 App Shell 提高首屏渲染速度</h2><p>提高首屏渲染速度的一个主流方法是使用 <a href="https://lark.alipay.com/fgt-mobile/be9mcc/epod4g/edit" target="_blank" rel="noopener">App Shell</a>。那怎样优雅地写一个 App Shell 呢？既然要求在 JS 加载之前渲染，那是不是意味着只能动手写 DOM？不是的，Vue 2 引入了服务端 Server Side Rendering，简称 SSR。它能够在 Node.js 里渲染 vue 组件并输出为 HTML 片段。因此我们可以在构建阶段调用 Vue SSR 进行 App Shell 的渲染，这也就是所谓的 prerendering。具体的做法可以参考<a href="https://www.npmjs.com/package/vue-server-renderer" target="_blank" rel="noopener"> vue-server-renderer</a> 和 <a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-hackernews</a>。<br>然而，饿了么 M 站在实践中发现 App Shell 的渲染比预计的要慢：它总是在同步的 JS 解析完成之后才渲染。不过这里有一个简单而行之有效的方法：把耗时的操作推迟到 Event Loop 的任务队列中，等待主调用栈清空后才执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 把初始化渲染放到 setTimeout 里</span></span><br><span class="line">  <span class="keyword">new</span> Vue()</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>虽然只是几行代码的 hack ，但是对 App Shell 的渲染提升是极大的。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/jpeg/257f24ab-aaa8-44af-ae11-5fa9c31e6aca.jpeg" alt="image.jpeg | center | 600x348"><br>可以看到，加入 App Shell 并且优化后，在主流手机设备上，首屏 App Shell 的渲染时间在 500ms 以下，再加上 SW 对 HTML 的缓存，页面的切换体验可以比较贴近单页应用了。</p><h2 id="一些踩坑经验"><a href="#一些踩坑经验" class="headerlink" title="一些踩坑经验"></a>一些踩坑经验</h2><p>下面是饿了么 M 站在 PWA 改造过程中遇到的坑以及相应的解决方案：</p><ul><li>Android WebView 中 UserAgent 不正确，cookies 丢失<blockquote><p>在我们实验性地上线 PWA 后，大数据的同事向我们反馈，他们的统计数据中有有一部分「不正常的 UA」涌入，根据来源分析，这部分 UA 应该是「饿了么 APP」的自定义 UA ，而统计到的数据却为安卓系统默认的 WebView UA。<br>同一时间，我们还在服务监控中，观察到了某些接口的 401 状态异常上涨。而 401 状态意味着用户认证失败，据此我们推断是 SW 导致 cookies 丢失。<br>后来我们及时降级 PWA，并与谷歌合作排查，最终确定了 bug 的来源，且将 bug 提交给了 Chrome 团队： <a href="">698175 - User agent string not set correctly when Service Worker makes a fetch request - chromium - Monorail</a><br>在 WebView 修复之前，你可以通过避免在 SW 里代理需要 UA 和 cookies 的请求（通常是API请求）来避开这个 bug。</p></blockquote></li></ul><ul><li>X5 内核部分请求发送 q-sid 头<blockquote><p>在开启 SW 后，微信和 QQ 浏览器都出现了白屏现象。我们利用调试工具观察到部分资源的请求多了一个 q-sid essay-header，这导致浏览器向 CDN 服务器发送 OPTIONS 请求并且遭到拒绝，所以导致页面无法打开。<br>我们向 X5 内核的团队反馈了这个问题，并且很快得到了技术支持：X5 内核将在新版(4311)中修复这个问题，在此之前，我们可以在服务端设置允许 q-sid 的自定义头部来避开这个问题。</p></blockquote></li></ul><ul><li>UC 浏览器中 301 跳转问题<blockquote><p>同样，我们的页面在 UC 浏览器中也出现了白屏现象，但是 bug 的原因不同：我们发现 SW 抓取的资源中，带 301 跳转的资源请求总是失败的。在向 UC 团队反馈后，我们得到了 bug 的确认，这是内核对 fetch API 的实现基于早期不完善的规范导致的，UC 团队将积极推进内核版本的升级和 bug 的修复。在修复之前，可以采用临时的解决方案：服务端避免 301 跳转，或者 SW 中对存在 301 跳转情况的资源做特殊处理。</p></blockquote></li></ul><ul><li>其他细节：<blockquote><p>低版本 chromium 不支持 cache.addAll，可以考虑引入带有 polyfill 的库；<br>UC 浏览器不支持 cache.add ，请用 cache.put 代替；<br>部分低版本微信浏览器中，UA 是 Chrome 30+ 但存在 navigator.serviceWorker，因此不要依赖 <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">isserviceworkerready</a> 用版本检测代替功能检测；</p></blockquote></li></ul><p>##参考文章<br><a href="http://chuansong.me/n/1676119852913" target="_blank" rel="noopener">PWA 在饿了么的实践经验</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文会不定期更新，欢迎关注！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常的技术调研、新技术的尝鲜，我们更多的关注点是在技术本身上。但是，如果涉及到技术的具体落地，关联到线上生产环境，我们要考虑的因素就多了。这里以 PWA 为例，如果我们的产品使用了 PWA 技术，在将其部署到生产环境之前，我们需要做什么准备呢？需要提前考虑到哪些因素呢？下面是总结饿了么 M 站的一些宝贵实践经验，这里拿来跟大家分享。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA 添加 Web Push 通知</title>
    <link href="http://G96968586.github.io/2017/11/29/PWA-%E6%B7%BB%E5%8A%A0-Web-Push-%E9%80%9A%E7%9F%A5/"/>
    <id>http://G96968586.github.io/2017/11/29/PWA-添加-Web-Push-通知/</id>
    <published>2017-11-29T07:38:03.000Z</published>
    <updated>2018-05-06T15:42:49.967Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何往 PWA 中添加推送通知功能，如果你有兴趣想了解更多关于 Web Push 技术，可以阅读这篇文章<a href="">《PWA系列 - Web Push 技术》</a>，看一篇抵过 n 篇 Google 的文档。<br><a id="more"></a><br>OK，下面我们进入主题。同样，你需要先做一些准备工作，可以参考这篇<a href="">《搭建你的第一个 PWA》</a>文章。然后下载示例代码：<br><a href="">download: push-notifications-master.zip</a></p><h2 id="注册-Service-Worker"><a href="#注册-Service-Worker" class="headerlink" title="注册 Service Worker"></a>注册 Service Worker</h2><p>解压示例代码，在 app 目录下有一个 sw.js 的文件，打开你会发现里面除了一些注释和一行 <code>use strict;</code>外什么都没有，后面我们会不断往里面添加代码的，因为这个文件是我们的服务工作线程。<br>现在，打开 scripts/main.js，这是示例程序的入口，在文件的末尾添加下面代码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Service Worker and Push is supported'</span>);</span><br><span class="line"></span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">swReg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Service Worker is registered'</span>, swReg);</span><br><span class="line"></span><br><span class="line">    swRegistration = swReg;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Service Worker Error'</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'Push messaging is not supported'</span>);</span><br><span class="line">  pushButton.textContent = <span class="string">'Push Not Supported'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一段注册服务工作线程的代码，但你会发现这段代码跟前面文章所介绍的注册服务工作线程有些不太一样，是的，我们这里同时检查了浏览器是否支持推送消息： ‘PushManager’ in window。<br>打开 Web Server for Chrome，选择访问目录为 app，<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/e32187ca-e5c1-4071-b1d1-024b0c17621a.png" alt="屏幕快照 2017-09-17 下午10.23.33.png | center | 644x680"></p><p>在浏览器打开网址 <strong>127.0.0.1:8887 </strong>访问我们的示例应用。如果你前面阅读过 <a href="https://lark.alipay.com/fgt-mobile/be9mcc/dt2egy" target="_blank" rel="noopener">《调试 Service Workers》</a>，并在自己的电脑上做过调试，你也许会访问到这个页面，<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/40be4c5b212b8e6e.png" alt="image | center"></p><p>这是因为前面我们缓存了一些资源文件，你可以打开开发者工具，切换到 Application 视图 Clear storage 选项，点击 Clear site data，清除缓存再次刷新页面，当你访问到下面这个绿色主题的页面，说明你前面操作成功！<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/dc930520-3d40-409a-be0b-c5855057ae78.png" alt="屏幕快照 2017-09-17 下午10.29.06.png | center | 2878x1536"></p><h3 id="获取应用服务器密钥"><a href="#获取应用服务器密钥" class="headerlink" title="获取应用服务器密钥"></a>获取应用服务器密钥</h3><p>使用示例代码，我们还需要生成一些应用服务器密钥，访问示例代码配套网站：<a href="https://web-push-codelab.appspot.com/?hl=zh-cn" target="_blank" rel="noopener">https://web-push-codelab.appspot.com/</a>，我们可以在这里生成一个公私密钥对。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/7a6cf3b7-be1b-4841-b7c8-ef274ad7862a.png" alt="屏幕快照 2017-09-17 下午10.39.05.png | center | 2876x1180"></p><p>点击 refresh keys 按钮，然后将公钥复制到<code>scripts/main.js</code>替换<code>&lt;Your Public Key&gt;</code>值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerPublicKey = <span class="string">'&lt;Your Public Key&gt;'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h2><p>你可以发现，目前我们的示例程序页面上的那个按钮不可点击。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/5d381b34-e1ca-4fc4-a182-4536976f60e3.png" alt="屏幕快照 2017-09-17 下午11.43.42.png | center | 754x300"></p><p>因为默认情况下最好禁用推送按钮。如果检测到当前浏览器环境支持推送功能，并且当前用户订阅了推送消息，我们再启用此按钮。<br>下面我们在 scripts/main.js 里面添加两个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前用户有没有订阅消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialiseUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Set the initial subscription value</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    isSubscribed = !(subscription === <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User IS subscribed.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User is NOT subscribed.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将启用推送按钮，以及更改用户是否订阅的文本，在 initialiseUI 里调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Disable Push Messaging'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Enable Push Messaging'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushButton.disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注册服务工作线程时调用 initialiseUI() 函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">swReg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Service Worker is registered'</span>, swReg);</span><br><span class="line"></span><br><span class="line">  swRegistration = swReg;</span><br><span class="line">  <span class="comment">// 这里调用</span></span><br><span class="line">  initialiseUI();</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>刷新页面，可以看到此时页面上的按钮变成可点击状态了，从 console 控制台上可以看到下面的输出，注意到其中有一句是 <code>User is NOT subscribed</code>，下面我们开始来订阅消息。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/f51f662b-28d4-4b1b-9c92-ae5e76df6a82.png" alt="屏幕快照 2017-09-18 上午10.08.52.png | center | 2880x1600"></p><h2 id="用户订阅"><a href="#用户订阅" class="headerlink" title="用户订阅"></a>用户订阅</h2><p>在 initialiseUI() 函数里添加点击事件监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialiseUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用户点击按钮后，我们先设置按钮处于不可点击状态，防止用户重复订阅消息</span></span><br><span class="line">    pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Unsubscribe user</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      subscribeUser();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the initial subscription value</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    isSubscribed = !(subscription === <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 注意，这里新增了一行代码</span></span><br><span class="line">    updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User IS subscribed.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User is NOT subscribed.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 scripts/main.js 里添加 subscribeUser 函数，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);</span><br><span class="line">  swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">    userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">    applicationServerKey: applicationServerKey</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User is subscribed:'</span>, subscription);</span><br><span class="line"></span><br><span class="line">    updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Failed to subscribe the user: '</span>, err);</span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数的作用是，先获取应用服务器的公钥（base64 网址安全编码），然后将其转换为 UInt8Array。转换后，我们调用 swRegistration.pushManager 的 subscribe() 方法，把应用服务器的公钥和 userVisibleOnly: true 传进去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);</span><br><span class="line">swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">  userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">  applicationServerKey: applicationServerKey</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>userVisibleOnly 表示在发送推送时显示我们的消息通知。<br>调用 subscribe() 方法后会返回一个 promise：</p><ol><li>用户已授权显示通知</li><li>浏览器已向推送服务发送网络请求，以便获取详细信息来生成 PushSubscription</li></ol><p>如果这些步骤成功执行，我们可以在 then 回调里对 subscription 进行解析，如果用户未授权，或者出现其他问题，我们需要在 catch 里做错误处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">  userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">  applicationServerKey: applicationServerKey</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'User is subscribed:'</span>, subscription);</span><br><span class="line"></span><br><span class="line">  updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">  isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  updateBtn();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Failed to subscribe the user: '</span>, err);</span><br><span class="line">  updateBtn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以收到订阅，并将用户标记为已订阅用户。成功或出错我们都调用 updateBtn 函数来修改按钮文案。下面在 scripts/main.js 里添加 updateSubscriptionOnServer 方法，将订阅发送到后端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSubscriptionOnServer</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Send subscription to application server</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscriptionJson = <span class="built_in">document</span>.querySelector(<span class="string">'.js-subscription-json'</span>);</span><br><span class="line">  <span class="keyword">const</span> subscriptionDetails =</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'.js-subscription-details'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subscription) &#123;</span><br><span class="line">    subscriptionJson.textContent = <span class="built_in">JSON</span>.stringify(subscription);</span><br><span class="line">    subscriptionDetails.classList.remove(<span class="string">'is-invisible'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscriptionDetails.classList.add(<span class="string">'is-invisible'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候刷新页面，点击订阅按钮，会看到下面的权限提示，</p><p><img src="https://gw.alicdn.com/tfs/TB1fr7YazuhSKJjSspmXXcQDpXa-2874-1720.png" alt="image | center"></p><p>点击允许，可以看到 console 控制台输出了 User is subscribe，同时页面底部出现了订阅信息。</p><p><img src="https://gw.alicdn.com/tfs/TB1qj89eMMPMeJjy1XdXXasrXXa-2872-1652.png" alt="image | center"></p><h2 id="处理拒绝的权限"><a href="#处理拒绝的权限" class="headerlink" title="处理拒绝的权限"></a>处理拒绝的权限</h2><p>我们还需要处理当用户点击拒绝的情况。因为如果用户拒绝了我们的推送，我们的页面是无法重新显示权限提示的，所以，这里的做法是禁止推送按钮。</p><p>在 updateBtn() 里检查 Notification.permission 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果权限为 denied，就无法订阅用户，并且我们无法执行其他操作，因此，停用此按钮是最好的做法</span></span><br><span class="line">  <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span>) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Push Messaging Blocked.'</span>;</span><br><span class="line">    pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">    updateSubscriptionOnServer(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Disable Push Messaging'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Enable Push Messaging'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushButton.disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到浏览器，刷新页面，点击网址栏的圆圈中的 <strong>i</strong>，将通知权限更改为 <em>Use global default (Ask)</em> 。</p><p><img src="https://gw.alicdn.com/tfs/TB1_dQ1aqagSKJjy0FbXXa.mVXa-2876-1320.png" alt="image | center"></p><p>重新加载页面，点击订阅按钮，选择禁止，发现按钮的文案现在改为 Push Messaging Blocked，并且处于不可点击状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Y7mgX2NNTKJjSspfXXbXIFXa-2880-1488.png" alt="image | center"></p><h2 id="处理推送事件"><a href="#处理推送事件" class="headerlink" title="处理推送事件"></a>处理推送事件</h2><p>在 sw.js 文件添加下面的推送事件监听器，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Push Received.'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[Service Worker] Push had this data: "<span class="subst">$&#123;event.data.text()&#125;</span>"`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> title = <span class="string">'Push Codelab'</span>;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    body: <span class="string">'Yay it works.'</span>,</span><br><span class="line">    icon: <span class="string">'images/icon.png'</span>,</span><br><span class="line">    badge: <span class="string">'images/badge.png'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  event.waitUntil(self.registration.showNotification(title, options));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在我们触发推送消息后，浏览器会收到推送消息，再唤醒相应的服务线程并分配推送事件。我们需要监听此事件，并将通知显示出来。</p><p>收到推送消息后，会触发推送事件监听，我们通过在注册时调用 showNotification() 来创建通知并将其显示出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="string">'Push Codelab'</span>;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  body: <span class="string">'Yay it works.'</span>, <span class="comment">// 消息正文</span></span><br><span class="line">  icon: <span class="string">'images/icon.png'</span>, <span class="comment">// 图标</span></span><br><span class="line">  badge: <span class="string">'images/badge.png'</span> <span class="comment">// 标志</span></span><br><span class="line">&#125;;</span><br><span class="line">self.registration.showNotification(title, options);</span><br></pre></td></tr></table></figure><p>现在我们来测试一下，刷新浏览器，并将通知权限更改为 Use global default (Ask)，选择允许，然后在 Application 视图 Service Workers 选项下点击右边的 Push 按钮，发送模拟通知。</p><p><img src="https://gw.alicdn.com/tfs/TB1K8Z7aqagSKJjy0FhXXcrbFXa-2880-1488.png" alt="image | center"></p><p>会收到类似如下的通知：</p><p><img src="https://gw.alicdn.com/tfs/TB1HImKeMoQMeJjy0FpXXcTxpXa-716-148.png" alt="image | center"></p><h2 id="通知点击处理"><a href="#通知点击处理" class="headerlink" title="通知点击处理"></a>通知点击处理</h2><p>我们都希望用户收到通知后，去点击它，并作出一些行为，比如，打开一个链接。现在我们来加上这个处理逻辑。</p><p>在 sw.js 添加 notificationclick 事件的监听，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'notificationclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Notification click Received.'</span>);</span><br><span class="line"></span><br><span class="line">  event.notification.close();</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    clients.openWindow(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当用户点击通知时，会调用 notificationclick 事件监听器，打开淘宝首页。</p><h2 id="发送推送消息"><a href="#发送推送消息" class="headerlink" title="发送推送消息"></a>发送推送消息</h2><p>下面我们来发送实际的推送消息了。回到配套网站 <a href="https://web-push-codelab.appspot.com/?hl=zh-cn%EF%BC%8C%E5%88%B7%E6%96%B0%E5%AF%86%E9%92%A5" target="_blank" rel="noopener">https://web-push-codelab.appspot.com/?hl=zh-cn，刷新密钥</a>(因为前面的 key 可能会失效，导致发送消息不成功)，更新 scripts/main.js  的 applicationServerPublicKey，然后回到示例页面，在 Application 视图里切到 Clear storage 选项，点击下边的 Clear site data，刷新页面重新订阅消息。</p><p>复制下面这段 Json 字符串，</p><p><img src="https://gw.alicdn.com/tfs/TB1NWOTeMMPMeJjy1XcXXXpppXa-2880-1658.png" alt="image | center"></p><p>然后粘贴到配套网站的 <em>Subscription to Send To</em> 文本区域：</p><p><img src="https://gw.alicdn.com/tfs/TB1LnGTeMMPMeJjy1XcXXXpppXa-2880-1498.png" alt="image | center"></p><p>点击 send push message 按钮，回到我们的示例页面，在控制台可以看到有一句 Push had this data: “This is a test!” 说明我们已经收到了推送消息。</p><p>上面的配套网站其实就是使用 <a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">web-push 库</a> 发送消息的节点服务器。我们可以查看 <a href="https://github.com/web-push-libs/" target="_blank" rel="noopener">Github 上的 web-push-libs org</a>，看看有哪些库可以发送推送消息。</p><h2 id="取消订阅用户"><a href="#取消订阅用户" class="headerlink" title="取消订阅用户"></a>取消订阅用户</h2><p>下面介绍如何取消用户的推送消息订阅。我们需要对 PushSubscription 调用 unsubscribe()。</p><p>在 scripts/main.js 里将 initialiseUI() 中 pushButton 的点击事件修改为下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pushButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    unsubscribeUser();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscribeUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>unsubscribeUser 方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsubscribeUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，我们通过调用 getSubscription() 获取当前的订阅</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 subscription 存在，调用其 unsubscribe 方法</span></span><br><span class="line">    <span class="keyword">if</span> (subscription) &#123;</span><br><span class="line">      <span class="keyword">return</span> subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error unsubscribing'</span>, error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSubscriptionOnServer(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User is unsubscribed.'</span>);</span><br><span class="line">    isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在来试一试，刷新页面，点击 <em>Disable Push Messaging</em>，可以看到控制台输出了：</p><p><img src="https://gw.alicdn.com/tfs/TB1bLmBeMMPMeJjy1XdXXasrXXa-1878-294.png" alt="image | center"></p><p>OK，教程到这里就结束了，如果你想继续深入了解，可以点击下面这两个链接</p><ul><li>Web Fundamentals 上的 <a href="https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/?hl=zh-cn" target="_blank" rel="noopener">网络推送通知</a> 文档</li><li><a href="https://github.com/web-push-libs/" target="_blank" rel="noopener">网络推送库</a> - 网络推送库包括 Node.js、PHP、Java 和 Python。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何往 PWA 中添加推送通知功能，如果你有兴趣想了解更多关于 Web Push 技术，可以阅读这篇文章&lt;a href=&quot;&quot;&gt;《PWA系列 - Web Push 技术》&lt;/a&gt;，看一篇抵过 n 篇 Google 的文档。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>App Shell 模型介绍</title>
    <link href="http://G96968586.github.io/2017/11/29/App-Shell-%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/11/29/App-Shell-模型介绍/</id>
    <published>2017-11-29T07:35:43.000Z</published>
    <updated>2018-05-06T15:42:14.938Z</updated>
    
    <content type="html"><![CDATA[<p>App Shell 是构建 PWA 的一种常用的技术方法，同时，App Shell 也是提高页面首次渲染速度的主流方法之一。通过 App Shell 我们的应用（Web App）能够做到像 Native App 一样可靠、即时地加载到用户设备屏幕上，极大的提高了用户体验。<br><a id="more"></a><br>其实 App Shell 就是一个能够被缓存的、轻量级的界面框架，它往往是纯 HTML 片段，只包括内联 CSS 和 base64 图片，不依赖于 JS 框架，可以在加载、解析、执行 JS 之前就渲染出来，几乎消除了白屏时间，大大提高用户体验。<br>结合服务工作线程 Service Worker 的 Cache API 缓存技术，App Shell 在没有网络或弱网络的情况下能表现的非常出色。它能够将一些初始 HTML 片段快速加载到屏幕上，并从缓存获取数据渲染到页面上，整个过程不需等待，带来了类似 Native App 的流畅过渡体验。<br><img src="https://gw.alicdn.com/tfs/TB1CG2IdgMPMeJjy1XdXXasrXXa-743-550.png" alt="image | center"></p><h2 id="构建自己的-App-Shell"><a href="#构建自己的-App-Shell" class="headerlink" title="构建自己的 App Shell"></a>构建自己的 App Shell</h2><p>前面说过 App Shell 是一个轻量级界面框架，它将应用核心基础架构和 UI 同数据分离出来。因此，在构建我们的 App Shell 之前，需要明确区分页面 Shell 和动态数据。<br>理想的 App Shell 具备下面的特点：</p><ul><li>快速加载</li><li>尽可能使用较少的数据</li><li>使用本地静态缓存资源</li><li>将内容与页面导航分离开</li><li>检索和显示特定页面的内容（HTML、JSON 等）</li><li>缓存动态资源（可选）</li></ul><p>这里有一个使用 App Shell 模型的 PWA 例子可以作为参考，Jake Archibald 的<a href="https://wiki-offline.jakearchibald.com/wiki/Rick_and_Morty" target="_blank" rel="noopener">离线维基百科应用</a>。它能在用户重复访问时即时加载到屏幕上，同时使用 JS 动态获取数据，并在稍后离线缓存数据内容，供后面访问使用。下面是截图示例。<br><img src="https://gw.alicdn.com/tfs/TB1Q5g7dgMPMeJjy1XdXXasrXXa-1796-1280.jpg" alt="image | center"></p><h3 id="App-Shell-的-HTML-示例"><a href="#App-Shell-的-HTML-示例" class="headerlink" title="App Shell 的 HTML 示例"></a>App Shell 的 HTML 示例</h3><p>这里我们让示例应用初始加载时尽可能的简单，在访问示例应用时仅显示页面布局，至于数据，有些来自index 文件(内联 DOM、样式)，有些来自外部脚本、样式表。<br>所有页面 UI 和基础架构都通过服务工作线程缓存在本地，这样，后面再次访问我们的应用时，将仅检索新数据或发生改变的数据，而不需要去加载所有的数据。<br>下面是示例代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles/inline.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"header__title"</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog-container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loader"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Show a spinner or placeholders for content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  if ('serviceWorker' in navigator) &#123;</span></span><br><span class="line"><span class="undefined">    navigator.serviceWorker.register('/sw.js').then(function(registration) &#123;</span></span><br><span class="line"><span class="undefined">      // Registration was successful</span></span><br><span class="line"><span class="undefined">      console.log('ServiceWorker registration successful with scope: ', registration.scope);</span></span><br><span class="line"><span class="undefined">    &#125;).catch(function(err) &#123;</span></span><br><span class="line"><span class="undefined">      // registration failed :(</span></span><br><span class="line"><span class="undefined">      console.log('ServiceWorker registration failed: ', err);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其实就是一个普通的 HTML 页面，由于篇幅，这里把一些代码省略掉了。纵观整个页面，包括了下面三个部分：</p><ul><li>页面主干：由 HTML 和 CSS 构成的页面导航以及一些内容展示块</li><li>用于处理导航和 UI 逻辑的外部 JavaScript 文件 app.js</li><li>网络应用清单 manifest.json 和用于启用离线功能的服务工作线程加载程序 sw.js</li></ul><p>说到这，App Shell 也没有什么神秘的地方，简单理解就是 HTML 页面 + 逻辑处理文件 app.js + 服务工作线程 service-worker.js 。App Shell 也可以通过使用任意内容库或框架去编写。</p><h3 id="缓存-App-Shell"><a href="#缓存-App-Shell" class="headerlink" title="缓存 App Shell"></a>缓存 App Shell</h3><p>缓存 App Shell 实际上是通过服务工作线程来实现的。<a href="">《Service Workers 介绍》</a> 以及<a href="">《调试 Service Workers》</a> 都介绍过，这里就不多说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App Shell 是构建 PWA 的一种常用的技术方法，同时，App Shell 也是提高页面首次渲染速度的主流方法之一。通过 App Shell 我们的应用（Web App）能够做到像 Native App 一样可靠、即时地加载到用户设备屏幕上，极大的提高了用户体验。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>调试 Service Workers</title>
    <link href="http://G96968586.github.io/2017/11/29/%E8%B0%83%E8%AF%95-Service-Workers/"/>
    <id>http://G96968586.github.io/2017/11/29/调试-Service-Workers/</id>
    <published>2017-11-29T07:35:21.000Z</published>
    <updated>2018-05-06T15:43:19.099Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们来一起探讨如何使用 Chrome DevTools 中新增的 Application 面板调试和检查 Service Workers（服务工作线程）。<br><a id="more"></a><br>首先，你需要做一些准备工作，可以参考这篇<a href="https://lark.alipay.com/fgt-mobile/be9mcc/oeeik3" target="_blank" rel="noopener">《搭建你的第一个 PWA》</a>文章。为了便于调试，这里我们去 Google 实验室下载测试 Demo: <a href="https://github.com/googlecodelabs/debugging-service-workers/archive/master.zip" target="_blank" rel="noopener">debugging-service-worker</a>。<br>解压 Demo，打开 Web Server，点击 Choose Folder 将当前文件路径定位到 Demo 目录下的 work 目录。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/6b911bfcf3bcf47b.png" alt="img"></p><p>我们然后关掉 Web Server，重新再打开，在 Chrome 地址栏输入 <a href="http://127.0.0.1:8887/" target="_blank" rel="noopener">http://127.0.0.1:8887</a> （当然，前提你没有更新 Web Server 默认的端口），你可以见到下图的页面。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/40be4c5b212b8e6e.png" alt="img"></p><p>好了，进入我们的主题：Debuging Service Workers。</p><h2 id="Inspect-Manifest"><a href="#Inspect-Manifest" class="headerlink" title="Inspect Manifest"></a>Inspect Manifest</h2><p>构建 PWA 需要结合多种不同的核心技术，包括 Service Workers、Network Manifest 以及有用的技术支持，比如由：Cache Storage API、IndexedDB、Push Notifications 。Chrome DevTools 给我们提供了 Application 调试窗口，并为每种技术提供了检查器，使我们能够轻松获得各种技术的协调视图。<br>回到前面的页面，打开 DevTools ，然后选中 Application。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/15fdfa68d4a7b572.png" alt="img"></p><p>可以看到右边视图显示的是与 manifest.json 文件有关的重要信息，包括应用名称、启动网址、图标、图标大小等。你还可以发现这里有一个 <strong>Add to homescreen</strong> 按钮，它可用于模拟添加应用到用户主屏幕的效果。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/cbb979db1fdbbeb2.png" alt="img"></p><h2 id="Inspect-Service-Workers"><a href="#Inspect-Service-Workers" class="headerlink" title="Inspect Service Workers"></a>Inspect Service Workers</h2><p>检查服务工作线程，首先选中 Manifest 下方的 Service Workers 菜单项，切换到 Service Workers 视图，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/8b1f630f29fa4b88.png" alt="img"></p><p>最顶部有四个复选框，Offline、Update on reload、Bypass for network 和 Show all。</p><ul><li><strong>Offline</strong>：模拟断开网络连接。有助于快速验证服务工作线程的 fetch 事件是否正常运行。</li><li><strong>Update on reload</strong>：将用新的服务工作线程强制替换当前服务工作线程（如果开发者已更新<code>service-worker.js</code>）。通常情况下，浏览器不会强制替换，将进入等待状态，直到用户关闭包含当前网站的所有标签。</li><li><strong>Bypass for network</strong>：将强制浏览器忽略所有活动服务工作线程并从网络中获取资源。这有助于我们使用 CSS 或 JavaScript 而不需担心服务工作线程意外缓存或返回旧文件。</li><li><strong>Show all</strong>- 在不考虑来源的情况下，显示所有活动服务工作线程。</li></ul><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/6e1b168b208b2f6b.png" alt="img"></p><p> Status 字段显示当前服务工作线程的状态，绿色表示一切正常。绿色圆圈后面的数字是当前活动服务工作线程的 ID。橙色圆圈则代表有新的服务工作线程进入等待状态。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fa8a52334757c2a4.png" alt="img"></p><p>现在打开 work 目录下的 service-worker.js 文件，添加几行代码进去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Service Worker installing.&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Service Worker activating.&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>切换回 DevTools 窗口，刷新页面，可以看到控制台有日志输出，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/8ca61141042f9492.png" alt="img"></p><p> 再回到 service-worker.js 文件，我们修改一下打印的信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123; </span><br><span class="line">    console.log(&apos;A new Service Worker is installing.&apos;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123; </span><br><span class="line">    console.log(&apos;Finally active. Ready to start serving content!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刷新页面看控制台输出信息，发现只输出了一句 “A new Service Worker is installing.”。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/707c8831d42cac1d.png" alt="img"></p><p> 我们发现右边视图出现两个状态指示灯，前面提过橙色说明有新的服务工作线程进入等待状态，点击 skipWaiting 按钮强制激活新的服务工作线程。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fa7fbe42997f12db.png" alt="img"></p><p>这时候控制台输出了来自 activate 事件的处理消息 “Finally active. Ready to start serving content!”。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/677c034de2a9387a.png" alt="img"></p><p> 我们也可以不必每次都点击 skipWaiting 按钮，只需要你勾选上 Update on reload，每次刷新页面浏览器都会强制最新的服务工作线程。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/49c682842694be19.png" alt="img"></p><h2 id="Browser-Cache"><a href="#Browser-Cache" class="headerlink" title="Browser Cache"></a>Browser Cache</h2><p>服务工作线程具备强大的离线缓存文件能力。<strong>Application</strong> 视图有很多有用的工具，用于浏览和修改存储的资源，这些工具在开发期间对我们非常有用。<br>为服务工作线程添加缓存，需要添加一些代码来存储一些文件。在服务工作线程的 install 阶段，预缓存文件是一种有用的技术，可以确保在用户即将离线时关键资源可用。<br>回到 service-worker.js 文件，更新代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var CACHE_NAME = &apos;my-site-cache-v1&apos;;</span><br><span class="line">var urlsToCache = [</span><br><span class="line">  &apos;/&apos;,</span><br><span class="line">  &apos;/styles/main.css&apos;,</span><br><span class="line">  &apos;/scripts/main.js&apos;,</span><br><span class="line">  &apos;/images/smiley.svg&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  // Perform install steps</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(function(cache) &#123;</span><br><span class="line">        return cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Finally active. Ready to start serving content!&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刷新页面，在 Application 视图左边栏选中 Cache Storage 菜单项，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/c161899c1a25be78.png" alt="img"></p><p>点击 my-site-cache-v1，可以看到由服务工作线程缓存的所有文件。如果你需要从缓存中移除文件，可以右键点击该文件，然后从上下文菜单中选择 <strong>delete </strong>选项。同样，你也可以通过右键点击 my-site-cache-v1，然后选择 delete 删除整个缓存。<br>也许你已经注意到了，除 <strong>Cache Storage</strong>，还有一些与存储资源有关的其他菜单项：Local Storage、Session Storage、IndexedDB、Web SQL、Cookie 以及 Application Cache (“AppCache”)。在一个面板中精细控制每个资源是非常有用的！但是如果你想删除所有的存储资源，依次访问每个菜单项并删除其内容是相当繁琐的。更好的做法是，你可以使用 <strong>Clear storage</strong> 选项来一次性清理缓存（请注意这也将注销所有的服务工作线程）。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/ec0d649fc0854861.png" alt="img"></p><p>什么是齿轮⚙️？<br>切换到 Network 视图，刷新页面，可以看到下面图示的结果，带有齿轮图标的是第二轮请求，这些请求似乎要获取相同的资源。那齿轮代表的是什么呢？</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/198bc2a7b8f1e974.png" alt="img"></p><p> 齿轮图标表示这些请求来自服务工作线程本身。具体而言，这些是由服务工作线程的<code>install</code>处理程序提出以填充离线缓存的请求。</p><h2 id="模拟不同网络条件"><a href="#模拟不同网络条件" class="headerlink" title="模拟不同网络条件"></a>模拟不同网络条件</h2><h3 id="离线时提供请求服务"><a href="#离线时提供请求服务" class="headerlink" title="离线时提供请求服务"></a>离线时提供请求服务</h3><p>服务工作线程的杀手锏功能之一是即使在用户离线时，它们也能够为其提供缓存内容。要验证这一切是否正常运行，我们可以通过 Chrome 提供的一些网络节流工具来进行测试。<br>首先，在 service-worker.js 文件里添加下面代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        // Cache hit - return response</span><br><span class="line">        if (response) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        return fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着切换到 Application 视图，确保 Update on reload 处于勾选状态，刷新页面，重新安装新的服务工作线程，然后取消 Update on reload，勾选上 Offline 复选框。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/edaebdd8-bd67-4b31-9c9f-bf7562989b28.png" alt="img"></p><p>你可以发现 Network 前面有一个黄色警告标志，表示当前已离线。这时候刷新页面，一切顺利的话，你应该还能看到整个网站内容。切换到 Network 视图，验证 Cache Storage 是否提供所有资源。这里的 Size 表示这些资源来自 <code>(from Service Worker)</code>。表明我们的服务工作线程拦截了请求，并提供了来自缓存的响应而不是来自网络。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/c5d6c262-a2d8-4507-b08f-32d187049603.png" alt="img"></p><h3 id="测试不同网络"><a href="#测试不同网络" class="headerlink" title="测试不同网络"></a>测试不同网络</h3><p>目前很多地方 3G 和 2G 网络仍是常态。所以我们应该测试在这些弱网络的情况下，我们的应用是否还能保持高性能正常运行。</p><p>Chrome 提供了工具方便我们测试不同的网络情况。在 Application 视图下，取消 Offline，勾选上 Bypass for network。Bypass for network 将告诉浏览器，当需要发出网络请求时跳过我们的服务工作线程。这就意味着 Cache Storage 将不提供任何内容，就好像我们没有安装任何服务工作线程一样。</p><p>接下来，切换到 Network 视图，使用 Network Throttle 下拉菜单将网络速度设置为 Slow 3G。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/f9c71344-48a6-473d-9fa5-ba6136ef1774.png" alt="img"></p><p>刷新页面，现在每个资源的下载需要 2 秒左右的时间。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/da7400ae-abe5-4adf-84fa-36bb379464aa.png" alt="img"></p><p>现在，取消 Bypass for network，刷新页面，看看服务工作线程在后台运行时有何不同。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fe9a1af5-00b4-4c90-9a3c-e70e2ff64892.png" alt="img"></p><p>很明显，响应时间急速下降至每个资源仅需几毫秒。对于网络速度较慢的用户来说，这是天壤之别！</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>服务工作线程实际上就是常规的 JavaScript 文件，我们可以使用现有的工具（如 debugger 语句和断点）来调试。</p><p> 现在我们来调试 install 处理程序。</p><p>在 service-worker.js 中 install 处理程序的开头添加一个 debugger 语句。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  debugger;</span><br><span class="line">  // Perform install steps</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(function(cache) &#123;</span><br><span class="line">        return cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>切换到 Application 视图，刷新页面，点击 skipWaiting 激活新的服务工作线程。再次刷新页面触发 fetch 处理程序运行。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/0bf1ac58-5c29-4d7d-ab9e-398035751095.png" alt="img"></p><p>页面自动跳转到 Sources 视图，并在 debugger 行处于暂停状态。右下方的 Scope 检查器，可以看到当前函数作用域内对象的当前状态。</p><p>点击 event:InstallEvent 下拉菜单，可以了解有关当前作用域内对象的各种有用的信息。例如，查看 type 字段，可以验证当前事件对象是否为 install 事件。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/2f188875-8250-49fd-bd50-0b88f7b5f31a.png" alt="img"></p><p>当然，我们也可以使用断点来调试，这样会更加方便。</p><h2 id="测试推送通知"><a href="#测试推送通知" class="headerlink" title="测试推送通知"></a>测试推送通知</h2><p>也许你已经发现了页面中心有一个 <strong>Subscribe for Push Notifications</strong> 按钮，它要求用户订阅推送通知。此按钮已被远程配置，以在用户点击时请求推送通知权限。 </p><p>现在添加推送支持，打开 service-worker.js ，然后在 fetch 处理程序后添加以下几行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;push&apos;, function(event) &#123;  </span><br><span class="line">  var title = &apos;Yay a message.&apos;;  </span><br><span class="line">  var body = &apos;We have received a push message.&apos;;  </span><br><span class="line">  var icon = &apos;/images/smiley.svg&apos;;  </span><br><span class="line">  var tag = &apos;simple-push-example-tag&apos;;</span><br><span class="line">  event.waitUntil(  </span><br><span class="line">    self.registration.showNotification(title, &#123;  </span><br><span class="line">      body: body,  </span><br><span class="line">      icon: icon,  </span><br><span class="line">      tag: tag  </span><br><span class="line">    &#125;)  </span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>处理程序就绪后，就可以很轻松地模拟推送事件。切换到 Application 视图，刷新页面，点击 skipWaiting 按钮，安装最新服务工作线程，点击 Subscribe for Push Notifications 按钮，接收权限提示。</p><p><img src="https://developers.google.com/web/fundamentals/getting-started/codelabs/debugging-service-workers/img/a8a8fa8d35b0667a.png?hl=zh-cn" alt="img"></p><p>最后，点击 <strong>Update</strong> 和 <strong>Unregister</strong> 旁边的 <strong>Push</strong> 按钮，现在应该会看到在屏幕的右上角，出现一个确认服务工作线程是否按预期处理 <code>push</code> 事件的推送通知。</p><p><img src="https://developers.google.com/web/fundamentals/getting-started/codelabs/debugging-service-workers/img/eacd4c5859f5f3ff.png?hl=zh-cn" alt="img"></p><p>OK，本文就到这，后面带来《向网络应用添加推送通知》、Cache API 和构建 App Shell 有关的分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我们来一起探讨如何使用 Chrome DevTools 中新增的 Application 面板调试和检查 Service Workers（服务工作线程）。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA Cache API 介绍</title>
    <link href="http://G96968586.github.io/2017/11/15/PWA-Cache-API-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/11/15/PWA-Cache-API-介绍/</id>
    <published>2017-11-15T09:28:14.000Z</published>
    <updated>2018-05-06T15:42:19.681Z</updated>
    
    <content type="html"><![CDATA[<p>本文重点介绍 Cache 相关技术，不对 Cache 的背景做过多的介绍。希望通过该文能够让读者对 Cache 技术有更进一步的了解。<br>CacheStorage 同 App Cache、IndexedDB、LocalStorage 等一样，也是一种数据存储机制，但它能够提供精细的存储控制能力，常与 Fetch API 结合，让页端具备了完全操控请求，响应，缓存的能力，这正是页端一直非常缺乏的能力。在 PWA 中结合 Service Workers ，能够给应用带来更好的离线体验。<br><a id="more"></a></p><h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><p>CacheStorage 管理一系列 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a> 对象，它提供了多个 JS 方法用于操作 Cache 对象。Cache 跟 Worker 一样，也是暴露在 window 作用域下。下面我们开始介绍 CacheStorage、Cache 的 API 使用。</p><h3 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a>CacheStorage</h3><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> 用于获取一个 Cache 对象实例，结果通过一个 Promise 返回。  </p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "caches" is a global read-only variable, which is an instance of CacheStorage</span></span><br><span class="line">caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with your cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response;</span><br><span class="line"><span class="comment">// 先从缓存中取</span></span><br><span class="line"><span class="keyword">var</span> cachedResponse = caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取不到缓存再去发起网络请求</span></span><br><span class="line">  <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  response = r;</span><br><span class="line">  <span class="comment">// 成功之后再把数据缓存起来</span></span><br><span class="line">  caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    cache.put(event.request, response);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> response.clone();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match" target="_blank" rel="noopener">CacheStorage.match()</a> 用于检查 CacheStorage 中是否存在以 Request 为 Key 的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.match(request, options).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with the response</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response || fetch(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, r);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> r.clone();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/keys" target="_blank" rel="noopener">CacheStorage.keys()</a> 用于返回 CacheStorage 中所有 Cache 对象的 Key 列表，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something with your keyList</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/has" target="_blank" rel="noopener">CacheStorage.has()</a> 用于检查是否存在指定名称的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.has(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// true: your cache exists!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caches.has(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">hasCache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasCache) &#123;</span><br><span class="line">    someCacheSetupfunction();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(myAssets);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Handle exception here.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/delete" target="_blank" rel="noopener">CacheStorage.delete()</a> 用于删除指定名称的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.delete(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your cache is now deleted</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache 提供了已缓存的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Request</a> / <a href="https://fetch.spec.whatwg.org/#response" target="_blank" rel="noopener">Response</a> 对象体的存储管理机制。CacheStorage.open() 开发者可以使用它来获取 Cache 对象实例，使用该实例的方法去管理已缓存的 Request / Response 对象体。</p><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/put" target="_blank" rel="noopener">Cache.put()</a> 用于把 Request / Response 对象体放进指定的 Cache。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.put(request, response).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request/response pair has been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Bad response status'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.put(url, response);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> response;</span><br><span class="line"><span class="keyword">var</span> cachedResponse = caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  response = r;</span><br><span class="line">  caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    cache.put(event.request, response);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> response.clone();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/add" target="_blank" rel="noopener">Cache.add()</a> 用于获取一个 Request 的 Response，并将 Request / Response 对象体放进指定的Cache。等价于 fetch(request) + cache.put(request, response)。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cache.add(request).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request has been added to the cache</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于下面</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad response status'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.put(url, response);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.add(<span class="string">'/sw-test/index.html'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" target="_blank" rel="noopener">Cache.addAll()</a> 用于获取一组 Request 的 Response，并将该组 Request / Response 对象体放进指定的Cache。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.addAll(requests[]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// requests have been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>  Examples：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/star-wars-logo.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/bountyHunters.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/snowTroopers.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/match" target="_blank" rel="noopener">Cache.match()</a> 用于查找是否存在以 Request 为 Key 的 Cache 对象。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.match(request, &#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with the response</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We only want to call event.respondWith() if this is a GET request for an HTML document.</span></span><br><span class="line">  <span class="keyword">if</span> (event.request.method === <span class="string">'GET'</span> &amp;&amp;</span><br><span class="line">      event.request.headers.get(<span class="string">'accept'</span>).indexOf(<span class="string">'text/html'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling fetch event for'</span>, event.request.url);</span><br><span class="line">    event.respondWith(</span><br><span class="line">      fetch(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'Fetch failed; returning offline page instead.'</span>, e);</span><br><span class="line">        <span class="keyword">return</span> caches.open(OFFLINE_CACHE).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cache.match(OFFLINE_URL);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/matchAll" target="_blank" rel="noopener">Cache.matchAll()</a> 用于查找是否存在一组以 Request 为Key的 Cache 对象组。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.matchAll(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something with the response array</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.matchAll(<span class="string">'/images/'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">      cache.delete(element);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank" rel="noopener">Cache.delete()</a> 用于删除以 Request 为 Key 的 Cache Entry。注意，Cache 不会过期，只能显式<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank" rel="noopener">删除</a> 。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.delete(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">true</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//your cache entry has been deleted</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.delete(<span class="string">'/images/image.png'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    someUIUpdateFunction();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">MDN Cache API</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">MDN CacheStorage API</a><br><a href="https://www.atatech.org/articles/74883" target="_blank" rel="noopener">PWA系列 - Cache 技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文重点介绍 Cache 相关技术，不对 Cache 的背景做过多的介绍。希望通过该文能够让读者对 Cache 技术有更进一步的了解。&lt;br&gt;CacheStorage 同 App Cache、IndexedDB、LocalStorage 等一样，也是一种数据存储机制，但它能够提供精细的存储控制能力，常与 Fetch API 结合，让页端具备了完全操控请求，响应，缓存的能力，这正是页端一直非常缺乏的能力。在 PWA 中结合 Service Workers ，能够给应用带来更好的离线体验。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Service Workers 介绍</title>
    <link href="http://G96968586.github.io/2017/10/25/Service-Workers-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/10/25/Service-Workers-介绍/</id>
    <published>2017-10-25T09:08:27.000Z</published>
    <updated>2018-05-06T15:43:00.249Z</updated>
    
    <content type="html"><![CDATA[<p>PWA 具备丰富的离线体验、定期的后台同步以及原生应用的推送通知功能，离不开 Service Workers 在背后提供的技术基础。<br><a id="more"></a></p><h2 id="什么是-Service-Workers"><a href="#什么是-Service-Workers" class="headerlink" title="什么是 Service Workers"></a>什么是 Service Workers</h2><p>Service Workers，即服务工作线程，是浏览器在后台独立于网页运行的脚本，它不受页面窗口生命周期的限制。因为 Service Workers 是一种事件驱动型的 worker，生命周期与页面无关. 关联页面未关闭时, 它也可以退出, 没有关联页面时, 它也可以启动。</p><h2 id="Service-Workers-生命周期"><a href="#Service-Workers-生命周期" class="headerlink" title="Service Workers 生命周期"></a>Service Workers 生命周期</h2><p>Service Workers 初始化安装时的简化生命周期图：<br><img src="https://gw.alicdn.com/tfs/TB12CznbwMPMeJjy1XdXXasrXXa-702-685.png" alt="image | center"></p><p>Service Workers 生命周期的目的：</p><ul><li>实现离线优先</li><li>在不打断现有 Service Workers 的情况下，准备好一个新的 Service Workers</li><li>Service Workers 注册的作用域下的页面, 同一时间只由一个 Service Workers 控制</li><li>确保你的网站只有一个版本在运行</li></ul><p>Service Workers 注册成功，即 <code>navigator.serviceWorker.register</code> 返回成功，并不意味着它已经完成安装或已经激活，只能说明 worker 的脚本被成功解析，此时处于 installing 状态，install 事件被触发，一般在 install 事件的回调处理函数中提前缓存相关的静态文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'xxx'</span>;</span><br><span class="line">...</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果文件缓存失败，那安装步骤将会失败，Service Workers 也无法激活。如果发生这种情况，也不必担心，它下次会再试一次。如果安装成功，Service Workers 将会进入 installed / waiting 状态，此时，已准备好接管页面已有的 Service Workers，从而控制页面。<br>Service Workers 满足下面条件其中之一，就会进入 activating 状态：</p><ul><li>当前没有 active worker 在运行</li><li>代码调用了 self.skipWaiting() 跳过 waiting 状态</li><li>用户关闭页面, 释放了当前处于 active 状态的 worker</li><li>系统在一定时间后释放了当前处于 active 状态的 worker</li></ul><p>在 activating 状态，activate 事件被触发，一般在 activate 事件的回调处理函数中清除旧缓存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'pages-cache-v1'</span>, <span class="string">'blog-posts-cache-v1'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果 Service Workers 激活成功，将会进入 activated 状态，此时，该 worker 将会对其作用域内的所有页面进行控制，可以处理一些功能事件, 比如 fetch, push, message。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// Do stuff with fetch events</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// Do stuff with postMessages received from document</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Service Workers 对页面进行控制后，并不会一直保持着 Running 状态。它会处于两种状态的互换：</p><ul><li>为了节省内存，不需要处理事件和消息的 Service Workers 会处于 Stopped 状态，即使关联页面未关闭</li><li>页面发出网络请求或消息后，Service Workers 会处于 Running 状态，处理 fetch 和 message 事件，即使全部关联文档都已关闭</li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>目前除了 Chrome 之外，Firefox 和 Opera 也已经支持 Service Workers。Edge、Safari 当前正在开发中。<a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">is ServiceWork ready</a> 这里可以查看所有浏览器的支持情况。</p><h3 id="需要-Https"><a href="#需要-Https" class="headerlink" title="需要 Https"></a>需要 Https</h3><p>本地开发可以通过 localhost 使用 Service Workers，但部署到线上环境需要服务器支持 Https。</p><h2 id="注册-Service-Workers"><a href="#注册-Service-Workers" class="headerlink" title="注册 Service Workers"></a>注册 Service Workers</h2><p>首先检查浏览器是否支持 Service Worker API ，如果支持，则注册 Service Worker。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">             .register(<span class="string">'./service-worker.js'</span>)</span><br><span class="line">             .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); </span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>页面正常加载时，就会调用 register()，注意 register 方法参数所传的脚本路径，这里注册的 service-worker.js 脚本位于根目录下，这意味着 Service Worker 的作用域将是整个来源。换句话说，Service Worker 将接收此网站上所有事项的 fetch 事件。如果我们在 /example/service-worker.js 处注册Service Worker 文件，则 Service Worker 将只能看到网址以 /example/ 开头（即 /example/page1/、/example/page2/）的页面的 fetch 事件。<br>这时候可以通过在 Chrome 浏览器输入 chrome://inspect/#service-workers 来检查 Service Worker 是否已启用。</p><h2 id="安装服务工作线程"><a href="#安装服务工作线程" class="headerlink" title="安装服务工作线程"></a>安装服务工作线程</h2><p>前面提到过，Service Workers 注册成功，说明 service-worker.js 脚本被成功解析，此时处于 installing 状态，install 事件被触发，此时我们可以在 install 事件回调里决定想要缓存哪些文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'weatherPWA'</span>;</span><br><span class="line"><span class="keyword">var</span> filesToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/styles/main.css'</span>,</span><br><span class="line">  <span class="string">'/script/main.js'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform install steps</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>首先，我们需要通过 caches.open() 打开缓存并提供一个缓存名称。缓存打开后，我们便可调用 cache.addAll()，这个带有网址列表参数的方法随即从服务器获取文件，并将响应添加到缓存内。event.waitUntil() 方法带有 promise 参数并使用它来判断安装所花费的时间以及安装是否成功。</p><h2 id="缓存和返回请求"><a href="#缓存和返回请求" class="headerlink" title="缓存和返回请求"></a>缓存和返回请求</h2><p>Service Workers 激活后，开始处理一些功能事件。下面提供一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Cache hit - return response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里添加了 fetch 事件的监听，在 event.respondWith() 里传入 caches.match() 方法，caches.match() 会对 fetch 请求事件进行分析，检查它是否位于缓存内，并从 Service Workers 所创建的任何缓存中查找缓存的结果。如果发现匹配的响应，就返回缓存的值，否则，将调用 fetch 发出网络请求，并将请求拿到的数据作为结果返回。<br>如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Cache hit - return response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IMPORTANT: Clone the request. A request is a stream and</span></span><br><span class="line">        <span class="comment">// can only be consumed once. Since we are consuming this</span></span><br><span class="line">        <span class="comment">// once by cache and once by the browser for fetch, we need</span></span><br><span class="line">        <span class="comment">// to clone the response.</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone();</span><br><span class="line"><span class="comment">// 在 fetch 请求中添加对 .then() 的回调。</span></span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确保响应有效，检查并确保响应的状态为 200，确保响应类型为 basic，亦即由自身发起的请求。 这意味着，对第三方资产的请求不会添加到缓存</span></span><br><span class="line">            <span class="keyword">if</span>(!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IMPORTANT: Clone the response. A response is a stream</span></span><br><span class="line">            <span class="comment">// and because we want the browser to consume the response</span></span><br><span class="line">            <span class="comment">// as well as the cache consuming the response, we need</span></span><br><span class="line">            <span class="comment">// to clone it so we have two streams.</span></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="更新-Service-Workers"><a href="#更新-Service-Workers" class="headerlink" title="更新 Service Workers"></a>更新 Service Workers</h2><p>前面提到的 service-worker.js 会在什么情况下请求更新呢？一般有两种更新方式。</p><ul><li>强制更新<br>距离上一次更新检查已超过24小时, 会忽略浏览器缓存, 强制到服务器更新一次</li><li>检查更新<ul><li>第一次访问作用域里的页面</li><li>距离上一次更新检查已超过24小时</li><li>有功能性事件发生, 比如 push, sync</li><li>在 Service Worker URL 发生变化时调用了.register()方法</li><li>service-worker.js 的缓存时间已超出其头部的 max-age 设置的时间 (注: max-age 大于24小时, 会使用24小时作为其值).</li><li>service-worker.js 的代码只要有一个字节发生了变化, 就会触发更新, 将其视为“新服务工作线程”</li></ul></li></ul><p>一个新的 Service Worker 启动时，将会触发 install 事件，但由于旧的 Service Worker 仍然控制着当前的页面，因此，新的 Service Worker 进入了 waiting 状态。当网站上当前打开的页面关闭时，旧的 Service Worker 就会终止，新的 Service Worker 将会取得控制权，此时会触发 activate 事件。<br>在 activate 回调中的一个常见任务是缓存管理。原因在于，如果在安装步骤中清除了任何旧的缓存，则继续控制所有当前页面的任何旧的 Service Worker 将突然无法从缓存中提供文件。<br>举个例子，比如说我们有一个名为 ‘my-site-cache-v1’ 的缓存，我们想要将该缓存拆分为一个页面缓存和一个博文缓存。这就意味着在安装步骤中我们创建了两个缓存：‘pages-cache-v1’ 和 ‘blog-posts-cache-v1’，且在激活步骤中我们要删除旧的 ‘my-site-cache-v1’。</p><p>以下代码将执行此操作，具体做法为：遍历服务工作线程中的所有缓存，并删除未在缓存白名单中定义的任何缓存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'pages-cache-v1'</span>, <span class="string">'blog-posts-cache-v1'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Service-Workers-的退出"><a href="#Service-Workers-的退出" class="headerlink" title="Service Workers 的退出"></a>Service Workers 的退出</h2><p>Service Workers 在什么情况下会被停止呢？</p><p>（1）ServiceWorker JS 有任何异常，都会导致 ServiceWorker 线程退出。包括但不限于，JS 文件存在语法错误， ServiceWorker 安装失败/ 激活失败，ServiceWorker JS 执行时出现未捕获的异常。</p><p>（2）ServiceWorker 功能事件处理完成，处于空闲状态，ServiceWorker 线程会自动退出。</p><p>（3）ServiceWorker JS 执行时间过长，ServiceWorker 线程会自动退出。比如， ServiceWorker JS 执行时间超过30秒，或 Fetch 请求在5分钟内还未完成。</p><p>（4）浏览器会周期性检查各个 ServiceWorker 线程是否可以退出， 一般在启动ServiceWorker线程时会检查一次。</p><p>（5）为了方便开发者调试， Chromium 进行了特殊处理， 在连上 devtools 之后，ServiceWorker 线程不会退出。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.atatech.org/articles/78747" target="_blank" rel="noopener">PWA系列 - Service Workers 生命周期</a><br><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">Service Workers: an Introduction</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PWA 具备丰富的离线体验、定期的后台同步以及原生应用的推送通知功能，离不开 Service Workers 在背后提供的技术基础。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>学习搭建你的第一个 PWA</title>
    <link href="http://G96968586.github.io/2017/10/25/PWA/"/>
    <id>http://G96968586.github.io/2017/10/25/PWA/</id>
    <published>2017-10-25T07:28:03.000Z</published>
    <updated>2018-05-06T13:28:47.291Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 PWA ？ PWA 有哪些特点？PWA 在国内的发展情况怎么样？相对传统的 web 页面，PWA 能够给我们带来更多什么优势？想了解这些问题，可以看看这篇文章<a href="https://huangxuan.me/2017/02/09/nextgen-web-pwa/" target="_blank" rel="noopener">《下一代 Web 应用模型 —— Progressive Web App》</a>。本文的目的是教你如何搭建一个 PWA 应用，带你从中了解到 PWA 的一些技术实现细节和注意事项。<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Chrome 52 或更高版本</li><li>安装 <a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=zh-cn" target="_blank" rel="noopener">Web Server for Chrome</a> <img src="https://gw.alicdn.com/tfs/TB1OkN2SpXXXXcJaFXXXXXXXXXX-350-228.png_100x100.jpg" alt="image | center"><br>，当然，或使用自己选择的网络服务器</li><li>IDE 或文本编辑器</li><li>官方示例代码 <a href="https://github.com/googlecodelabs/your-first-pwapp/archive/master.zip" target="_blank" rel="noopener">-&gt;传送门</a></li></ul><h2 id="解压代码"><a href="#解压代码" class="headerlink" title="解压代码"></a>解压代码</h2><p>解压官方代码，你会发现在文件夹 your-first-pwapp-master 里有下面的目录结构：</p><p>├── <a href="http://CONTRIBUTING.md" target="_blank" rel="noopener">CONTRIBUTING.md</a><br>├── final<br>├── LICENSE<br>├── <a href="http://README.md" target="_blank" rel="noopener">README.md</a><br>├── resources<br>├── step-02<br>├── step-04<br>├── step-05<br>├── step-06<br>├── step-07<br>├── step-08<br>├── work<br>│    ├── favicon.ico<br>│    ├── images<br>│    ├── index.html -&gt; 后面会提到的 App Shell<br>│    ├── scripts<br>│    ├── styles</p><h2 id="验证-Web-Server-for-Chrome"><a href="#验证-Web-Server-for-Chrome" class="headerlink" title="验证 Web Server for Chrome"></a>验证 Web Server for Chrome</h2><p>首次安装完 Web Server for Chrome 后，打开它，会看到下面的窗口，<br><img src="https://gw.alicdn.com/tfs/TB1kXGVSpXXXXXsXXXXXXXXXXXX-1728-1436.png_500x500.jpg" alt="image | center"></p><p>点击 choose folder 按钮，然后选择 work 文件夹，<br><img src="https://gw.alicdn.com/tfs/TB1Ps5vSpXXXXcrXFXXXXXXXXXX-918-456.png_500x500.jpg" alt="image | center"></p><p>在 Options 下，选中“Automatically show index.html”旁边的框，如下所示：<br><img src="https://gw.alicdn.com/tfs/TB1_fCvSpXXXXckXFXXXXXXXXXX-580-712.png_400x400.jpg" alt="image | center"></p><p>你也可以修改默认的端口号：8887<br>然后将标记为“Web Server:STARTED”的切换按钮向左滑动，然后向右滑动，停止并重启服务器。<br>现在打开 Chrome，按住 option + command + I 进入开发者工具模式，再按住 shift + command + M进入移动端模式，访问 <a href="http://127.0.0.1:8887" target="_blank" rel="noopener">http://127.0.0.1:8887</a> ，将会看到下面的页面，<br><img src="https://gw.alicdn.com/tfs/TB1fzSJSpXXXXX7XpXXXXXXXXXX-758-1340.png_500x500.jpg" alt="image | center"></p><p>有一个转不停的菊花。</p><h2 id="构建-App-Shell"><a href="#构建-App-Shell" class="headerlink" title="构建 App Shell"></a>构建 App Shell</h2><p>App Shell 是一个能够被缓存的、轻量级的界面框架，它往往是纯 HTML 片段，只包括内联 CSS 和 base64 图片，不依赖于 JS 框架，是确保获得可靠而又出色性能的组件之一。它的第一次加载速度非常快，并且能够立即缓存。“缓存”意味着 Shell 文件一旦通过网络完成加载，就会保存到本地设备中。以后每当用户打开应用时，就会自动从本地设备的缓存中打开 Shell 文件，这样应用就能超快启动。<br><img src="https://gw.alicdn.com/tfs/TB1KXmVSpXXXXXBXXXXXXXXXXXX-1249-923.jpg" alt="image | center"></p><p>App Shell 将核心应用基础架构、 UI 与数据分离。所有 UI 和基础架构都利用服务工作线程缓存在本地，这样在后续加载时，PWA 只需检索必要的数据，而不必加载所有内容。换句话讲，App Shell 就类似于你在开发 Native 应用时需要向应用商店发布的一组代码。它是让你的应用成功起步所需的核心组件，但可能并不包含数据。</p><h3 id="设计-App-Shell"><a href="#设计-App-Shell" class="headerlink" title="设计 App Shell"></a>设计 App Shell</h3><p>第一步是将设计细分成其核心组件。</p><p>问问自己：</p><ul><li><p>哪些内容需要立即呈现在屏幕上？</p></li><li><p>还有哪些其他 UI 组件对我们的应用很重要？</p></li><li><p>App Shell 需要哪些支持资源？例如图像、JavaScript、样式等。</p></li></ul><p>示例代码是一个天气应用，将其作为我们的第一个 Progressive Web App。其关键组件将包括：</p><ul><li>标头，其中包含标题和添加/刷新按钮</li><li>预报卡片容器</li><li>预报卡片模板</li><li>用于添加新城市的对话框</li><li>加载指示器</li></ul><h3 id="实现-App-Shell"><a href="#实现-App-Shell" class="headerlink" title="实现 App Shell"></a>实现 App Shell</h3><p>在示例代码 work 目录下，找到 index.html，这是一个实现好的 App Shell，里面已经完成了大部分的 UI，接下来，可以着手连接代码，让一切运转起来！</p><p>在 work 目录下找到 script/app.js，打开 app.js 可以找到以下内容：</p><ul><li>一个 <code>app</code> 对象，其中包含应用所需的一些关键信息。</li><li>标头中所有按钮 (<code>add/refresh</code>) 和“Add City”对话框中所有按钮 (<code>add/cancel</code>) 的事件侦听器。</li><li>一个用于添加或更新预报卡片的方法 (<code>app.updateForecastCard</code>)。</li><li>一个用于从 Firebase Public Weather API 获取最新天气预报数据的方法 (<code>app.getForecast</code>)。</li><li>一个用于遍历现有卡片并调用 <code>app.getForecast</code> 以获取最新预报数据的方法 (<code>app.updateForecasts</code>)。</li><li>可用来快速测试渲染效果的一些虚假数据 (<code>initialWeatherForecast</code>)。</li></ul><p>示例代码提供了 mock 的天气预报数据，为了了解数据是如何渲染的，我们取消 <code>index.html</code> 文件底部的以下行的注释：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;script src="scripts/app.js" async&gt;&lt;/script&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，取消 <code>app.js</code> 文件底部的以下行的注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.updateForecastCard(initialWeatherForecast);</span></span><br></pre></td></tr></table></figure><p>刷新浏览器，你将看到如下图所示的界面：</p><p><img src="https://gw.alicdn.com/tfs/TB14XC0SpXXXXXHXXXXXXXXXXXX-754-1338.png_500x500.jpg" alt="image | center"></p><h2 id="从快速首次加载开始"><a href="#从快速首次加载开始" class="headerlink" title="从快速首次加载开始"></a>从快速首次加载开始</h2><p>Progressive Web App 应启动迅速，并且立即就能使用。在目前状态下，我们的天气应用虽启动迅速，却无法使用，因为没有任何数据。我们可以发出 AJAX 请求来获取该数据，但那会额外增加一个请求，使首次加载时间变得更长。可以改为在首次加载时提供真实数据。</p><h3 id="注入天气预报数据"><a href="#注入天气预报数据" class="headerlink" title="注入天气预报数据"></a>注入天气预报数据</h3><p>在示例代码中，模拟服务器将天气预报直接注入 JavaScript 中，但在生产应用中，最新天气预报数据将由服务器根据用户的 IP 地址地理定位进行注入。</p><p>代码已经包含我们即将注入的数据。这就是前面步骤中使用的 <code>initialWeatherForecast</code>。</p><h3 id="区分首次运行"><a href="#区分首次运行" class="headerlink" title="区分首次运行"></a>区分首次运行</h3><p>我们怎么知道什么时候显示这些信息呢？因为未来加载时天气应用将从缓存中获取，届时这些信息可能不再相关了。比如，用户在后续访问时加载应用，他们可能已改换城市，因此，我们需要加载的是这些城市的信息，而不一定是他们查询过的第一个城市。</p><p>用户首选项（比如用户订阅的城市列表）应利用 IndexedDB 或其他快速存储机制存储在本地。为尽可能简化此代码实验室，我们使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>，但它并非生产应用的理想选择，因为它是一种封闭的同步存储机制，在某些设备上可能会运行得非常缓慢。</p><p>首先，让我们添加必要的代码来保存用户首选项。在 app.js 文件中，找到下面的 TODO 注释，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add saveSelectedCities function here</span></span><br></pre></td></tr></table></figure><p>在注释下方添加下面的代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save list of cities to localStorage.</span></span><br><span class="line">  app.saveSelectedCities = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> selectedCities = <span class="built_in">JSON</span>.stringify(app.selectedCities);</span><br><span class="line">    localStorage.selectedCities = selectedCities;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>接下来，添加启动代码，以检查用户是否保存了任何城市并渲染这些城市，或使用注入的数据。找到以下注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add startup code here</span></span><br></pre></td></tr></table></figure><p>并在注释下方添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Code required to start the app</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">NOTE:</span>To simplify this codelab, we've used localStorage.</span></span><br><span class="line"><span class="comment">   *   localStorage is a synchronous API and has serious performance</span></span><br><span class="line"><span class="comment">   *   implications.It should not be used in production applications!</span></span><br><span class="line"><span class="comment">   *   Instead, check out IDB (https://www.npmjs.com/package/idb) or</span></span><br><span class="line"><span class="comment">   *   SimpleDB (https://gist.github.com/inexorabletash/c8069c042b734519680c)</span></span><br><span class="line"><span class="comment">   ************************************************************************/</span></span><br><span class="line"></span><br><span class="line">  app.selectedCities = localStorage.selectedCities;</span><br><span class="line">  <span class="keyword">if</span> (app.selectedCities) &#123;</span><br><span class="line">    app.selectedCities = <span class="built_in">JSON</span>.parse(app.selectedCities);</span><br><span class="line">    app.selectedCities.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">      app.getForecast(city.key, city.label);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* The user is using the app for the first time, or the user has not</span></span><br><span class="line"><span class="comment">     * saved any cities, so show the user some fake data.A real app in this</span></span><br><span class="line"><span class="comment">     * scenario could guess the user's location via IP lookup and then inject</span></span><br><span class="line"><span class="comment">     * that data into the page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app.updateForecastCard(initialWeatherForecast);</span><br><span class="line">    app.selectedCities = [</span><br><span class="line">      &#123;<span class="attr">key</span>: initialWeatherForecast.key, <span class="attr">label</span>: initialWeatherForecast.label&#125;</span><br><span class="line">    ];</span><br><span class="line">    app.saveSelectedCities();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动代码会检查本地存储中是否存储了任何城市。如果存储了城市，它就会解析本地存储数据，然后为保存的每个城市显示预报卡片。如果没有存储城市，启动代码会使用虚假的预报数据，并将其保存为默认城市。</p><p>最后，我们需要修改“Add City”按钮处理程序，以便将所选的城市添加到本地存储。</p><p>更新 <code>butAddCity</code> 点击处理程序，以便匹配以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'butAddCity'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Add the newly selected city</span></span><br><span class="line">    <span class="keyword">var</span> select = <span class="built_in">document</span>.getElementById(<span class="string">'selectCityToAdd'</span>);</span><br><span class="line">    <span class="keyword">var</span> selected = select.options[select.selectedIndex];</span><br><span class="line">    <span class="keyword">var</span> key = selected.value;</span><br><span class="line">    <span class="keyword">var</span> label = selected.textContent;</span><br><span class="line">    <span class="keyword">if</span> (!app.selectedCities) &#123;</span><br><span class="line">      app.selectedCities = [];</span><br><span class="line">    &#125;</span><br><span class="line">    app.getForecast(key, label);</span><br><span class="line">    app.selectedCities.push(&#123;<span class="attr">key</span>: key, <span class="attr">label</span>: label&#125;);</span><br><span class="line">    app.saveSelectedCities();</span><br><span class="line">    app.toggleAddDialog(<span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>新添加的内容是 <code>app.selectedCities</code> 的初始化，以及对 <code>app.selectedCities.push()</code> 和 <code>app.saveSelectedCities()</code> 的调用。</p><p>OK，再次刷新浏览器，运行时，应用应该会立即向用户显示来自 <code>initialWeatherForecast</code> 的天气预报数据。点击右上角的图标，增加新的城市，并验证应用是否加载了两个天气预报卡片并显示了最新信息。</p><h2 id="利用-Service-Worker-预缓存-App-Shell"><a href="#利用-Service-Worker-预缓存-App-Shell" class="headerlink" title="利用 Service Worker 预缓存 App Shell"></a>利用 Service Worker 预缓存 App Shell</h2><p>Progressive Web App 必须快速并且可安装，这意味着它们能够在在线、离线以及间歇性、弱网络连接下工作。要实现此目标，我们需要利用服务工作线程缓存我们的 App Shell，让其始终都能快速而又可靠地投入使用。</p><h3 id="在服务工作线程可用时注册它"><a href="#在服务工作线程可用时注册它" class="headerlink" title="在服务工作线程可用时注册它"></a>在服务工作线程可用时注册它</h3><p>使应用离线工作的第一步是注册一个 Service Worker 服务工作线程，这是一个无需打开网页或用户交互便可实现后台功能的脚本。</p><p>只需要两步骤：</p><ul><li>让浏览器将 JavaScript 文件注册为服务工作线程</li><li>创建包含此服务工作线程的 JavaScript 文件</li></ul><p>首先我们需要检查浏览器是否支持服务工作线程，如果支持，则注册服务工作线程。在 app.js 找到下面注释之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add service worker code here</span></span><br></pre></td></tr></table></figure><p>添加下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">             .register(<span class="string">'./service-worker.js'</span>)</span><br><span class="line">             .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存网站资源"><a href="#缓存网站资源" class="headerlink" title="缓存网站资源"></a>缓存网站资源</h3><p>注册服务工作线程后，用户首次访问页面时将会触发安装事件。在此事件处理程序内，我们将缓存应用所需的全部资源。触发服务工作线程时，它会打开 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">caches</a> 对象并为其填充加载 App Shell 所需的资源。在 work 目录下，创建 service-worker.js 文件，这个文件之所以必须位于应用的根文件夹内，是因为服务工作线程的作用域由该文件所在的目录定义。在 service-worker.js 添加下面代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'weatherPWA-step-6-1'</span>;</span><br><span class="line"><span class="keyword">var</span> filesToCache = [];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Install'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先，我们需要通过 <code>caches.open()</code> 打开缓存并提供一个缓存名称。提供缓存名称可让我们对文件进行版本控制，或将数据与 App Shell 分开，以便我们能轻松地更新某个数据，而不会影响其他数据。</p><p>缓存打开后，我们便可调用 <code>cache.addAll()</code>，这个带有网址列表参数的方法随即从服务器获取文件，并将响应添加到缓存内。遗憾的是，<code>cache.addAll()</code> 具有原子性，如果任何一个文件失败，整个缓存步骤也将失败！</p><h3 id="使用-DevTools-了解和调试服务工作线程"><a href="#使用-DevTools-了解和调试服务工作线程" class="headerlink" title="使用 DevTools 了解和调试服务工作线程"></a>使用 DevTools 了解和调试服务工作线程</h3><p>重新加载页面之前，打开 DevTools，转至 <strong>Application </strong>面板的 <strong>Service Worker </strong>窗口，如下所示：</p><p><img src="https://gw.alicdn.com/tfs/TB1it5fSpXXXXceapXXXXXXXXXX-632-419.png" alt="image | center"></p><p>如果看到类似于这样的空白页面，就表示当前打开的页面没有注册服务工作线程。</p><p>现在，重新加载页面。Service Worker 窗口现在应该像下面这样，表示页面正在运行服务工作线程。</p><p><img src="https://gw.alicdn.com/tfs/TB1jgh6SpXXXXayaVXXXXXXXXXX-1490-858.png_600x600" alt="image | center"></p><p>现在，我们将要插入一点其他内容，说明我们在开发服务工作线程时可能会遇到的 Gotcha。为了说明这一问题，需要在 <code>service-worker.js</code> 文件中的 <code>install</code> 侦听器下面添加 <code>activate</code> 事件侦听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>activate</code> 事件会在服务工作线程启动时触发。</p><p>打开 DevTools Console，重新加载页面，切换到 Application 面板中的 Service Worker 窗口，然后点击激活的服务工作线程上的 Inspect。可以看到 <code>[ServiceWorker] Activate</code> 消息记录到控制台，但并没有发生。请查看 Service Worker 窗口，我们会看到新的服务工作线程（包含激活事件侦听器）处于“等待”状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Hd1HSpXXXXa5XFXXXXXXXXXX-1494-534.png_600x600" alt="image | center"></p><p>从根本上说，只要页面有打开的标签，以前的服务工作线程就会继续控制页面。因此，你可以关闭然后重新打开页面，或者按 <strong>skipWaiting </strong>按钮，但是更长期的解决方案只需启用 DevTools 的 Service Worker 窗口上的 <strong>Update on Reload </strong>复选框。如果启用此复选框，服务工作线程会在每次页面重新加载时强制更新。</p><p>现在启用 <strong>update on reload </strong>复选框，并重新加载页面，以确认新的服务工作线程被激活。</p><p><strong>注：</strong> 你可能会在 Application 面板的 Service Worker 窗口中发到一个错误（类似于以下内容），完全可以忽略此错误。</p><p><img src="https://gw.alicdn.com/tfs/TB1v.KDSpXXXXcCXFXXXXXXXXXX-424-73.png" alt="image | center"></p><p>有关在 DevTools 中检查和调试服务工作线程的内容就到此结束。现在，我们来展开 <code>activate</code> 事件侦听器，添加以下逻辑来更新缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== cacheName) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Removing old cache'</span>, key);</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> self.clients.claim();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码可以确保我们的服务工作线程在任何 App Shell 文件更改时更新其缓存。为了使其工作，我们需要在服务工作线程文件的顶部增加 <code>cacheName</code> 变量。</p><p>最后，我们更新 App Shell 所需的文件列表。在数组中，我们需要加入应用所需的全部文件，包括图像、JavaScript、样式表等。在接近 <code>service-worker.js</code> 文件顶部的地方，使用以下代码替换 <code>var filesToCache = [];</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filesToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/index.html'</span>,</span><br><span class="line">  <span class="string">'/scripts/app.js'</span>,</span><br><span class="line">  <span class="string">'/styles/inline.css'</span>,</span><br><span class="line">  <span class="string">'/images/clear.png'</span>,</span><br><span class="line">  <span class="string">'/images/cloudy-scattered-showers.png'</span>,</span><br><span class="line">  <span class="string">'/images/cloudy.png'</span>,</span><br><span class="line">  <span class="string">'/images/fog.png'</span>,</span><br><span class="line">  <span class="string">'/images/ic_add_white_24px.svg'</span>,</span><br><span class="line">  <span class="string">'/images/ic_refresh_white_24px.svg'</span>,</span><br><span class="line">  <span class="string">'/images/partly-cloudy.png'</span>,</span><br><span class="line">  <span class="string">'/images/rain.png'</span>,</span><br><span class="line">  <span class="string">'/images/scattered-showers.png'</span>,</span><br><span class="line">  <span class="string">'/images/sleet.png'</span>,</span><br><span class="line">  <span class="string">'/images/snow.png'</span>,</span><br><span class="line">  <span class="string">'/images/thunderstorm.png'</span>,</span><br><span class="line">  <span class="string">'/images/wind.png'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>现在应用现在还不能离线运行。我们虽然已缓存了 App Shell 组件，但仍需从本地缓存加载它们。</p><h3 id="从缓存提供-App-Shell"><a href="#从缓存提供-App-Shell" class="headerlink" title="从缓存提供 App Shell"></a>从缓存提供 App Shell</h3><p>服务工作线程提供了拦截 Progressive Web App 发出的请求并在服务工作线程内对它们进行处理的能力。这意味着我们可以决定想要如何处理请求，并可提供我们自己的已缓存响应。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something interesting with the fetch here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在我们从缓存提供 App Shell。将以下代码添加到 <code>service-worker.js</code> 文件的底部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Fetch'</span>, e.request.url);</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>caches.match()</code> 会由内而外对触发<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener"> fetch </a>事件的网络请求进行评估，并检查以确认它是否位于缓存内。它随即使用已缓存版本作出响应，或者利用 <code>fetch</code> 从网络获取一个副本。<code>response</code> 通过 <code>e.respondWith()</code> 传回至网页。</p><p>又到测试环节了，现在我们的应用可以离线运行了。重新加载页面，然后转至 DevTools 的 <strong>Application</strong> 面板的 <strong>Cache Storage</strong> 窗口。展开这个部分，可以看到左侧列出的 App Shell 缓存的名称。当我们点击 App Shell 缓存后，可以看到它当前缓存的所有资源。</p><p><img src="https://gw.alicdn.com/tfs/TB1EXiaSpXXXXabaFXXXXXXXXXX-1466-862.png_600x600" alt="image | center"></p><p>现在，测试一下离线模式。回到 DevTools 的 <strong>Service Worker</strong> 窗口，然后勾上 <strong>Offline</strong> 复选框。启用后，可以看到 <strong>Network</strong> 面板标签旁边显示很小的黄色警告图标。这表示当前正处于离线状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Zo1oSpXXXXcdaXXXXXXXXXXX-1292-524.png_600x600" alt="image | center"></p><p>重新刷新页面，你会发现天气预报卡片还是出来了！请注意它加载初始（虚假）天气数据的方式。</p><p><img src="https://gw.alicdn.com/tfs/TB1l3udSpXXXXbRapXXXXXXXXXX-752-898.png_400x400" alt="image | center"></p><p>下一步就是修改应用和服务工作线程逻辑，以便能够缓存天气数据，并在应用处于离线状态时从缓存中返回最新数据。</p><p>如果要开始刷新和清除已保存的所有数据（localStoarge、indexedDB 数据、缓存文件）以及移除任何服务工作线程，请使用 Application 标签中的 Clear storage。</p><h2 id="使用-Service-Worker-缓存天气预报数据"><a href="#使用-Service-Worker-缓存天气预报数据" class="headerlink" title="使用 Service Worker 缓存天气预报数据"></a>使用 Service Worker 缓存天气预报数据</h2><h3 id="拦截网络请求并缓存响应"><a href="#拦截网络请求并缓存响应" class="headerlink" title="拦截网络请求并缓存响应"></a>拦截网络请求并缓存响应</h3><p>我们需要修改服务工作线程，以拦截发给 weather API 的请求，并将其响应存储在缓存内，以便我们在稍后访问它们。</p><p>我们在服务工作线程中添加一个 <code>dataCacheName</code>，以便将应用数据与 App Shell 分离。更新 App Shell 并清除较旧缓存时，我们的数据将保持不变，可随时用于实现超快速加载。注意，如果未来你的数据格式发生变化，你需要相应的处理手段，并且需要确保 App Shell 和内容保持同步。</p><p>在 <code>service-worker.js</code> 文件顶部添加下面一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataCacheName = <span class="string">'weatherData-v1'</span>;</span><br></pre></td></tr></table></figure><p>然后，更新 <code>activate</code> 事件处理程序，使其不会在清除 App Shell 缓存时删除数据缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key !== cacheName &amp;&amp; key !== dataCacheName) &#123;</span><br></pre></td></tr></table></figure><p>最后，更新 <code>fetch</code> 事件处理程序，将发给 data API 的请求与其他请求分开处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Fetch'</span>, e.request.url);</span><br><span class="line">  <span class="keyword">var</span> dataUrl = <span class="string">'https://query.yahooapis.com/v1/public/yql'</span>;</span><br><span class="line">  <span class="keyword">if</span> (e.request.url.indexOf(dataUrl) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the request URL contains dataUrl, the app is asking for fresh</span></span><br><span class="line"><span class="comment">     * weather data. In this case, the service worker always goes to the</span></span><br><span class="line"><span class="comment">     * network and then caches the response. This is called the "Cache then</span></span><br><span class="line"><span class="comment">     * network" strategy:</span></span><br><span class="line"><span class="comment">     * https://jakearchibald.com/2014/offline-cookbook/#cache-then-network</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    e.respondWith(</span><br><span class="line">      caches.open(dataCacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetch(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">          cache.put(e.request.url, response.clone());</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The app is asking for app shell files. In this scenario the app uses the</span></span><br><span class="line"><span class="comment">     * "Cache, falling back to the network" offline strategy:</span></span><br><span class="line"><span class="comment">     * https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    e.respondWith(</span><br><span class="line">      caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码会拦截请求，并检查网址是否以 weather API 的地址开头。如果是，我们将使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">fetch</a> 发出请求。返回请求后，我们的代码会打开缓存，克隆响应，将其存储在缓存内，最后将响应返回给原始请求者。</p><p>我们的应用还不能完全离线工作。我们已经实现了 App Shell 的缓存和检索，但尽管我们缓存了数据，应用也没有查看缓存来看看其中是否有任何天气数据。</p><h3 id="发出请求"><a href="#发出请求" class="headerlink" title="发出请求"></a>发出请求</h3><p>如前面所述，应用需要发起两个异步请求，一个发向缓存，一个发向网络。应用利用 <code>window</code> 中提供的 <code>caches</code> 对象来访问缓存和检索最新数据。这是“渐进式增强”的一个典范，因为可能并非所有浏览器都提供 <code>caches</code> 对象，即使没有该对象，网络请求仍应正常工作。</p><p>为此，我们需要做的是：</p><ol><li>检查全局 <code>window</code> 对象中是否提供了 <code>caches</code> 对象</li><li>从缓存请求数据</li><li>如果服务器请求仍未完成，则用缓存的数据更新应用</li><li>从服务器请求数据</li><li>保存数据以便稍后快速访问</li><li>使用来自服务器的最新数据更新应用</li></ol><h3 id="从缓存获取数据"><a href="#从缓存获取数据" class="headerlink" title="从缓存获取数据"></a>从缓存获取数据</h3><p>接下来，我们需要检查并确保 <code>caches</code> 对象存在，并从该对象请求最新数据。找到 <code>app.getForecast()</code> 中的 <code>TODO add cache logic here</code> 注释，然后在注释下方添加以下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Check if the service worker has already cached this city's weather</span></span><br><span class="line"><span class="comment">      * data. If the service worker has the data, then display the cached</span></span><br><span class="line"><span class="comment">      * data while the app fetches the latest data.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     caches.match(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (response) &#123;</span><br><span class="line">         response.json().then(<span class="function"><span class="keyword">function</span> <span class="title">updateFromCache</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> results = json.query.results;</span><br><span class="line">           results.key = key;</span><br><span class="line">           results.label = label;</span><br><span class="line">           results.created = json.query.created;</span><br><span class="line">           app.updateForecastCard(results);</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们的天气应用现在会发出两个异步数据请求，一个去请求 <code>cache</code> ，一个去请求远程 API 数据，一般情况下缓存请求会先把结果返回，此时我们的页面将以极快的速度（几十微秒）渲染，并更新卡片。随后，远程返回响应后将直接使用 weather API 的最新数据更新卡片。</p><p>请注意缓存请求和 XHR 请求都以更新预报卡片的调用结束。应用如何知道它是否显示了最新数据？<code>app.updateForecastCard</code> 中的以下代码会处理这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cardLastUpdatedElem = card.querySelector(<span class="string">'.card-last-updated'</span>);</span><br><span class="line">    <span class="keyword">var</span> cardLastUpdated = cardLastUpdatedElem.textContent;</span><br><span class="line">    <span class="keyword">if</span> (cardLastUpdated) &#123;</span><br><span class="line">      cardLastUpdated = <span class="keyword">new</span> <span class="built_in">Date</span>(cardLastUpdated);</span><br><span class="line">      <span class="comment">// Bail if the card has more recent data then the data</span></span><br><span class="line">      <span class="keyword">if</span> (dataLastUpdated.getTime() &lt; cardLastUpdated.getTime()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每次更新卡片时，应用都会在卡片上隐藏的属性中存储数据的时间戳。仅当卡片上已经存在的时间戳晚于传递给函数的数据时，应用才会释放。</p><p>现在应用应能完全离线运行了。保存两个城市，按应用上的 refresh 按钮获取最新的天气数据，然后转为离线状态并重新加载页面。</p><p>转至 DevTools 的 <strong>Application</strong> 面板的 <strong>Cache Storage</strong> 窗口。展开这个部分，你可以看到左侧列出的 App Shell 和数据缓存的名称。如果每个城市存储有数据，即可打开数据缓存。</p><p><img src="https://gw.alicdn.com/tfs/TB1mRGRSpXXXXaZXpXXXXXXXXXX-1662-816.png_600x600" alt="image | center"></p><h2 id="添加至主屏幕"><a href="#添加至主屏幕" class="headerlink" title="添加至主屏幕"></a>添加至主屏幕</h2><p>通过 Add To Home Screen 功能，我们可以像从应用商店安装本机应用那样，选择为设备添加一个快捷链接，并且过程要顺畅得多。</p><h3 id="通过-manifest-json-文件声明应用清单"><a href="#通过-manifest-json-文件声明应用清单" class="headerlink" title="通过 manifest.json 文件声明应用清单"></a>通过 manifest.json 文件声明应用清单</h3><p>网络应用清单是一个简单的 JSON 文件，利用网络应用清单，你的网络应用可以：</p><ul><li>在用户的 Android 主屏幕进行丰富的呈现</li><li>在没有网址栏的 Android 设备上以全屏模式启动</li><li>控制屏幕方向以获得最佳查看效果</li><li>定义网站的“启动画面”启动体验和主题颜色</li><li>追踪你是从主屏幕还是从网址栏启动</li></ul><p>在 work 文件夹中创建名称为 manifest.json 的文件，并复制/粘贴以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Weather"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"Weather"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [&#123;</span><br><span class="line">    <span class="attr">"src"</span>: <span class="string">"images/icons/icon-128x128.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"128x128"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-144x144.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-152x152.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"152x152"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-192x192.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"192x192"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-256x256.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"256x256"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;],</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/index.html"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#3E4EB8"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#2F3BA2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此清单支持一组适用于各种屏幕尺寸的图标。</p><p>现在将以下行添加到 <code>index.html</code> 文件中的 <code>&lt;head&gt;</code> 元素底部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最佳做法：</p><ul><li>在你网站的所有网页上放置该清单链接，这样一来，无论用户首次访问时登陆哪个网页，Chrome 都会立即检索到它。</li><li>在 Chrome 上首选使用 <code>short_name</code>，如果存在，则优先于 name 字段使用。</li><li>为不同密度的屏幕定义图标集。Chrome 会尝试使用最接近 48dp 的图标，例如它会在 2 倍像素的设备上使用 96px，在 3 倍像素的设备上使用 144px。</li><li>请记得提供尺寸对启动画面而言合理的图标，并且别忘了设置 <code>background_color</code>。</li></ul><p>在 <code>index.html</code> 中，向 <code>&lt;head&gt;</code> 元素底部添加以下代码，以适配 iOS Safari：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Add to home screen for Safari on iOS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"Weather PWA"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"images/icons/icon-152x152.png"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试验证，打开 DevTool，切换到 <strong>Application </strong>面板上的 <strong>Manifest </strong>窗口，</p><p><img src="https://gw.alicdn.com/tfs/TB1NzqASpXXXXcVXpXXXXXXXXXX-1894-1258.png_600x600" alt="image | center"></p><p>发现浏览器已经将其解析出来了。切换到 Web Server for Chrome，勾上<code>Accessible on local network</code> 选项</p><p><img src="https://gw.alicdn.com/tfs/TB1rPOPSpXXXXXzXpXXXXXXXXXX-700-1212.png_600x600" alt="image | center"></p><p>将网络服务器切换到 <code>STOPPED</code>，然后重新切换到 <code>STARTED</code>。你会看到在 Web Server URL(s) 下面有一个可以远程访问的地址，使用手机访问这个页面，就可以在手机上体验这个 PWA 了。</p><p>如果使用这种测试方式，你会在控制台中看到服务工作线程错误，这是因为未通过 HTTPS 提供服务工作线程。</p><p>在移动 Android 设备上使用 Chrome，尝试将应用添加到主屏幕并验证启动屏幕能否正确显示以及使用的图标是否正确。</p><h2 id="部署到-Firebase"><a href="#部署到-Firebase" class="headerlink" title="部署到 Firebase"></a>部署到 Firebase</h2><p>如果你从未接触过 Firebase，需要先创建你的帐户并安装一些工具。</p><ol><li>在 <a href="https://firebase.google.com/console/?hl=zh-cn" target="_blank" rel="noopener">https://firebase.google.com/console/</a> 上创建一个 Firebase 帐户</li><li>通过 npm 安装 Firebase：<code>npm install -g firebase-tools</code></li></ol><p>创建帐户并登录后，便可随时进行部署！</p><ol><li><p>在 <a href="https://firebase.google.com/console/?hl=zh-cn" target="_blank" rel="noopener">https://firebase.google.com/console/</a> 上创建一个新应用，这里我创建了一个叫 PWA Demo 的应用</p><p><img src="https://gw.alicdn.com/tfs/TB1ly9fSpXXXXcBapXXXXXXXXXX-1970-566.png" alt="image | center"></p></li></ol><ol start="2"><li><p>如果你近期未登录 Firebase 工具，需要重新登录：<code>firebase login</code></p></li><li><p>初始化你的应用，并提供你完成的应用所在的目录（我们的示例 Demo 是 <code>work</code>）： <code>firebase init</code></p><p><img src="https://gw.alicdn.com/tfs/TB1QByCSpXXXXXHXVXXXXXXXXXX-2448-1328.png_600x600" alt="image | center"></p></li></ol><ol start="4"><li><p>最后，将应用部署到 Firebase： <code>firebase deploy</code></p><p><img src="https://gw.alicdn.com/tfs/TB1Ahh6SpXXXXbeaVXXXXXXXXXX-2420-914.png_600x600" alt="image | center"></p></li></ol><ol start="5"><li>大功告成。 操作完成！我们的应用将部署到以下网域：<code>https://YOUR-FIREBASE-APP.firebaseapp.com</code></li></ol><p>测试，尝试将应用添加到主屏幕，然后断开网络并验证应用能够按照预期离线工作。当然，你可以选择部署到集团 CDN 上，这里就不演示了。</p><p>OK，就到这吧，后面再给大家带来详细的《调试服务工作线程》和 《向网络应用添加推送通知》的分享。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 PWA ？ PWA 有哪些特点？PWA 在国内的发展情况怎么样？相对传统的 web 页面，PWA 能够给我们带来更多什么优势？想了解这些问题，可以看看这篇文章&lt;a href=&quot;https://huangxuan.me/2017/02/09/nextgen-web-pwa/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《下一代 Web 应用模型 —— Progressive Web App》&lt;/a&gt;。本文的目的是教你如何搭建一个 PWA 应用，带你从中了解到 PWA 的一些技术实现细节和注意事项。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>weekly-1125 </title>
    <link href="http://G96968586.github.io/2016/11/27/weekly-1125/"/>
    <id>http://G96968586.github.io/2016/11/27/weekly-1125/</id>
    <published>2016-11-27T15:46:11.000Z</published>
    <updated>2018-05-02T09:44:49.288Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Android Logcat的Material颜色主题</li></ul><p>要改变 Android Studio 的 Logcat 你需要这样做：进入 Preferences ( Windows 上是 Settings / Linux machines ) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色(foreground)。</p><p><img src="http://p3.pstatp.com/large/10f3000b2045b867f40e" alt="img"></p><a id="more"></a><p>我使用的material颜色：</p><p>Assert #BA68C8</p><p>Debug #2196F3</p><p>Error #F44336</p><p>Info #4CAF50</p><p>Verbose #BBBBBB</p><p>Warning #FF9800</p><p>注意里面有几个现有的主题，可以直接修改现有主题(不建议)，或者点击save as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。</p><ul><li>防止当前应用崩溃时 Logcat 清除 log</li></ul><p>在 Android Monitor 面板的右上方点击下拉菜单中的 choose Edit filter configuration：</p><p><img src="http://p1.pstatp.com/large/11af000b840a002fe833" alt="img"></p><ul><li>无干扰模式</li></ul><p>你可以到 View → Enter Distraction Free Mode 里启用它</p><p><img src="http://p1.pstatp.com/large/10f3000b2046565442d3" alt="img"></p><p>在无干扰模式下，编辑器占据了整个IntelliJ IDEA窗口，没有任何tab或者工具按钮。代码居中显示。[ IntelliJ Idea Viewing Modes ]</p><p><img src="http://p3.pstatp.com/large/10e6000fb226567e1a0f" alt="img"></p><ul><li>使用 Live Templates</li></ul><p>你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。</p><p><img src="http://p3.pstatp.com/large/11b100005c12e0ddbb70" alt="img"></p><p>可以使用已经定义好了的 Live Templates，比如 Toasts 或者 if 语句。</p><p>可以使用自定义的 templates。这里是 Reto Meier 的一篇不错的参考文章。你也可以参考 IntelliJ IDEA 的文档。</p><ul><li>option + enter</li></ul><p>把一个硬编码的字符串放到资源文件中：option + enter (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图：</p><p><img src="http://p3.pstatp.com/large/10f3000b2047df7703c4" alt="img"></p><ul><li>查看远程分支</li></ul><p>git branch -a</p><ul><li>查看本地分支</li></ul><p>git branch</p><ul><li>CSS实现单行、多行文本溢出显示省略号（…）</li></ul><p>如果实现单行文本的溢出显示省略号同学们应该都知道用 text-overflow:ellipsis 属性来，当然还需要加宽度 width 属来兼容部分浏览。</p><p>实现方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="http://www.daqianduan.com/wp-content/uploads/2015/10/dome1.png" alt=""></p><p>但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。</p><p>接下来重点说一说多行文本溢出显示省略号，如下。</p><p>实现方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="http://www.daqianduan.com/wp-content/uploads/2015/10/dome2.png" alt=""></p><p>适用范围：<br>因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；</p><p>注：</p><p>-webkit-line-clamp;<br>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。</p><p>常见结合属性：</p><p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p><p>-webkit-box-orient; 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p><ul><li>input 输入框点击时去掉外边框方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  outline: white ;<span class="comment">/* 颜色随便设置 */</span></span><br><span class="line">  border: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Android Logcat的Material颜色主题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要改变 Android Studio 的 Logcat 你需要这样做：进入 Preferences ( Windows 上是 Settings / Linux machines ) → Editor → Colors &amp;amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色(foreground)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/10f3000b2045b867f40e&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ADB 常用命令</title>
    <link href="http://G96968586.github.io/2016/10/23/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://G96968586.github.io/2016/10/23/ADB-常用命令/</id>
    <published>2016-10-23T14:30:30.000Z</published>
    <updated>2018-05-02T12:37:06.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ADB-常用命令总结："><a href="#ADB-常用命令总结：" class="headerlink" title="ADB 常用命令总结："></a>ADB 常用命令总结：</h3><ul><li><p>显示系统全部的 Android 平台</p><p><code>android list targets</code></p><p>output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  android list targets</span><br><span class="line">Available Android targets:</span><br><span class="line">----------</span><br><span class="line">id: 1 or "android-21"</span><br><span class="line">     Name: Android 5.0.1</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 21</span><br><span class="line">     Revision: 2</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</span><br><span class="line"> Tag/ABIs : no ABIs.</span><br><span class="line">----------</span><br><span class="line">id: 2 or "android-22"</span><br><span class="line">     Name: Android 5.1.1</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 22</span><br><span class="line">     Revision: 2</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in, AndroidWearRound, AndroidWearRound400x400, AndroidWearRoundChin320x290, AndroidWearRoundChin360x325, AndroidWearRoundChin360x330, AndroidWearSquare, AndroidWearSquare320x320, AndroidWearRound, AndroidWearRound400x400, AndroidWearRoundChin320x290, AndroidWearRoundChin360x325, AndroidWearRoundChin360x330, AndroidWearSquare, AndroidWearSquare320x320</span><br><span class="line"> Tag/ABIs : android-tv/armeabi-v7a, android-tv/x86, android-wear/armeabi-v7a, android-wear/x86, default/armeabi-v7a, default/x86, default/x86_64</span><br><span class="line">----------</span><br><span class="line">id: 3 or "android-23"</span><br><span class="line">     Name: Android 6.0</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 23</span><br><span class="line">     Revision: 3</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</span><br><span class="line"> Tag/ABIs : no ABIs.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>安装应用</p><p><code>adb install xxx.apk</code><br>output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p>如果手机已经存在 newjob 应用，则会报</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure><p>这时候，加一个 -r 参数，代表重新安装，就不会报上面的错误了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install -r newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>Push 将文件写入手机存储系统</p><p><code>adb push &lt;local&gt; &lt;remote&gt;</code></p><p>只要拥有相应的权限，就可以把任何文件写入到手机的任何目录下。比如，前面我们通过 install 将一个 App 安装到手机上，这里，我们也可以把 Apk Push 到 Sdcard 再手动点击安装。</p><p><code>adb push ~/Desktop/newjob.apk /sdcard/</code></p><p>同理，既然可以将文件写入手机，也可以将手机里的文件取出来。</p></li><li><p>Pull 获取手机中的文件</p><p> <code>adb pull &lt;remote&gt; &lt;local&gt;</code>       </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  adb pull /sdcard/ newjob.apk</span><br></pre></td></tr></table></figure></li><li><p>查看 Log 日志</p><p> <code>adb shell</code>  进入 adb 命令行窗口，</p><p> <code>logcat | grep &quot;XX&quot;</code></p><p> eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell</span><br><span class="line"> shell@virgo:/ $ logcat | grep "NJ"</span><br><span class="line"> 10-21 11:18:34.767  2572  4823 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 14:12:03.610  2572  5054 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob/.module.main.NJMainActivity&#125; from uid 10154 on display 0</span><br><span class="line"> 10-21 15:49:33.229  2572  2659 I ActivityManager:   Force finishing activity ActivityRecord&#123;c06ee19 u0 com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity t673&#125;</span><br><span class="line"> 10-21 15:49:38.330  2572  5128 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 15:55:29.015  2572  5054 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 16:25:23.751  2572  4785 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br></pre></td></tr></table></figure></li><li><p>卸载应用</p><p><code>adb uninstall 包名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb uninstall com.taobao.newjob</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>查看系统盘符</p><p><code>adb shell df</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell df</span><br><span class="line">Filesystem               Size     Used     Free   Blksize</span><br><span class="line">/dev                   800.0M   116.0K   799.9M   4096</span><br><span class="line">/var                     1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup           1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup/memory: Permission denied</span><br><span class="line">/mnt                     1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup           1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup/memory: Permission denied</span><br><span class="line">/sys/fs/cgroup/freezer: Permission denied</span><br><span class="line">/system                  1.5G     1.3G   223.6M   4096</span><br><span class="line">/data                   12.2G     4.7G     7.5G   4096</span><br><span class="line">/cache                 377.8M     6.3M   371.5M   4096</span><br><span class="line">/persist                15.7M     4.1M    11.6M   4096</span><br><span class="line">/firmware               64.0M    53.1M    10.9M   16384</span><br><span class="line">/storage                 1.4G     0.0K     1.4G   4096</span><br><span class="line">/mnt/runtime/default/emulated: Permission denied</span><br><span class="line">/storage/emulated       12.2G     4.7G     7.5G   4096</span><br><span class="line">/mnt/runtime/read/emulated: Permission denied</span><br><span class="line">/mnt/runtime/write/emulated: Permission denied</span><br></pre></td></tr></table></figure></li><li><p>查看所有已安装的应用</p><p><code>adb shell pm list packages -f</code>，后面的参数追加 -s 表示列出系统应用，-3 表示列出三方应用，-f 表示列出应用关联的APK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜ adb shell pm list packages -f</span><br><span class="line">package:/data/app/com.homelink.android-1/base.apk=com.homelink.android</span><br><span class="line">package:/system/priv-app/TelephonyProvider/TelephonyProvider.apk=com.android.providers.telephony</span><br><span class="line">package:/system/app/PowerKeeper/PowerKeeper.apk=com.miui.powerkeeper</span><br><span class="line">package:/data/app/io.appium.settings-1/base.apk=io.appium.settings</span><br><span class="line">package:/system/priv-app/CalendarProvider/CalendarProvider.apk=com.android.providers.calendar</span><br><span class="line">package:/system/priv-app/MediaProvider/MediaProvider.apk=com.android.providers.media</span><br><span class="line">package:/system/app/MiLinkService/MiLinkService.apk=com.milink.service</span><br><span class="line">package:/system/priv-app/SpacesTrustAgent/SpacesTrustAgent.apk=com.securespaces.android.trustagent</span><br><span class="line">package:/system/app/XiaomiAccount/XiaomiAccount.apk=com.xiaomi.account</span><br><span class="line">package:/system/app/shutdownlistener/shutdownlistener.apk=com.qualcomm.shutdownlistner</span><br><span class="line">package:/system/priv-app/WallpaperCropper/WallpaperCropper.apk=com.android.wallpapercropper</span><br><span class="line">package:/system/priv-app/CNEService/CNEService.apk=com.quicinc.cne.CNEService</span><br><span class="line">package:/system/app/MiLivetalk/MiLivetalk.apk=com.miui.milivetalk</span><br><span class="line">package:/system/app/Updater/Updater.apk=com.android.updater</span><br><span class="line">package:/system/app/DocumentsUI/DocumentsUI.apk=com.android.documentsui</span><br><span class="line">package:/system/app/Galaxy4/Galaxy4.apk=com.android.galaxy4</span><br><span class="line">package:/system/priv-app/ExternalStorageProvider/ExternalStorageProvider.apk=com.android.externalstorage</span><br><span class="line">package:/system/priv-app/MiGameCenterSDKService/MiGameCenterSDKService.apk=com.xiaomi.gamecenter.sdk.service</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>模拟输入</p><p> <code>adb shell input keyevent code</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell input keyevent 3 (home)</span><br><span class="line">➜  adb shell input keyevent 4 (back)</span><br><span class="line">➜  adb shell input keyevent 19 (up)</span><br><span class="line">➜  adb shell input keyevent 20 (down)</span><br><span class="line">➜  adb shell input keyevent 21 (left)</span><br><span class="line">➜  adb shell input keyevent 22 (right)</span><br><span class="line">➜  adb shell input keyevent 82 (menu)</span><br><span class="line">...</span><br><span class="line">(其他请参考 API 文档)</span><br></pre></td></tr></table></figure></li><li><p>查看 Activity 运行状态</p><p> <code>adb shell dumpsys activity activities</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell dumpsys activity activities | grep "newjob"</span><br><span class="line"> * TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> userId=0 effectiveUid=u0a154 mCallingUid=u0a154 mCallingPackage=com.taobao.newjob</span><br><span class="line"> affinity=com.taobao.newjob</span><br><span class="line"> intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.taobao.newjob/.module.launch.LaunchActivity&#125;</span><br><span class="line"> realActivity=com.taobao.newjob/.module.launch.LaunchActivity</span><br><span class="line"> Activities=[ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;]</span><br><span class="line"> * Hist #0: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> packageName=com.taobao.newjob processName=com.taobao.newjob</span><br><span class="line"> launchedFromUid=10154 launchedFromPackage=com.taobao.newjob userId=0</span><br><span class="line"> app=ProcessRecord&#123;4340cfa 15047:com.taobao.newjob/u0a154&#125;</span><br><span class="line"> Intent &#123; flg=0x10000000 cmp=com.taobao.newjob/.module.main.NJMainActivity &#125;</span><br><span class="line"> frontOfTask=true task=TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> taskAffinity=com.taobao.newjob</span><br><span class="line"> realActivity=com.taobao.newjob/.module.main.NJMainActivity</span><br><span class="line"> baseDir=/data/app/com.taobao.newjob-1/base.apk</span><br><span class="line"> dataDir=/data/user/0/com.taobao.newjob</span><br><span class="line"> TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> Run #2: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> mResumedActivity: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> mLastPausedActivity: ActivityRecord&#123;28c42b5 u0 com.taobao.newjob/.module.launch.LaunchActivity t752 f&#125;</span><br><span class="line"> mFocusedActivity: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br></pre></td></tr></table></figure></li><li><p>列出前台 Activity</p><p><code>adb shell dumpsys activity activities | grep mFocusedActivity</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell dumpsys activity activities | grep mFocusedActivity</span><br><span class="line">   mFocusedActivity: ActivityRecord&#123;a798935 u0 com.taobao.taobao/com.taobao.tao.homepage.MainActivity3 t1023&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动一个 Activity</p><p><code>adb shell am start -n 包名/包名+类名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell am start -n com.taobao.newjob/com.taobao.newjob.module.launch.LaunchActivity</span><br><span class="line">Starting: Intent &#123; cmp=com.taobao.newjob/.module.launch.LaunchActivity &#125;</span><br></pre></td></tr></table></figure></li><li><p>启动一个 Service</p><p><code>adb shell am startservice -n 包名/包名+类名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell am startservice -n com.taobao.newjob.debug/com.taobao.newjob.services.NJRequestImageService</span><br><span class="line">Starting service: Intent &#123; cmp=com.taobao.newjob.debug/com.taobao.newjob.services.NJRequestImageService &#125;</span><br><span class="line">Error: Requires permission not exported from uid 10188</span><br><span class="line">// 这里因为我的 service 设置了 exported = false，所以启动失败</span><br></pre></td></tr></table></figure></li><li><p>发送指定的广播</p><p><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n 包名/包名+类名</code><br>我们可以在调试时，执行这个命令发送指定广播来 debug，特别是一些很难制作的情景的广播。</p></li><li><p>录制屏幕</p><p><code>adb shell screenrecord /路径/xxx/mp4</code></p></li><li><p>手机重新启动</p><p><code>adb reboot</code></p></li><li><p>当电脑上有多个设备 online 时，指定链接到某个设备向其发送命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb devices (先查看有哪些设备)</span><br><span class="line">List of devices attached</span><br><span class="line">192.168.57.101:5555     device</span><br><span class="line">1d760d8a        device</span><br></pre></td></tr></table></figure><p>​现在我们链接下面的那个设备 1d760d8a，通过<code>adb -s &lt;serial number&gt; cmd</code>指定向其发送 shell 命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb -s 1d760d8a shell</span><br><span class="line">shell@virgo:/ $</span><br></pre></td></tr></table></figure><p>导出一个应用的数据库到本地 Desktop 目录下面，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb -s 192.168.57.101:5555 pull /data/data/com.taobao.newjob.debug/databases/logdb.db ~/Desktop</span><br><span class="line"><span class="meta">[100%</span>] /data/data/com.taobao.newjob.debug/databases/logdb.db</span><br></pre></td></tr></table></figure><p>运行其它命令同上面。</p></li><li><p>启动/停止 adb</p><p><code>adb start-server</code> 和 <code>adb kill-server</code></p></li><li><p>清除 apk 数据</p><p><code>adb shell pm clear 包名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell pm clear com.taobao.taobao</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>强行停止应用</p><p><code>adb shell am force-stop 包名</code></p></li><li><p>Android 日志</p><p><code>adb logcat [&lt;option&gt;] [&lt;filter-spec&gt;]</code></p></li><li><p>查看系统属性</p><p><code>adb shell cat /system/build.prop</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell cat /system/build.prop</span><br><span class="line"><span class="meta"> #</span> begin build properties</span><br><span class="line"><span class="meta"> #</span> autogenerated by buildinfo.sh</span><br><span class="line"> ro.build.id=MMB29M</span><br><span class="line"> ro.build.display.id=MMB29M</span><br><span class="line"> ro.build.version.incremental=6.10.13</span><br><span class="line"> ro.build.version.sdk=23</span><br><span class="line"> ro.build.version.preview_sdk=0</span><br><span class="line"> ro.build.version.codename=REL</span><br><span class="line"> ro.build.version.all_codenames=REL</span><br><span class="line"> ro.build.version.release=6.0.1</span><br><span class="line"></span><br><span class="line"> ro.build.version.security_patch=2016-09-01</span><br><span class="line"> ro.build.version.base_os=</span><br><span class="line"> ro.build.date=Thu Oct 13 12:11:20 CST 2016</span><br><span class="line"> ro.build.date.utc=1476331880</span><br><span class="line"> ro.build.type=user</span><br><span class="line"> ro.build.user=builder</span><br><span class="line"> ro.build.host=c3-miui-ota-bd22</span><br><span class="line"> ro.build.tags=release-keys</span><br><span class="line"> ro.build.flavor=virgo-user</span><br><span class="line"> ro.product.model=MI 3W</span><br><span class="line"> ro.product.brand=Xiaomi</span><br><span class="line"> ro.product.name=virgo</span><br><span class="line"> ro.product.device=virgo</span><br><span class="line"> ro.product.board=MSM8974</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li><li><p>屏幕截图</p><p>​<code>adb shell screencap -p /路径/xxx.png</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ADB-常用命令总结：&quot;&gt;&lt;a href=&quot;#ADB-常用命令总结：&quot; class=&quot;headerlink&quot; title=&quot;ADB 常用命令总结：&quot;&gt;&lt;/a&gt;ADB 常用命令总结：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;显示系统全部的 Android 平台&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly 1014</title>
    <link href="http://G96968586.github.io/2016/10/13/weekly-1014/"/>
    <id>http://G96968586.github.io/2016/10/13/weekly-1014/</id>
    <published>2016-10-13T15:34:46.000Z</published>
    <updated>2018-05-02T12:42:07.001Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在 Andorid Studio 中查看 Gradle 添加的依赖时，只有平行的一级，看不出任何从属关系，</li></ul><p><img src="http://alphayang.github.io/img/graldle_flat_dep_tree.png" alt="img"></p><p>特别是出现依赖冲突的时候，在build.gradle 中根据没有添加的包，此时可以在项目根目录下的 build.gradle 中添加如下代码：<br><a id="more"></a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    task allDeps(<span class="string">type:</span> DependencyReportTask) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Terminal 下运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew allDeps</span><br></pre></td></tr></table></figure><p>就可以看到依赖树啦!</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">compile - Classpath <span class="keyword">for</span> compiling the main sources.</span><br><span class="line">...</span><br><span class="line">+--- com.android.<span class="string">support:</span><span class="string">design:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    \--- com.android.<span class="string">support:</span>support-<span class="string">annotations:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>recyclerview-<span class="string">v7:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    +--- com.android.<span class="string">support:</span>support-<span class="string">annotations:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|    \--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|         +--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|         +--- com.android.<span class="string">support:</span>support-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|         |    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|         \--- com.android.<span class="string">support:</span>animated-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|              \--- com.android.<span class="string">support:</span>support-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>recyclerview-<span class="string">v7:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.<span class="string">alibaba:</span><span class="string">fastjson:</span><span class="number">1.2</span><span class="number">.7</span></span><br><span class="line">+--- com.android.<span class="string">support:</span><span class="string">multidex:</span><span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">+--- com.<span class="string">nineoldandroids:</span><span class="string">library:</span><span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">+--- com.wang.<span class="string">avi:</span><span class="string">library:</span><span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">22.2</span><span class="number">.0</span> -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|    \--- com.<span class="string">nineoldandroids:</span><span class="string">library:</span><span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">+--- me.drakeet.<span class="string">materialdialog:</span><span class="string">library:</span><span class="number">1.2</span><span class="number">.8</span></span><br><span class="line">+--- com.<span class="string">balysv:</span>material-<span class="string">ripple:</span><span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">+--- com.<span class="string">zhy:</span><span class="string">okhttputils:</span><span class="number">2.2</span><span class="number">.0</span></span><br><span class="line">|    \--- com.squareup.<span class="string">okhttp3:</span><span class="string">okhttp:</span><span class="number">3.0</span><span class="number">.1</span></span><br><span class="line">|         \--- com.squareup.<span class="string">okio:</span><span class="string">okio:</span><span class="number">1.6</span><span class="number">.0</span></span><br><span class="line">+--- com.czt.<span class="string">mp3recorder:</span><span class="string">library:</span><span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">|    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">23.1</span><span class="number">.1</span> -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>客户端本地使用 Android Studio 调试时出现 <strong>Failure [INSTALL_CANCELED_BY_USER]</strong> 的问题</li></ul><p>今天在我使用小米 Note 本地调试 app 时，每次在 Install app 环节就出现了 <strong>Failure [INSTALL_CANCELED_BY_USER]</strong> 的错误，字面意义很容易理解，被用户手动取消安装了，呵，说着倒是挺轻松的，可我压根就没有取消，查看手机开发者调试开关和 USB 开关都打开了，网上查了一下，大概有下面几种解决方法：</p><p>1.确保手机处于开发者模式</p><p>2.在手机上，勾选 系统设置 -&gt; 安全 -&gt; 未知来源</p><p>3.安装的时候手机是否处于锁屏状态，若是，取消锁屏</p><p>4.有的手机需要手动安装，比如小米3</p><p>5.手机内存空间可能不足</p><p>上面五种方法对我来说都没有用，正当我在烦恼的时候，我突然想起是不是我更新了 MIUI 系统的原因造成的，因为之前我是可以调试的。打开手机开发者选项，看到多出了很多的开关选项，其中有一个“允许通过USB安装应用”的开关，打开它，发现还需要小米账号登录，真烦，无奈，我还是登录了，然后把这个开关打开，重新通过 Android Studio 把 app 跑起来，结果可以了！</p><p>如果你在小米的手机上也遇到这个问题，不妨试试我的方法。</p><p><strong>注：更新后的小米系统版本如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Android 版本: 6.0.1 MMB29M</span><br><span class="line"></span><br><span class="line">MIUI 版本: MIUI 8.6.9.29|开发版 (靠，还是开发版)</span><br></pre></td></tr></table></figure><ul><li>Chrome 上模拟 UA</li></ul><p>打开开发者模式，More tools -&gt; Network conditions</p><p><img src="https://gw.alicdn.com/tps/TB1rfAfNFXXXXXrapXXXXXXXXXX-782-580.png" alt=""></p><p>进入下面的页面，</p><p><img src="https://gw.alicdn.com/tps/TB1PQ.qNFXXXXbJXVXXXXXXXXXX-1156-618.png" alt=""></p><p>去掉 Select automatically 选项，然后选择平台，下面的 UA 就可以根据你的需求更改了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在 Andorid Studio 中查看 Gradle 添加的依赖时，只有平行的一级，看不出任何从属关系，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://alphayang.github.io/img/graldle_flat_dep_tree.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;特别是出现依赖冲突的时候，在build.gradle 中根据没有添加的包，此时可以在项目根目录下的 build.gradle 中添加如下代码：&lt;br&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0708</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0708/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0708/</id>
    <published>2016-10-09T15:06:29.000Z</published>
    <updated>2018-05-02T09:57:59.107Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://www.codes51.com/article/detail_101733.html" target="_blank" rel="noopener">在WebView自身打开链接 – 关于 WebViewClient 类 shouldOverrideUrlLoading 的错误用法</a></p></li><li><p>Android 24之后(即 Android N)，可以很方便的查看自己 app 是否打开了消息通知开关</p><a id="more"></a><p>详情：<br>Now you can check it, as said in <a href="https://www.youtube.com/watch?v=w45y_w4skKs&amp;feature=youtu.be&amp;list=PLOU2XLYxmsILe6_eGvDN3GyiodoV3qNSC&amp;t=192" target="_blank" rel="noopener">this Google I/O 2016 video</a></p></li></ul><p>怎么使用呢？看下我的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isOpen = NotificationManagerCompat.from(<span class="keyword">this</span>).areNotificationsEnabled();</span><br></pre></td></tr></table></figure><p>这里需要注意的是，在 API 19 以下方法 areNotificationsEnabled 默认都返回 true，在 API 19+ (包括19)是有效果的。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.codes51.com/article/detail_101733.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在WebView自身打开链接 – 关于 WebViewClient 类 shouldOverrideUrlLoading 的错误用法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 24之后(即 Android N)，可以很方便的查看自己 app 是否打开了消息通知开关&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0715</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0715/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0715/</id>
    <published>2016-10-09T15:05:23.000Z</published>
    <updated>2018-05-02T09:58:35.921Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://www.jianshu.com/p/ea48332c82af" target="_blank" rel="noopener">落地——读《App研发录》</a></p></li><li><p><a href="https://segmentfault.com/a/1190000005864691" target="_blank" rel="noopener">Web App防坑手册</a></p></li><li><p>Android 从代码源头上 findbugs <a href="https://github.com/MasonLiuChn/AndroidCodeQuality" target="_blank" rel="noopener">《AndroidCodeQuality》库</a>，尝试了一下，会导致编译变慢好多，所以还是不引入众包项目了。</p><a id="more"></a></li><li><p><a href="https://github.com/mihaip/dex-method-counts" target="_blank" rel="noopener">dex-method-counts</a>,统计一个 apk 使用的方法数，它可以很详细的列出哪些包使用了多少方法，这个工具可以用来决定哪些类库可以在 65k 限制之下使用。</p></li><li><p>强烈推荐的一篇文章 <a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="noopener">《Android 开发最佳实践》</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/ea48332c82af&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;落地——读《App研发录》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005864691&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web App防坑手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 从代码源头上 findbugs &lt;a href=&quot;https://github.com/MasonLiuChn/AndroidCodeQuality&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AndroidCodeQuality》库&lt;/a&gt;，尝试了一下，会导致编译变慢好多，所以还是不引入众包项目了。&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0722</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0722/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0722/</id>
    <published>2016-10-09T15:02:38.000Z</published>
    <updated>2018-05-02T09:58:44.593Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>了解下 box-sizing <a href="http://www.jiangweishan.com/article/boxSizing.html" target="_blank" rel="noopener">关于移动端Box-sizing的基本知识和应用</a></p></li><li><p><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">Android性能优化典范 - 第1季</a></p></li><li><p><a href="http://hukai.me/android-tips-for-reduce-apk-size/" target="_blank" rel="noopener">Android APK安装包瘦身</a></p><a id="more"></a></li><li><p><a href="http://www.html-js.com/article/Mobile-terminal-H5-mobile-terminal-HD-multi-screen-adaptation-scheme%203041" target="_blank" rel="noopener">移动端高清、多屏适配方案</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=2652261744&amp;idx=1&amp;sn=01fc945337c048735c8375d5a94fc4c8&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">Android :“万能” Activity 重构篇（上）</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=2652261744&amp;idx=2&amp;sn=caa8bd3502624385c789bc99bb605581&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">Android :“万能” Activity 重构篇（下）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解下 box-sizing &lt;a href=&quot;http://www.jiangweishan.com/article/boxSizing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于移动端Box-sizing的基本知识和应用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-performance-patterns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android性能优化典范 - 第1季&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-tips-for-reduce-apk-size/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android APK安装包瘦身&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0729</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0729/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0729/</id>
    <published>2016-10-09T15:00:44.000Z</published>
    <updated>2018-05-02T09:58:56.535Z</updated>
    
    <content type="html"><![CDATA[<p>1、本地 git 切换到远程分支</p><p>首先，通过 git branch -va 查看本地 ＋ 远程的分支列表,比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master              0840594 merge master and 1.0.0</span><br><span class="line">remotes/origin/1.0.0  743012a 'update'</span><br><span class="line">remotes/origin/2.0.0  2787838 udpate</span><br><span class="line">remotes/origin/HEAD   -&gt; origin/master</span><br><span class="line">remotes/origin/master 0840594 merge master and 1.0.0</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果想切换到 origin/2.0.0 的分支，我们可以<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch remotes/origin/2.0.0</span><br></pre></td></tr></table></figure></p><p>不过结果并不如意：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* (detached from origin/2.0.0)</span><br><span class="line">master</span><br></pre></td></tr></table></figure></p><p>git branch 会看到上面的信息，这里还需要一步操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 2.0.0</span><br></pre></td></tr></table></figure><p>-b 的意思是 base，以当前分支为 base，新建一个名叫 2.0.0 的分支，这里当然也可以使用其他的命名。此时再执行 git branch 就能看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git br</span><br><span class="line">  master</span><br><span class="line">* 2.0.0</span><br></pre></td></tr></table></figure><p>最直接的方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t origin/2.0.0</span><br></pre></td></tr></table></figure><p>能够直接新建本地分支，将远程分支提取出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、本地 git 切换到远程分支&lt;/p&gt;
&lt;p&gt;首先，通过 git branch -va 查看本地 ＋ 远程的分支列表,比如：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* master              0840594 merge master and 1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/1.0.0  743012a &#39;update&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/2.0.0  2787838 udpate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/HEAD   -&amp;gt; origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/master 0840594 merge master and 1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 1008</title>
    <link href="http://G96968586.github.io/2016/10/08/weekly-1008/"/>
    <id>http://G96968586.github.io/2016/10/08/weekly-1008/</id>
    <published>2016-10-08T15:20:16.000Z</published>
    <updated>2018-05-02T09:59:54.535Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近在做 React 开发时，遇到了这样一个问题，<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    getInitialState()&#123;</span><br><span class="line">         <span class="comment">// some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>getInitialState 不会调用，浏览器输出了下面的信息，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: getInitialState was defined on TodoApp, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?</span><br></pre></td></tr></table></figure></p><p>上网查了一下，原来 React 在 ES6 的实现中去掉了 getInitialState 这个 hook 函数，规定 state 在 constructor 中实现，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class App extends Component &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">&#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Babel的Blog上还有一种实现方法，即直接使用赋值语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">state = &#123;&#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最近在做 React 开发时，遇到了这样一个问题，&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TodoApp&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getInitialState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// some thing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>样式辅助文件 flexbox.scss</title>
    <link href="http://G96968586.github.io/2016/09/25/%E6%A0%B7%E5%BC%8F%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6flexbox-scss/"/>
    <id>http://G96968586.github.io/2016/09/25/样式辅助文件flexbox-scss/</id>
    <published>2016-09-25T15:50:21.000Z</published>
    <updated>2016-09-25T15:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.FBH</span>,</span><br><span class="line"><span class="selector-class">.FBV</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBV</span> &#123;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-box-<span class="attribute">direction</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAS</span> &#123;</span><br><span class="line">  -webkit-box-align: start;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: flex-start;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAC</span> &#123;</span><br><span class="line">  -webkit-box-align: center;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAE</span> &#123;</span><br><span class="line">  -webkit-box-align: end;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: flex-end;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJS</span> &#123;</span><br><span class="line">  -webkit-box-pack: start;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJC</span> &#123;</span><br><span class="line">  -webkit-box-pack: center;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJE</span> &#123;</span><br><span class="line">  -webkit-box-pack: end;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJ</span> &#123;</span><br><span class="line">  -webkit-box-pack: justify;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB1</span>, <span class="selector-class">.FB2</span>, <span class="selector-class">.FB3</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB1</span>,</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB2</span>,</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB1</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB2</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB3</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="CSS" scheme="http://G96968586.github.io/categories/CSS/"/>
    
    
      <category term="样式" scheme="http://G96968586.github.io/tags/%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="代码" scheme="http://G96968586.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>微信 Tinker 的一切都在这里，包括源码(一)</title>
    <link href="http://G96968586.github.io/2016/09/24/%E5%BE%AE%E4%BF%A1Tinker%E7%9A%84%E4%B8%80%E5%88%87%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%BA%90%E7%A0%81-%E4%B8%80/"/>
    <id>http://G96968586.github.io/2016/09/24/微信Tinker的一切都在这里，包括源码-一/</id>
    <published>2016-09-24T06:24:30.000Z</published>
    <updated>2018-05-02T12:38:05.088Z</updated>
    
    <content type="html"><![CDATA[<p>最近半年以来，Android热补丁技术热潮继续爆发，各大公司相继推出自己的开源框架。Tinker在最近也顺利完成了公司的审核，并非常荣幸的成为github.com/Tencent上第一个正式公开的项目。</p><p>回顾这半年多的历程，这是一条跪着走完，坑坑不息之路。或许只有自己真正经历过，深入研究过, 才会真正的明白。<br><a id="more"></a></p><blockquote><p>热补丁不是请客吃饭</p></blockquote><p>对热补丁技术本身，还是对使用者来说都是如此。我希望通过分享微信在这历程中的思考与经验，能帮助大家更容易的决定是否在自己的项目中使用热补丁技术，以及选择什么样方案。</p><h2 id="热补丁技术背景"><a href="#热补丁技术背景" class="headerlink" title="热补丁技术背景"></a>热补丁技术背景</h2><p>热补丁是什么以及它的应用场景介绍，大家可以参考文章<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286306&amp;idx=1&amp;sn=d6b2865e033a99de60b2d4314c6e0a25&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">微信Android热补丁实践演进之路</a>。</p><p>在笔者看来Android热补丁技术应该分为以下两个流派：</p><ul><li>Native，代表有阿里的Dexposed、AndFix与腾讯的内部方案KKFix；</li><li>Java，代表有Qzone的超级补丁、大众点评的nuwa、百度金融的rocooFix, 饿了么的amigo以及美团的robust。</li></ul><p>Native流派与Java流派都有着自己的优缺点，它们具体差异大家可参考上文。事实上从来都没有最好的方案，只有最适合自己的。</p><p>对于微信来说，我们希望得到一个“高可用”的补丁框架，它应该满足以下几个条件：</p><ol><li><strong>稳定性与兼容性</strong>；微信需要在数亿台设备上运行，即使补丁框架带来1%的异常，也将影响到数万用户。</li><li><strong>性能</strong>；补丁框架不能影响应用的性能，这里基于大部分情况下用户不会使用到补丁。其次补丁包应该尽量少，这关系到用户流量与补丁的成功率问题；</li><li><strong>易用性</strong>；我们同时希望补丁框架简单易用，并且可以全面支持，甚至可以做到功能发布级别。</li></ol><p>在“高可用”这个大前提下，微信对当时存在的两个方案做了大量的研究：</p><ol><li>Dexposed/AndFix；最大挑战在于稳定性与兼容性，而且native异常排查难度更高。另一方面，由于无法增加变量与类等限制，无法做到功能发布级别；</li><li>Qzone；最大挑战在于性能，即Dalvik平台存在插桩导致的性能损耗，Art平台由于地址偏移问题导致补丁包可能过大的问题；</li></ol><p>在2016年3月，微信为了追寻“高可用”这个目标，决定尝试搭建自己的补丁框架—Tinker。</p><p>Tinker框架的演绎并不是一蹴而就，它大致分为三个阶段，每一阶段需要解决的核心问题并不相同。而Tinker v1.0的核心问题是实现符合性能要求的Dex补丁框架。</p><h2 id="Tinker-v1-0—性能极致追求之路"><a href="#Tinker-v1-0—性能极致追求之路" class="headerlink" title="Tinker v1.0—性能极致追求之路"></a>Tinker v1.0—性能极致追求之路</h2><p>为了稳定性与兼容性，微信选择了 Java 流派。当前最大难点在于如何突破 Qzone 方案的性能问题，通过研究Instant Run 的冷插拔与 buck 的 exopackage 给了我们灵感。它们的思想都是全量替换新的Dex。</p><p><img src="https://gw.alicdn.com/tps/TB1nWi9NpXXXXcrXVXXXXXXXXXX-1166-919.jpg" alt="img"></p><p>简单来说，我们通过完全使用了新的Dex，那样既不出现Art地址错乱的问题，在Dalvik也无须插桩。当然考虑到补丁包的体积，我们不能直接将新的Dex放在里面。但我们可以将新旧两个Dex的差异放到补丁包中，这里我们可以调研的方法有以下几个：</p><p><img src="https://gw.alicdn.com/tps/TB1UGjaNpXXXXb5XVXXXXXXXXXX-1193-736.jpg" alt="img"></p><ol><li><strong>BsDiff</strong>；它格式无关，但对Dex效果不是特别好，而且生成产物大小非常不稳定。当前微信对于so与部分资源，依然使用bsdiff算法；</li><li><strong>DexMerge</strong>；它主要问题在于合成时内存占用过大，一个12M的dex，峰值内存可能达到70多M；</li><li><strong>DexDiff</strong>；通过深入Dex格式，实现一套生成产物小，内存占用少以及支持增删改的算法。</li></ol><p>如何选择？在“高可用”的核心诉求下，性能问题也尤为重要。非常庆幸微信在当时那个节点坚决的选择了自研DexDiff 算法，这过程虽然有苦有泪，但也正是有它，才有现在的 Tinker。</p><h3 id="一-DexDiff技术实践"><a href="#一-DexDiff技术实践" class="headerlink" title="一. DexDiff技术实践"></a><strong>一. DexDiff技术实践</strong></h3><p>在不断的深入研究究<a href="undefined">Dex格式</a>后，我们发现自己跳进了一个深坑，主要难点有以下三个：</p><ol><li><strong>Dex格式复杂</strong>；Dex大致分为像StringID，TypeID这些Index区域以及使用Offset的Data区域。它们有大量的互相引用，一个小小的改变可能导致大量的Index与Offset变化；</li><li><strong>dex2opt与dex2oat校验</strong>；在这两个过程系统会做例如四字节对齐，部分元素排序等校验，例如StringID按照内容的Unicode排序，TypeID按照StringID排序…</li><li><strong>低内存，快速</strong>；这要求我们对Dex每一块做到一次读写，无法像baksmali与dexmerge那样完全结构化。</li></ol><p><img src="https://gw.alicdn.com/tps/TB1ZeYoNpXXXXXbXFXXXXXXXXXX-594-388.jpg" alt="img"></p><p>现在回想起来，这的确是一条跪着走完的路。与研究Dalvik与Art执行一致，这是经历一次次翻看源码，一次次编Rom查看日志，一次次dump内存结构换来的结果。</p><p>下面以最简单的Index区域举例：</p><p><img src="https://gw.alicdn.com/tps/TB1REW5NpXXXXa.aXXXXXXXXXXX-618-161.jpg" alt="img"></p><p>要想将从左边序列更改成右边序列，Diff算法的核心在于如何生成最小操作序列，同时修正Index与Offset，实现增删改的功能。</p><ol><li><strong>Del 2</strong>；”b”元素被删除，它对应的Index是2，为了减少补丁包体积，除了新增的元素其他一律只存Index;</li><li>“c”, “d”, “e”元素自动前移，无须操作；</li><li><strong>Addf(5)</strong>; 在第五个位置增加”f”这个元素。</li></ol><p>对于Offset区，由于每个Section可能有非常多的元素，这里会更加复杂。最后我们得到最终的操作队列，为什么DexDiff可以做到内存非常少？这是因为DexDiff算法是每一个操作的处理，它无需一次性读入所有的数据。DexDiff的各项数据如下：</p><p><img src="https://gw.alicdn.com/tps/TB1.izzNpXXXXbiXXXXXXXXXXXX-828-147.jpg" alt="img"></p><p>通过DexDiff算法的实现，我们既解决了Dalvik平台的性能损耗问题，又解决了Art平台补丁包过大的问题。但这套方案的缺点在于占Rom体积比较大，微信考虑到移动设备的存储空间提升比较快，增加几十M的Rom空间这个代价可以接受。</p><h3 id="二-Android-N的挑战"><a href="#二-Android-N的挑战" class="headerlink" title="二. Android N的挑战"></a><strong>二. Android N的挑战</strong></h3><p>信心满满上线后，却很快收到华为反馈的一个Crash：</p><p><img src="https://gw.alicdn.com/tps/TB1YWTiNpXXXXaQXFXXXXXXXXXX-688-107.jpg" alt="img"></p><p>而且这个Crash只在Android N上出现，在当时对我们震动非常大，难道Android N不支持Java方式热补丁了？难道这两个月的辛苦都白费了吗？一切想象都苍白无力，只有继续去源码里面找原因。</p><p>在之前的基础上，这一块的研究并没有花太多的时间，主要是Android N的混合编译模式导致。更多的详细分析可参考文章<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android N混合编译与对热补丁影响解析</a>。</p><h3 id="三-厂商OTA的挑战"><a href="#三-厂商OTA的挑战" class="headerlink" title="三. 厂商OTA的挑战"></a><strong>三. 厂商OTA的挑战</strong></h3><p>刚刚解决完Android N的问题，还在沉醉在自己的胜利的愉悦中。前线很快又传来噩耗，小米反馈开发版的一些用户在微信启动时黑屏，甚至ANR。</p><p><img src="https://gw.alicdn.com/tps/TB12ZjXNpXXXXXaaXXXXXXXXXXX-612-257.png" alt="img"></p><p>当时第一反应是不可能，所有的DexOpt操作都是放到单独的进程，为什么只在Art平台出现？为什么小米开发版用户反馈比较多？经过分析，我们发现优化后odex文件存在有效性的检查：</p><ul><li>Dalvik平台：modtime/crc…</li><li>Art平台： checksum/image_checksum/image_offset…</li></ul><p>这就非常好理解了，因为OTA之后系统image改变了，odex文件用到image的偏移地址很可能已经错误。对于ClassN.dex文件，在OTA升级系统已完成重新dex2oat，而补丁是动态加载的，只能在第一次执行时同步执行。</p><p>这个耗时可能高达十几秒，黑屏甚至ANR也是非常好理解。那为什么只有小米用户反馈比较多呢？这也是因为小米开发版每周都会推送系统升级的原因。</p><p>在当时那个节点上，我们重新的审视了全量合成这一思路，再次对方案原理本身产生怀疑，它在Art平台上面带来了以下几个代价：</p><ol><li><strong>OTA后黑屏问题</strong>；这里或许可以通过loading界面实现，但并不是很好的方案；</li><li><strong>Rom体积问题</strong>；一个10M的Dex，在Dalvik下odex产物只有11M左右，但在Art平台，可以达到30多M；</li><li><strong>Android N的问题</strong>；Android N在混合编译上努力，被补丁全量合成机制所废弃了。这是因为动态加载的Dex，依然是全量编译。</li></ol><p>回想起来，Qzone方案它只把需要的类打包成补丁推送，在Art平台上可能导致补丁很大，但它肯定比全量合成的Dex少很多很多。在此我们提出分平台合成的想法，即在Dalvik平台合成全量Dex，在Art平台合成需要的小Dex。</p><p><img src="https://gw.alicdn.com/tps/TB1aem.NpXXXXXsaXXXXXXXXXXX-594-409.jpg" alt="img"></p><p>DexDiff算法已经非常复杂，事实上要实现分平台合成更加不容易。</p><p><img src="https://gw.alicdn.com/tps/TB1Q5vkNpXXXXXyXFXXXXXXXXXX-486-193.jpg" alt="img"></p><p>主要难点有以下几个方面：</p><ul><li><strong>small dex的类收集</strong>；什么类应该放在这个小的Dex中呢？</li><li><strong>ClassN处理</strong>；对于ClassN怎么样处理，可能出现类从一个Dex移动到另外一个Dex?</li><li><strong>偏移二次修正</strong>; 补丁包中的操作序列如何二次修正？</li><li><strong>Art.info的大小</strong>； 为了修正偏移所引入的info文件的大小？</li></ul><p>庆幸的是，面对困难我们并没有畏惧，最后实现了这一套方案，这也是其他全量合成方案所不能做到的：</p><ol><li>Dalvik全量合成，解决了插桩带来的性能损耗；</li><li>Art平台合成small dex，解决了全量合成方案占用Rom体积大, OTA升级以及Android N的问题；</li><li>大部分情况下Art.info仅仅1-20K, 解决由于补丁包可能过大的问题；</li></ol><p>事实上，DexDiff算法变的如此复杂，怎么样保证它的正确性呢？微信为此做了以下三件事情：</p><ol><li>随机组成Dex校验，覆盖大部分case；</li><li>微信200个版本的随机Diff校验, 覆盖日常使用情况；</li><li>Dex文件合成产物有效性校验，即使算法出现问题，也只是编译不出补丁包。</li></ol><p>每一次DexDiff算法的更新，都需要经过以上三个Test才可以提交，这样DexDiff的这套算法已完成了整个闭环。</p><h3 id="四-其他技术挑战"><a href="#四-其他技术挑战" class="headerlink" title="四. 其他技术挑战"></a><strong>四. 其他技术挑战</strong></h3><p>在实现过程，我们还发现其他的一些问题：</p><ol><li><p>Xposed 等微信插件; 市面上有各种各样的微信插件，它们在微信启动前会提前加载微信中的类，这会导致两个问题：</p><p>a.Dalvik 平台：出现Class ref in pre-verified class resolved to unexpected  implementation的 crash；</p><p>b.Art 平台:出现部分类使用了旧的代码，这可能导致补丁无效，或者地址错乱的问题。</p></li></ol><p><strong>微信在这里的处理方式是若 crash 时发现安装了 Xposed，即清除并不再应用补丁</strong>。</p><ol start="2"><li>Dex反射成功但是不生效；部分三星android-19版本存在Dex反射成功，但      出现类重复时，查找顺序始终从base.apk开始。 </li></ol><p><strong>微信在这里的处理方式是增加 Dex 反射成功校验，具体通过在框架中埋入某个类的 isPatch 变量为 false。在补丁时，我们自动将这个变量改为 true。通过这个变量最终的数值，我们可以知道反射成功与否。</strong></p><h2 id="Tinker-v1-0总结"><a href="#Tinker-v1-0总结" class="headerlink" title="Tinker v1.0总结"></a>Tinker v1.0总结</h2><h3 id="一-关于性能"><a href="#一-关于性能" class="headerlink" title="一. 关于性能"></a><strong>一. 关于性能</strong></h3><p>通过Tinker v1，0的努力，我们解决了Qzone方案的性能问题，得到一个符合“高可用”性能要求的补丁框架。</p><ul><li><strong>它补丁包大小非常少</strong>，通常都是10k以内；</li><li><strong>对性能几乎没有影响，</strong>2%的性能影响主要原因是微信运行时校验补丁Dex文件的md5导致(虽然文件在/data/data/目录，微信为了更高级别的安全)；</li><li><strong>Art平台通过革命性的分平台合成</strong>，既解决了地址偏移的问题，占Rom体积与Qzone方案一致。</li></ul><p><img src="https://gw.alicdn.com/tps/TB1J4TsNpXXXXbaXpXXXXXXXXXX-514-306.jpg" alt="img"></p><p><strong>二. 关于成功率</strong></p><p>也许有人会质疑微信成功率为什么这么低，其他方案都是99%以上。事实上，我们的成功率计算方式是：</p><blockquote><p>应用成功率= 补丁版本转化人数/基准版本安装人数</p></blockquote><p>即三天后，94.1%的基础版本都成功升级到补丁版本，由于基础版本人数也是持续增长，同时可能存在基准或补丁版本用户安装了其他版本，所以本统计结果应略为偏低，但它能现实的反应补丁的线上总体覆盖情况。</p><p>事实上，采用 Qzone 方案，3天的成功率大约为96.3%，这里还是有很多的优化空间。</p><h3 id="三-Tinker-v2-0－稳定性的探寻之路"><a href="#三-Tinker-v2-0－稳定性的探寻之路" class="headerlink" title="三. Tinker v2.0－稳定性的探寻之路"></a><strong>三. Tinker v2.0－稳定性的探寻之路</strong></h3><p>在v1.0阶段，大部分的异常都是通过厂商反馈而来，Tinker并没有解决“高可用”下最核心的稳定性与兼容性问题。</p><p>我们需要建立完整的监控与补丁回退机制，监控每一个阶段的异常情况。这也是Tinker v2.0的核心任务，由于边幅问题这部分内容将放在下一篇文章。</p><p>注：Tinker Github 源码地址：<a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener">https://github.com/Tencent/tinker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近半年以来，Android热补丁技术热潮继续爆发，各大公司相继推出自己的开源框架。Tinker在最近也顺利完成了公司的审核，并非常荣幸的成为github.com/Tencent上第一个正式公开的项目。&lt;/p&gt;
&lt;p&gt;回顾这半年多的历程，这是一条跪着走完，坑坑不息之路。或许只有自己真正经历过，深入研究过, 才会真正的明白。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
      <category term="转载" scheme="http://G96968586.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="热修复" scheme="http://G96968586.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>快速排序优化分析</title>
    <link href="http://G96968586.github.io/2016/09/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://G96968586.github.io/2016/09/23/快速排序优化分析/</id>
    <published>2016-09-23T12:19:32.000Z</published>
    <updated>2018-05-02T12:38:09.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自我在 CSDN 的一篇博文，<a href="http://blog.csdn.net/g96968586/article/details/24271639" target="_blank" rel="noopener">原文链接</a>在这里，谢谢大家支持！</p></blockquote><p>上一篇的《浅谈快速排序》 <a href="http://blog.csdn.net/g96968586/article/details/24185967" target="_blank" rel="noopener">http://blog.csdn.net/g96968586/article/details/24185967</a>  </p><p>中我们分析了快速排序的算法，我们也举了一个例子来模拟快速排序，然而大家发现了没有，上次是对数组{50，10，90，30，70，40，80，60，20}进行排序，如果这一次我换成下面这个例子会发生什么情况呢？<br><a id="more"></a></p><p>前一篇的Partition函数代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">( SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> pivotkey;  </span><br><span class="line">       pivotkey = L-&gt;r[low];   <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span>  </span><br><span class="line">       <span class="keyword">while</span>(low &lt; high)   <span class="comment">/* 从表的两端交替向中间扫描 */</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)    high - - ;  </span><br><span class="line">            swap(L,low,high);    <span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span>  </span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey )   low ++;  </span><br><span class="line">            swap(L,low,high);  <span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">          <span class="keyword">return</span> low;   <span class="comment">/*  返回枢轴所在位置 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们对数组{9,1,5,8,3,7,4,6,2}进行排序，由代码第四行“pivotkey = L-&gt;r[low]; ”知道，我们应该选取9作为第一个枢轴pivotkey，此时经过一轮“pivot=Partition(L,1,9)”，它只是更换了9和2的位置，并把9返回给pivot。整个数组并没有实质性的变化。如图示，</p><p><img src="http://img.blog.csdn.net/20140421211948156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZzk2OTY4NTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>换句话说，第四行代码“pivotkey = L-&gt;r[low]; ”变成了一个潜在的瓶颈。排序速度的快慢取决于L-&gt;r[l1]的关键字处在整个序列的位置，L-&gt;r[1]太大或太小都回影响性能。在我们现实中，带排序的序列极有可能是基本有序的，如果我们总是固定地选择第一个关键字作为首个枢轴，就变成了极为不合理的做法。<br>这里的改进方法我们采用三数取中法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取整个待排序的左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者是最大的数，从概率来说，取三个数均为最小或最大的可能性微乎其微，因此中间数位于较为中间的值的可能性就大大提高了。<br>我们现在在Partition函数的第三行和第四行中间加入这么一段代码，</p><p><img src="http://img.blog.csdn.net/20140421211805765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZzk2OTY4NTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>这样子，如果我们对数组{9,1,5,8,3,7,4,6,2}，取左9、中间3、右2来比较，最终使得L-&gt;r[low] = 3,一定要比9和2来的更合理。</p><p>下面来优化一些不必要的交换。<br>大家发现了没，上一篇中，对于50这个关键字，其位置变化是1-&gt;9-&gt;3-&gt;6-&gt;5，可其实它的最终目标就是5，当中的一些交换是不需要的。因此，我们再次对Partition函数进行优化。</p><p><img src="http://img.blog.csdn.net/20140421212022000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZzk2OTY4NTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>优化之后少了多次交换数据的操作，在性能上又得到了部分的提高。</p><p>看程序分析，</p><p><img src="http://img.blog.csdn.net/20140421212232265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZzk2OTY4NTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p><img src="http://img.blog.csdn.net/20140421212330640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZzk2OTY4NTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自我在 CSDN 的一篇博文，&lt;a href=&quot;http://blog.csdn.net/g96968586/article/details/24271639&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;在这里，谢谢大家支持！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇的《浅谈快速排序》 &lt;a href=&quot;http://blog.csdn.net/g96968586/article/details/24185967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/g96968586/article/details/24185967&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;中我们分析了快速排序的算法，我们也举了一个例子来模拟快速排序，然而大家发现了没有，上次是对数组{50，10，90，30，70，40，80，60，20}进行排序，如果这一次我换成下面这个例子会发生什么情况呢？&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://G96968586.github.io/categories/DataStructure/"/>
    
    
      <category term="转载" scheme="http://G96968586.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>浅谈快速排序</title>
    <link href="http://G96968586.github.io/2016/09/23/%E6%B5%85%E8%B0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://G96968586.github.io/2016/09/23/浅谈快速排序/</id>
    <published>2016-09-23T12:08:45.000Z</published>
    <updated>2018-05-02T12:40:49.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自我在 CSDN 的一篇博文，<a href="http://blog.csdn.net/g96968586/article/details/24185967" target="_blank" rel="noopener">原文链接</a>在这里，谢谢大家支持！</p></blockquote><p>谈起快速排序，大家都不陌生了，学过数据结构的人（除了那些逃课或者上课睡觉的人）都知道它，如果还有人现在不能马上手写出快速排序的算法，那就赶紧过来跟我一起重温一下快速排序的精髓吧！面试可是经常会被问起或当场手写代码的哦！<br><a id="more"></a></p><p>快速排序最早由图灵奖获得者 Tony Hoare 设计出来的，该算法被列为20世纪十大算法之一。</p><p>快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>我们现在直接上代码分析（C语言）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS bool  </span></span><br><span class="line"><span class="comment">//声明结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> r[MAXSIZE];  </span><br><span class="line"><span class="keyword">int</span> length;  </span><br><span class="line">&#125;SqList;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，下面会用到，在这里先定义  </span></span><br><span class="line"><span class="comment">/*交换 L 中数组 r 的下标为 i 和 j 的值*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> temp = L-&gt;r[i];  </span><br><span class="line">L-&gt;r[i] = L-&gt;r[j];  </span><br><span class="line">L-&gt;r[j] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span> <span class="params">( SqList *L)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Qsort(L,<span class="number">1</span>,L-&gt;length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于需要递归调用，我们外封装了一个函数，现在来看看 Qsort 的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low] ~ L-&gt;r[high]作快速排序，low为当前待排序的序列最小下标值，high为当前待排序的序列最大下标值 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span> <span class="params">( SqList *L,<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> pivot;  <span class="comment">/* 枢轴值 */</span>  </span><br><span class="line">  <span class="keyword">if</span>(low &lt; high)  </span><br><span class="line"> &#123;  </span><br><span class="line">     pivot = Partition (L,low,high);  <span class="comment">/* 将L-&gt;[low...high]一分为二，算出枢轴值pivot */</span>  </span><br><span class="line">     Qsort(L,low,pivot<span class="number">-1</span>);  <span class="comment">/* 对低子表递归操作 */</span>  </span><br><span class="line">     Qsort(L,pivot+<span class="number">1</span>,high);  <span class="comment">/* 对高子表递归操作 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段的核心是“pivot = Partition (L,low,high);” ，假设我们要对数组{50，10，90，30，70，40，80，60，20}进行排序，Partition函数要做的就是先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值都比它大，我们将这样的关键字成为枢轴（pivot）。</p><p>在经过Partition（L,1,9）的执行后，数组就变成{20，10，40，30，50，70，80，60，90}，并返回5给pivot，数字5表明50放置在数组下标为5的位置，这时候你是否发现，50左边的值均比它小，右边的值都比它大。后面的递归调用”Qsort(L,1,5-1);”和”Qsort(L,5+1,9)”语句，其实就是在对{20，10，40，30}和{70，80，60，90}进行同样的Partition操作，直到顺序全部正确为止。</p><p>下面就来看看核心函数Partition的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置，此时在它之前（后）的记录均不大（小）于它 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">( SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> pivotkey;  </span><br><span class="line">       pivotkey = L-&gt;r[low];   <span class="comment">/* 用子表的 第一个记录作枢轴记录 */</span>  </span><br><span class="line">       <span class="keyword">while</span>(low &lt; high)   <span class="comment">/* 从表的两端交替向中间扫描 */</span>  </span><br><span class="line">       &#123;  </span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)    high - - ;  </span><br><span class="line">            swap(L,low,high);    <span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span>  </span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey )   low ++;  </span><br><span class="line">            swap(L,low,high);  <span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">          <span class="keyword">return</span> low;   <span class="comment">/*  返回枢轴所在位置 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们照着代码来分析：</p><p><img src="http://img.blog.csdn.net/20140420174030281" alt=""><br><img src="http://img.blog.csdn.net/20140420174146656" alt=""><br><img src="http://img.blog.csdn.net/20140420174215093" alt=""><br><img src="http://img.blog.csdn.net/20140420174229531" alt=""><br><img src="http://img.blog.csdn.net/20140420174249531" alt=""><br><img src="http://img.blog.csdn.net/20140420174259296" alt=""></p><p>可以看出Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到左边，比它大的换到右边，它也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p><p>我在这里就不分析快排的时间和空间复杂度了，那些数字符号不想打，哈哈。快速排序的时间复杂度是O(nlogn)，空间复杂度为O(logn)。</p><p>最后注明一下，快速排序是一种不稳定的排序方法，因为它的关键字比较和交换是跳跃进行的。如果有人不清楚什么是稳定和不稳定算法，百度一下就知道啦！我在这里就不说了，在接下来一篇博客，我将带领大家一起去优化我们当前说的快速排序。是的，兜了大半天，我们当前的快速排序算法还不是最好的，还有很多地方可以优化呢~哈哈</p><p>附上Java语言编写的快速排序算法，比我们用c语言实现的思路要更加清晰，大家自行分析吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;       inti,j;  </span><br><span class="line">         i= start;  </span><br><span class="line">         j= end;  </span><br><span class="line">         <span class="keyword">if</span>((a==<span class="keyword">null</span>)||(a.length==<span class="number">0</span>))  </span><br><span class="line">             <span class="keyword">return</span>;  </span><br><span class="line">         <span class="keyword">while</span>(i&lt;j)&#123;  </span><br><span class="line">             <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=a[j])&#123;    <span class="comment">//以数组start下标的数据为key，右侧扫描  </span></span><br><span class="line">                 j--;  </span><br><span class="line">             &#125;  </span><br><span class="line">             <span class="keyword">if</span>(i&lt;j)&#123;                  <span class="comment">//右侧扫描，找出第一个比key小的，交换位置  </span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">                 a[i]= a[j];  </span><br><span class="line">                 a[j]= temp;  </span><br><span class="line">             &#125;  </span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;a[j])&#123;   <span class="comment">//左侧扫描（此时a[j]中存储着key值）  </span></span><br><span class="line">                 i++;  </span><br><span class="line">               &#125;  </span><br><span class="line">             <span class="keyword">if</span>(i&lt;j)&#123;                <span class="comment">//找出第一个比key大的，交换位置  </span></span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">                 a[i]= a[j];  </span><br><span class="line">                 a[j]= temp;  </span><br><span class="line">             &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i-start&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">             <span class="comment">//递归调用，把key前面的完成排序  </span></span><br><span class="line">            quickSort(a,start,i-<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(end-i&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">            quickSort(a,i+<span class="number">1</span>,end);   <span class="comment">//递归调用，把key后面的完成排序  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：参考书籍《大话数据结构》，文中的图片均出自该书。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自我在 CSDN 的一篇博文，&lt;a href=&quot;http://blog.csdn.net/g96968586/article/details/24185967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;在这里，谢谢大家支持！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谈起快速排序，大家都不陌生了，学过数据结构的人（除了那些逃课或者上课睡觉的人）都知道它，如果还有人现在不能马上手写出快速排序的算法，那就赶紧过来跟我一起重温一下快速排序的精髓吧！面试可是经常会被问起或当场手写代码的哦！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://G96968586.github.io/categories/DataStructure/"/>
    
    
      <category term="转载" scheme="http://G96968586.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>WebView 开车指南</title>
    <link href="http://G96968586.github.io/2016/09/18/WebView-%E5%BC%80%E8%BD%A6%E6%8C%87%E5%8D%97/"/>
    <id>http://G96968586.github.io/2016/09/18/WebView-开车指南/</id>
    <published>2016-09-18T07:21:33.000Z</published>
    <updated>2018-05-02T09:56:38.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://jiandanxinli.github.io/2016-08-31.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">简单心理·技术团队 WebView·开车指南</a></p></blockquote><p><strong>Tips</strong></p><p>1.由于WebView的用法实在太多，如果您只是想查询某个功能的使用——建议Ctrl+F（Commad+F）在本页面搜索关键字查找。</p><p>2.文章给前半部分大多是方法的介绍，若嫌琐碎可直接拖到最后看代码演示。</p><a id="more"></a><p><strong>前言</strong></p><p>喝酒不开车，开车不喝酒。</p><p><strong>目录</strong></p><p>1.WebView简介</p><p>2.WebView基本使用</p><p>3.WebView常用方法</p><p>4.WebSettings</p><p>5.WebViewClient</p><p>6.WebChromeClient</p><p>7.JavaScript与WebView交互</p><p>8.WebView加载优化</p><p>9.驾照考试</p><p>10.上路</p><h3 id="WebView简介"><a href="#WebView简介" class="headerlink" title="WebView简介"></a>WebView简介</h3><p>为了方便开发者实现在app内展示网页并与网页交互的需求，Android SDK提供了WebView组件。</p><p>它继承自AbsoluteLayout，展示网页的同时，也可以在其中放入其他的子View。</p><p>现如今，Hybrid应用似乎占据的APP的主流类型，那么关于WebView的使用就变得越发的重要。</p><p>从Android 4.4（KitKat）开始，原本基于WebKit的WebView开始基于Chromium内核，这一改动大大提升了WebView组件的性能以及对HTML5,CSS3,JavaScript的支持。不过它的API却没有很大的改动，在兼容低版本的同时只引进了少部分新的API，并不需要你做很大的改动。</p><p>不过有几点改变需要注意，但我尝试着翻译了下，发现还是英文原文说得好，所以我贴链接吧~~~</p><p><a href="https://developer.android.com/guide/webapps/migrating.html" target="_blank" rel="noopener">Migrating to WebView in Android 4.4</a></p><p>在WebView中，有几个地方是我们可以使用来定制我们的WebView各种行为的，分别是：<strong>WebSettings</strong>、<strong>JavaScriptInterface</strong>、<strong>WebViewClient</strong>以及<strong>WebChromeClient</strong>。这些我都会在接下来的文章中一一介绍。</p><h3 id="WebView基本使用"><a href="#WebView基本使用" class="headerlink" title="WebView基本使用"></a>WebView基本使用</h3><p>下面简单介绍下WebView的基本使用：</p><p>首先新建一个工程，在layout文件里放入一个WebView控件（当然也可以通过Java代码动态放入，这里不演示了）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Activity的onCreate方法里写入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">WebView webView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">webView.loadUrl(url);</span><br></pre></td></tr></table></figure><p>接着在AndroidManifest声明访问网络的权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>就，完事了~</p><p>这时运行app，它已经可以访问指定地址的网页了。</p><p>上面提到了WebView继承自AbsoluteLayout，可以在其中放入一些子View，那也顺手来一下。</p><p>Layout文件改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_x</span>=<span class="string">"170dp"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_y</span>=<span class="string">"400dp"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@string/app_name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">WebView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Activity的onCreate里加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">"系好安全带!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这时，运行app，里面就会多出一个Button~ 但如果你真的运行的话，你就会发现，app会自动跳到浏览器并打开指定的网页，而并非在app内展示网页，那这就与我们的初衷背道而驰了，那么要如何实现网页在App内打开呢?这就引出了下面的章节会提到的东西：WebViewClient。我先将代码贴出，具体实现原理留到下节说明。</p><p>最终XML布局就如上面那样，Java代码（最终）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">        WebView webView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">        webView.loadUrl(url);</span><br><span class="line"></span><br><span class="line">        webView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> </span>&#123;</span><br><span class="line">                view.loadUrl(request.toString());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">/*这里我说一下，如果返回false已一样可以在 webview 内加载页面，true 的意思是我们程序自己拦截做了处理，false 则代表交由 webview 自己处理，很多人都在这里返回 true，会误导大家的。另外，这里返回 true 的话，前端js 通过 document.referrer 是获取不到当前页面的前一个页面 URL 的，返回 false 则没有问题。官方文档地址在这里：http://developer.android.com/guide/webapps/webview.html*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getApplicationContext(), <span class="string">"系好安全带!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：<a href="http://www.iqiyi.com/w_19rsx20xst.html" target="_blank" rel="noopener">效果视频</a></p><h3 id="WebView简介-1"><a href="#WebView简介-1" class="headerlink" title="WebView简介"></a>WebView简介</h3><p>接下来再介绍一些WebView的常用方法，具体演示会在后面章节的代码里统一展示。</p><ul><li><strong>String getUrl</strong>()：获取当前页面的URL。</li><li><strong>reload</strong>()：重新reload当前的URL，即刷新。</li><li><strong>boolean canGoBack</strong>()：用来确认WebView里是否还有可回退的历史记录。通常我们会在WebView里重写返回键的点击事件，通过该方法判断WebView里是否还有历史记录，若有则返回上一页。</li><li><strong>boolean canGoForward</strong>()：用来确认WebView是否还有可向前的历史记录。</li><li><strong>boolean canGoBackOrForward</strong>(int steps)：以当前的页面为起始点，用来确认WebView的历史记录是否足以后退或前进给定的步数，正数为前进，负数为后退。</li><li><strong>goBack</strong>()：在WebView历史记录后退到上一项。</li><li><strong>goForward</strong>()：在WebView历史记录里前进到下一项。</li><li><strong>goBackOrForward</strong>(int steps)：以当前页面为起始点，前进或后退历史记录中指定的步数，正数为前进，负数为后退。</li><li><strong>clearCache</strong>(boolean includeDiskFiles)：清空网页访问留下的缓存数据。需要注意的时，由于缓存是全局的，所以只要是WebView用到的缓存都会被清空，即便其他地方也会使用到。该方法接受一个参数，从命名即可看出作用。若设为false，则只清空内存里的资源缓存，而不清空磁盘里的。</li><li><strong>clearHistory</strong>()：清除当前webview访问的历史记录。</li><li><strong>clearFormData</strong>()：清除自动完成填充的表单数据。需要注意的是，该方法仅仅清除<strong>当前表单域自动完成填充的表单数据</strong>，并不会清除WebView存储到本地的数据。</li><li><strong>onPause</strong>()：当页面被失去焦点被切换到后台不可见状态，需要执行onPause操作，该操作会通知内核安全地暂停所有动作，比如动画的执行或定位的获取等。需要注意的是该方法并不会暂停JavaScript的执行，若要暂停JavaScript的执行请使用接下来的这个方法。</li><li><strong>onResume</strong>()：在先前调用<strong>onPause()</strong>后，我们可以调用该方法来恢复WebView的运行。</li><li><strong>pauseTimers</strong>()：该方法面向全局整个应用程序的webview，它会暂停所有webview的layout，parsing，JavaScript Timer。当程序进入后台时，该方法的调用可以降低CPU功耗。</li><li><strong>resumeTimers</strong>()：恢复pauseTimers时的所有操作。</li><li><strong>destroy</strong>()：销毁WebView。需要注意的是：这个方法的调用应在WebView从父容器中被remove掉之后。我们可以手动地调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootLayout.removeView(webView);</span><br><span class="line">webView.destroy();</span><br></pre></td></tr></table></figure><ul><li><strong>getScrollY</strong>()：该方法返回的当前可见区域的顶端距整个页面顶端的距离，也就是当前内容滚动的距离。</li><li><strong>getHeight</strong>()：方法都返回当前WebView这个容器的高度。其实以上两个方法都属于View。</li><li><strong>getContentHeight</strong>()：该方法返回整个HTML页面的高度，但该高度值并不等同于当前整个页面的高度，因为WebView有缩放功能， 所以当前整个页面的高度实际上应该是原始HTML的高度再乘上缩放比例。因此，准确的判断方法应该是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (webView.getContentHeight() * webView.getScale() == (webView.getHeight() + webView.getScrollY())) &#123;</span><br><span class="line">    //已经处于底端</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(webView.getScrollY() == 0)&#123;</span><br><span class="line">    //处于顶端</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>pageUp</strong>(boolean top)：将WebView展示的页面滑动至顶部。</li><li><strong>pageDown</strong>(boolean bottom)：将WebView展示的页面滑动至底部。</li></ul><h3 id="WebSettings"><a href="#WebSettings" class="headerlink" title="WebSettings"></a>WebSettings</h3><p>WebSettings是用来管理WebView配置的类。当WebView第一次创建时，内部会包含一个默认配置的集合。若我们想更改这些配置，便可以通过WebSettings里的方法来进行设置。</p><p>WebSettings对象可以通过<strong>WebView.getSettings()</strong>获得，它的生命周期是与它的WebView本身息息相关的，如果WebView被销毁了，那么任何由WebSettings调用的方法也同样不能使用。</p><h3 id="获取WebSettings对象"><a href="#获取WebSettings对象" class="headerlink" title="获取WebSettings对象"></a>获取WebSettings对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = webView.getSettings();</span><br></pre></td></tr></table></figure><h3 id="WebSettings常用方法"><a href="#WebSettings常用方法" class="headerlink" title="WebSettings常用方法"></a>WebSettings常用方法</h3><p>（几乎所有的set方法都有相应的get方法，这里就只介绍set了。<strong>另，所有未写方法返回值类型的皆为空类型</strong>）</p><ul><li><strong>setJavaScriptEnabled</strong>(boolean flag)：设置WebView是否可以运行JavaScript。</li><li><strong>setJavaScriptCanOpenWindowsAutomatically</strong>(boolean flag)：设置WebView是否可以由JavaScript自动打开窗口，默认为false，通常与JavaScript的<strong>window.open()</strong>配合使用。</li><li><strong>setAllowFileAccess</strong>(boolean allow)：启用或禁用WebView访问文件数据。</li><li><strong>setBlockNetworkImage</strong>(boolean flag)：禁止或允许WebView从网络上加载图片。需要注意的是，如果设置是从禁止到允许的转变的话，图片数据并不会在设置改变后立刻去获取，而是在WebView调用reload()的时候才会生效。<br>这个时候，需要确保这个app拥有访问Internet的权限，否则会抛出安全异常。<br>通常没有禁止图片加载的需求的时候，完全不用管这个方法，因为当我们的app拥有访问Internet的权限时，这个flag的默认值就是false。</li><li><strong>setSupportZoom</strong>(boolean support)：设置是否支持缩放。</li><li><strong>setBuiltInZoomControls</strong>(boolean enabled)：显示或不显示缩放按钮（wap网页不支持）。</li><li><strong>setSupportMultipleWindows</strong>(boolean support)：设置WebView是否支持多窗口。</li><li><strong>setLayoutAlgorithm</strong>(WebSettings.LayoutAlgorithm l)：指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认值为LayoutAlgorithm#NARROW_COLUMNS。</li><li><strong>setNeedInitialFocus(boolean flag)</strong>：通知WebView是否需要设置一个节点获取焦点当WebView#requestFocus(int,android.graphics.Rect)被调用时，默认为true。</li><li><strong>setAppCacheEnabled(boolean flag)</strong>：启用或禁用应用缓存。</li><li><strong>setAppCachePath(String appCachePath)</strong>：设置应用缓存路径，这个路径必须是可以让app写入文件的。该方法应该只被调用一次，重复调用会被无视~</li><li><strong>setCacheMode(int mode)</strong>：<strong>用来设置WebView的缓存模式。</strong>当我们加载页面或从上一个页面返回的时候，会按照设置的缓存模式去检查并使用（或不使用）缓存。</li></ul><p>缓存模式有四种：</p><ol><li><strong>LOAD_DEFAULT</strong>：默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。</li><li><strong>LOAD_CACHE_ELSE_NETWORK</strong>：只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。</li><li><strong>LOAD_NO_CACHE</strong>：不加载缓存，只从网络加载数据。</li><li><strong>LOAD_CACHE_ONLY</strong>：不从网络加载数据，只从缓存加载数据。</li></ol><p>通常我们可以根据网络情况将这几种模式结合使用，比如有网的时候使用LOAD_DEFAULT，离线时使用LOAD_CACHE_ONLY、LOAD_CACHE_ELSE_NETWORK，让用户不至于在离线时啥都看不到。</p><ul><li><strong>setDatabaseEnabled(boolean flag)</strong>：启用或禁用数据库缓存。</li><li><strong>setDomStorageEnabled(boolean flag)</strong>：启用或禁用DOM缓存。</li><li><strong>setUserAgentString(String ua)</strong>：设置WebView的UserAgent值。</li><li><strong>setDefaultEncodingName(String encoding)</strong>：设置编码格式，通常都设为“UTF-8”。</li><li><strong>setStandardFontFamily(String font)</strong>：设置标准的字体族，默认“sans-serif”。</li><li><strong>setCursiveFontFamily</strong>：设置草书字体族，默认“cursive”。</li><li><strong>setFantasyFontFamily</strong>：设置CursiveFont字体族，默认“cursive”。</li><li><strong>setFixedFontFamily</strong>：设置混合字体族，默认“monospace”。</li><li><strong>setSansSerifFontFamily</strong>：设置梵文字体族，默认“sans-serif”。</li><li><strong>setSerifFontFamily</strong>：设置衬线字体族，默认“sans-serif”</li><li><strong>setDefaultFixedFontSize(int size)</strong>：设置默认填充字体大小，默认16，取值区间为[1-72]，超过范围，使用其上限值。</li><li><strong>setDefaultFontSize(int size)</strong>：设置默认字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。</li><li><strong>setMinimumFontSize</strong>：设置最小字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。</li><li><strong>setMinimumLogicalFontSize</strong>：设置最小逻辑字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。</li></ul><p>以上就是一些WebSettings的常用方法，具体的使用以及一些缓存的问题会在接下来的代码以及文章中有更加直观的说明。</p><h3 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h3><p>从名字上不难理解，这个类就像WebView的委托人一样，是帮助WebView处理各种通知和请求事件的，我们可以称他为WebView的“内政大臣”。</p><ul><li><strong>onLoadResource(WebView view, String url)</strong>：该方法在加载页面资源时会回调，每一个资源（比如图片）的加载都会调用一次。</li><li><strong>onPageStarted(WebView view, String url, Bitmap favicon)</strong>：该方法在WebView开始加载页面且仅在<strong>Main frame loading</strong>（即<strong>整页加载</strong>）时回调，一次Main frame的加载只会回调该方法一次。我们可以在这个方法里设定开启一个加载的动画，告诉用户程序在等待网络的响应。</li><li><strong>onPageFinished(WebView view, String url)</strong>：该方法只在WebView完成一个页面加载时调用一次（同样也只在<strong>Main frame loading</strong>时调用），我们可以可以在此时关闭加载动画，进行其他操作。</li><li><strong>onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)</strong>：该方法在web页面加载错误时回调，这些错误通常都是由无法与服务器正常连接引起的，最常见的就是网络问题。 这个方法有两个地方需要注意：</li></ul><p>1.这个方法只在与服务器无法正常连接时调用，类似于服务器返回错误码的那种错误（即<strong>HTTP ERROR</strong>），该方法是不会回调的，因为你已经和服务器正常连接上了（全怪官方文档(︶^︶)）；<br>2.这个方法是新版本的onReceivedError()方法，从API23开始引进，与旧方法onReceivedError(WebView view,int errorCode,String description,String failingUrl)不同的是，新方法在页面局部加载发生错误时也会被调用（比如页面里两个子Tab或者一张图片）。这就意味着该方法的调用频率可能会更加频繁，所以我们应该在该方法里执行尽量少的操作。</p><ul><li><strong>onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse)</strong>：上一个方法提到onReceivedError并不会在服务器返回错误码时被回调，那么当我们需要捕捉HTTP ERROR并进行相应操作时应该怎么办呢？<strong>API23</strong>便引入了该方法。当服务器返回一个HTTP ERROR并且它的status code&gt;=400时，该方法便会回调。这个方法的作用域并不局限于Main Frame，任何资源的加载引发HTTP ERROR都会引起该方法的回调，所以我们也应该在该方法里执行尽量少的操作，只进行非常必要的错误处理等。</li><li><strong>onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)</strong>：当WebView加载某个资源引发SSL错误时会回调该方法，这时WebView要么执行handler.cancel()取消加载，要么执行handler.proceed()方法继续加载（默认为cancel）。需要注意的是，这个决定可能会被保留并在将来再次遇到SSL错误时执行同样的操作。</li><li><strong>WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request)</strong>：当WebView需要请求某个数据时，这个方法可以拦截该请求来告知app并且允许app本身返回一个数据来替代我们原本要加载的数据。</li></ul><p>比如你对web的某个js做了本地缓存，希望在加载该js时不再去请求服务器而是可以直接读取本地缓存的js，这个方法就可以帮助你完成这个需求。你可以写一些逻辑检测这个request，并返回相应的数据，你返回的数据就会被WebView使用，如果你返回null，WebView会继续向服务器请求。</p><ul><li><strong>boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request)</strong>：哈~ 终于到了这个方法，在最开始的基础演示时我们用到了这个方法。从实践中我们知道，当我们没有给WebView提供WebViewClient时，WebView如果要加载一个url会向ActivityManager寻求一个适合的处理者来加载该url（比如系统自带的浏览器），这通常是我们不想看到的。于是我们需要给WebView提供一个WebViewClient，并重写该方法返回true来告知WebView url的加载就在app中进行。这时便可以实现在app内访问网页。</li><li><strong>onScaleChanged(WebView view, float oldScale, float newScale)</strong>：当WebView得页面Scale值发生改变时回调。</li><li><strong>boolean shouldOverrideKeyEvent(WebView view, KeyEvent event)</strong>：默认值为false，重写此方法并return true可以让我们在WebView内处理按键事件。</li></ul><h3 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h3><p>如果说WebViewClient是帮助WebView处理各种通知、请求事件的“内政大臣”的话，那么WebChromeClient就是辅助WebView处理Javascript的对话框，网站图标，网站title，加载进度等偏外部事件的“外交大臣”。</p><ul><li><strong>onProgressChanged(WebView view, int newProgress)</strong>：当页面加载的进度发生改变时回调，用来告知主程序当前页面的加载进度。</li><li><strong>onReceivedIcon(WebView view, Bitmap icon)</strong>：用来接收web页面的icon，我们可以在这里将该页面的icon设置到Toolbar。</li><li><strong>onReceivedTitle(WebView view, String title)</strong>：用来接收web页面的title，我们可以在这里将页面的title设置到Toolbar。</li></ul><p>以下两个方法是为了支持web页面进入全屏模式而存在的（比如播放视频），如果不实现这两个方法，该web上的内容便不能进入全屏模式。</p><ul><li><strong>onShowCustomView(View view, WebChromeClient.CustomViewCallback callback)</strong>：该方法在当前页面进入全屏模式时回调，主程序必须提供一个包含当前web内容（视频 or Something）的自定义的View。</li><li><strong>onHideCustomView()</strong>：该方法在当前页面退出全屏模式时回调，主程序应在这时隐藏之前show出来的View。</li><li><strong>Bitmap getDefaultVideoPoster()</strong>：当我们的Web页面包含视频时，我们可以在HTML里为它设置一个预览图，WebView会在绘制页面时根据它的宽高为它布局。而当我们处于弱网状态下时，我们没有比较快的获取该图片，那WebView绘制页面时的gitWidth()方法就会报出空指针异常~ 于是app就crash了。。</li></ul><p>这时我们就需要重写该方法，在我们尚未获取web页面上的video预览图时，给予它一个本地的图片，避免空指针的发生。</p><ul><li><strong>View getVideoLoadingProgressView()</strong>：重写该方法可以在视频loading时给予一个自定义的View，可以是加载圆环 or something。</li><li><strong>boolean onJsAlert(WebView view, String url, String message, JsResult result)</strong>：处理Javascript中的Alert对话框。</li><li><strong>boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)</strong>：处理Javascript中的Prompt对话框。</li><li><strong>boolean onJsConfirm(WebView view, String url, String message, JsResult result)</strong>：处理Javascript中的Confirm对话框</li><li><strong>boolean onShowFileChooser(WebView webView, ValueCallback filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)</strong>：该方法在用户进行了web上某个需要上传文件的操作时回调。我们应该在这里打开一个文件选择器，如果要取消这个请求我们可以调用<strong>filePathCallback.onReceiveValue(null)</strong>并返回<strong>true</strong>。</li><li><strong>onPermissionRequest(PermissionRequest request)</strong>：该方法在web页面请求某个尚未被允许或拒绝的权限时回调，主程序在此时调用<strong>grant(String [])</strong>或<strong>deny()</strong>方法。如果该方法没有被重写，则默认拒绝web页面请求的权限。</li><li><strong>onPermissionRequestCanceled(PermissionRequest request)</strong>：该方法在web权限申请权限被取消时回调，这时应该隐藏任何与之相关的UI界面。</li></ul><h3 id="Js与WebView交互"><a href="#Js与WebView交互" class="headerlink" title="Js与WebView交互"></a>Js与WebView交互</h3><p>既然嗨鸟应用大行其道，那么毫无疑问Android与JavaScript的交互我们也必须了解清楚，下面来介绍一下JavaScript与Android是如何互相调用的。</p><h4 id="利用WebView调用网页上的JavaScript代码"><a href="#利用WebView调用网页上的JavaScript代码" class="headerlink" title="利用WebView调用网页上的JavaScript代码"></a>利用WebView调用网页上的JavaScript代码</h4><p>在WebView中调用Js的基本格式为<strong>webView.loadUrl(“javascript:methodName(parameterValues)”);</strong></p><p><strong>现有以下这段JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readyToGo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    alert(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getYourCar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Car"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-WebView调用JavaScript无参无返回值函数"><a href="#1-WebView调用JavaScript无参无返回值函数" class="headerlink" title="1. WebView调用JavaScript无参无返回值函数"></a>1. WebView调用JavaScript无参无返回值函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String call = <span class="string">"javascript:readyToGo()"</span>;</span><br><span class="line">webView.loadUrl(call);</span><br></pre></td></tr></table></figure><h4 id="2-WebView调用JavScript有参无返回值函数"><a href="#2-WebView调用JavScript有参无返回值函数" class="headerlink" title="2. WebView调用JavScript有参无返回值函数"></a>2. WebView调用JavScript有参无返回值函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String call = <span class="string">"javascript:alertMessage(\""</span> + <span class="string">"content"</span> + <span class="string">"\")"</span>;</span><br><span class="line">webView.loadUrl(call);</span><br></pre></td></tr></table></figure><h4 id="3-WebView调用JavaScript有参数有返回值的函数"><a href="#3-WebView调用JavaScript有参数有返回值的函数" class="headerlink" title="3. WebView调用JavaScript有参数有返回值的函数"></a>3. WebView调用JavaScript有参数有返回值的函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evaluateJavaScript</span><span class="params">(WebView webView)</span></span>&#123;</span><br><span class="line">    webView.evaluateJavascript(<span class="string">"getYourCar()"</span>, <span class="keyword">new</span> ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"findCar"</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript通过WebView调用Java代码"><a href="#JavaScript通过WebView调用Java代码" class="headerlink" title="JavaScript通过WebView调用Java代码"></a>JavaScript通过WebView调用Java代码</h4><p>从API19开始，Android提供了@JavascriptInterface对象注解的方式来建立起Javascript对象和Android原生对象的绑定，提供给JavScript调用的函数必须带有@JavascriptInterface。</p><p><strong>演示一 JavaScript调用Android Toast方法</strong></p><p><strong>1. 编写Java原生方法并用使用@JavascriptInterface注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JavascriptInterface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Toast.makeText(getApplication(), s, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.注册JavaScriptInterface</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">this</span>, <span class="string">"android"</span>);</span><br></pre></td></tr></table></figure><p><strong>addJavascriptInterface的作用是把this所代表的类映射为JavaScript中的android对象。</strong></p><p><strong>3.编写JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toastClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.android.show(<span class="string">"JavaScript called~!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>演示二 JavaScript调用有返回值的Java方法</strong></p><p><strong>1.定义一个带返回值的Java方法，并使用@JavaInterface：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JavaInterface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello,boy~"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.添加JavaScript的映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavaScriptInterface(<span class="keyword">this</span>,<span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><p><strong>3.通过JavaScript调用Java方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="built_in">window</span>.Android.getMessage();</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Js与WebView交互的一些介绍，希望能对你有帮助。</p><h3 id="WebView加载优化"><a href="#WebView加载优化" class="headerlink" title="WebView加载优化"></a>WebView加载优化</h3><p>当WebView的使用频率变得频繁的时候，对于其各方面的优化就变得逐渐重要了起来。可以知道的是，我们每加载一个 H5页面，都会有很多的请求。除了HTML主URL自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个个独立的HTTP 请求，虽然请求是并发的，但当网页整体数量达到一定程度的时候，再加上浏览器解析、渲染的时间，Web整体的加载时间变得很长。同时请求文件越多，消耗的流量也会越多。那么对于加载的优化就变得非常重要，这方面的经验我也没有什么别的，大概三个方面：</p><h4 id="一个，就是资源本地化的问题"><a href="#一个，就是资源本地化的问题" class="headerlink" title="一个，就是资源本地化的问题"></a>一个，就是资源本地化的问题</h4><p>首先可以明确的是，以目前的网络条件，通过网络去服务器获取资源的速度是远远比不上从本地读取的。<strong>谈论各种优化策略其实恰恰忽略了“需要加载”才是阻挡速度提升的最大绊脚石。</strong>所以我们的思路一，就是将一些较重的资源比如js、css、图片甚至HTML本身进行本地化处理，在每次加载到这些资源的时候，从本地读取进行加载，可以简单记忆为<strong>“存·取·更”</strong>。</p><p>具体实现思路为：</p><ol><li><strong>“存”</strong>——将上述重量级资源打包进apk文件，每次加载相应文件时时从本地取即可。也可不打包，在第一次加载时以及接下来的若干间隔时间里动态下载存储，将所有的资源文件都存在Android的asset目录下；</li><li><strong>“取”</strong>——重写WebViewClient的<strong>WebResourceResponse shouldInterceptRequest</strong>(WebView view, WebResourceRequest request)方法，通过一定的判别方法（例如正则表达式）拦截相应的请求，从本地读取相应资源并返回；</li><li><strong>“更”</strong>——建立起Cache Control机制，定期或使用API通知的形式控制本地资源的更新，保证本地资源是最新和可用的。</li></ol><p>这里附上一篇博客链接，非常棒可供参考：<a href="http://tutorials.jenkov.com/android/android-web-apps-using-android-webview.html#caching-web-resources-in-the-android-device" target="_blank" rel="noopener">caching-web-resources-in-the-android-device</a></p><h4 id="第二个，就是缓存的问题"><a href="#第二个，就是缓存的问题" class="headerlink" title="第二个，就是缓存的问题"></a>第二个，就是缓存的问题</h4><p>倘若你不采用或不完全采用第一条资源本地化的思路，那么你的WebView缓存是必须要开启的（虽然这一思路和第一条有重合的地方）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">settings.setAppCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">settings.setDatabaseEnabled(<span class="keyword">true</span>);</span><br><span class="line">settings.setDomStorageEnabled(<span class="keyword">true</span>);<span class="comment">//开启DOM缓存</span></span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br></pre></td></tr></table></figure><p>在网络正常时，采用默认缓存策略，在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源以减少页面的网络请求次数。</p><p>这里值得提起的是，我们经常在app里用WebView展示页面时，并不想让用户觉得他是在访问一个网页。因为倘若我们的app里网页非常多，而我们给用户的感觉又都像在访问网页的话，我们的app便失去了意义。（我的意思是为什么用户不直接使用浏览器呢？）</p><p>所以这时，离线缓存的问题就值得我们注意。我们需要让用户在没有网的时候，依然能够操作我们的app，而不是面对一个和浏览器里的网络错误一样的页面，哪怕他能进行的操作十分有限。</p><p>这里我的思路是，在开启缓存的前提下，WebView在加载页面时检测网络变化，倘若在加载页面时用户的网络突然断掉，我们应当更改WebView的缓存策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line"><span class="keyword">if</span>(networkInfo.isAvailable()) &#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_DEFAULT);<span class="comment">//网络正常时使用默认缓存策略</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);<span class="comment">//网络不可用时只使用缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然有缓存，就要有缓存控制，与一相似的是我们也要建立缓存控制机制，定期或接受服务器通知来进行缓存的清空或更新。</p><h4 id="第三个，就是延迟加载和执行js"><a href="#第三个，就是延迟加载和执行js" class="headerlink" title="第三个，就是延迟加载和执行js"></a>第三个，就是延迟加载和执行js</h4><p>在WebView中，onPageFinished()的回调意味着页面加载的完成。但该方法会在JavScript脚本执行完成后才会触发，倘若我们要加载的页面使用了JQuery，会在处理完DOM对象，执行完$(document).ready(function() {})后才会渲染并显示页面。这是不可接受的，所以我们需要对Js进行延迟加载，当然这部分是Web前端的工作。</p><h4 id="如果说还有什么"><a href="#如果说还有什么" class="headerlink" title="如果说还有什么"></a>如果说还有什么</h4><p>那就是JsBridge一律不得滥用，这个对页面加载的完成速度是有很大影响的，倘若一个页面很多操作都通过JSbridge来控制，再怎么优化也无济于事（因为毕竟有那么多操作要实际执行）。同时要注意的是，不管你是否对资源进行缓存，都请将资源在服务器端进行压缩。因为无论是资源的获取和更新，都是要从服务器获取的，所以对于资源文件的压缩其实是<strong>最直接也最应该做</strong>的事情之一，但是一般服务器端都会做好，所以主要就是上面这三件事。</p><h2 id="驾照考试"><a href="#驾照考试" class="headerlink" title="驾照考试"></a>驾照考试</h2><p>介绍了这么多，希望能对你有点帮助。接下来时纯实战时间，我会将上面所介绍的很多知识点在接下来的代码里实际应用一遍，希望能够带给你更加直观的使用感受。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/progress_bar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:visibility</span>=<span class="string">"gone"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> WebView mWebView;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ProgressBar mProgressbar;</span><br><span class="line">  <span class="keyword">private</span> Toolbar mToolbar;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      supportRequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">      initAppBar();<span class="comment">//初始化Toolbar</span></span><br><span class="line"></span><br><span class="line">      initWebView();<span class="comment">//初始化WebView</span></span><br><span class="line">      initWebSettings();<span class="comment">//初始化WebSettings</span></span><br><span class="line">      initWebViewClient();<span class="comment">//初始化WebViewClient</span></span><br><span class="line">      initWebChromeClient();<span class="comment">//初始化WebChromeClient</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAppBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mToolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">      mToolbar.setTitle(<span class="string">"载入中.."</span>);</span><br><span class="line">      mToolbar.setTitleTextColor(getResources().getColor(R.color.colorWhite));</span><br><span class="line">      setSupportActionBar(mToolbar);</span><br><span class="line">      getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWebView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mWebView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">      mProgressbar = (ProgressBar) findViewById(R.id.progress_bar);</span><br><span class="line">      String url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">      mWebView.loadUrl(url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWebSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      WebSettings settings = mWebView.getSettings();</span><br><span class="line">      <span class="comment">//支持获取手势焦点</span></span><br><span class="line">      mWebView.requestFocusFromTouch();</span><br><span class="line">      <span class="comment">//支持JS</span></span><br><span class="line">      settings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//支持插件</span></span><br><span class="line">      settings.setPluginState(WebSettings.PluginState.ON);</span><br><span class="line">      <span class="comment">//设置适应屏幕</span></span><br><span class="line">      settings.setUseWideViewPort(<span class="keyword">true</span>);</span><br><span class="line">      settings.setLoadWithOverviewMode(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//支持缩放</span></span><br><span class="line">      settings.setSupportZoom(<span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">//隐藏原生的缩放控件</span></span><br><span class="line">      settings.setDisplayZoomControls(<span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">//支持内容重新布局</span></span><br><span class="line">      settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);</span><br><span class="line">      settings.supportMultipleWindows();</span><br><span class="line">      settings.setSupportMultipleWindows(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//设置缓存模式</span></span><br><span class="line">      settings.setDomStorageEnabled(<span class="keyword">true</span>);</span><br><span class="line">      settings.setDatabaseEnabled(<span class="keyword">true</span>);</span><br><span class="line">      settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">      settings.setAppCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">      settings.setAppCachePath(mWebView.getContext().getCacheDir().getAbsolutePath());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置可访问文件</span></span><br><span class="line">      settings.setAllowFileAccess(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//当webview调用requestFocus时为webview设置节点</span></span><br><span class="line">      settings.setNeedInitialFocus(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//支持自动加载图片</span></span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">          settings.setLoadsImagesAutomatically(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          settings.setLoadsImagesAutomatically(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      settings.setNeedInitialFocus(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//设置编码格式</span></span><br><span class="line">      settings.setDefaultTextEncodingName(<span class="string">"UTF-8"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWebViewClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//页面开始加载时</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onPageStarted(view, url, favicon);</span><br><span class="line">              mProgressbar.setVisibility(View.VISIBLE);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">//页面完成加载时</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">              mProgressbar.setVisibility(View.GONE);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//是否在WebView内加载新页面</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> </span>&#123;</span><br><span class="line">              view.loadUrl(request.toString());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//网络错误时回调的方法</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError error)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onReceivedError(view, request, error);</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 在这里写网络错误时的逻辑,比如显示一个错误页面</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 这里我偷个懒不写了</span></span><br><span class="line"><span class="comment">               * */</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@TargetApi</span>(Build.VERSION_CODES.M)</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedHttpError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceResponse errorResponse)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onReceivedHttpError(view, request, errorResponse);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWebChromeClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      mWebView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">private</span> Bitmap mDefaultVideoPoster;<span class="comment">//默认的视频展示图</span></span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedTitle</span><span class="params">(WebView view, String title)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.onReceivedTitle(view, title);</span><br><span class="line">              setToolbarTitle(title);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getDefaultVideoPoster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (mDefaultVideoPoster == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mDefaultVideoPoster = BitmapFactory.decodeResource(</span><br><span class="line">                          getResources(), R.drawable.video_default</span><br><span class="line">                  );</span><br><span class="line">                  <span class="keyword">return</span> mDefaultVideoPoster;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.getDefaultVideoPoster();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置Toolbar标题</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setToolbarTitle</span><span class="params">(<span class="keyword">final</span> String title)</span> </span>&#123;</span><br><span class="line">      Log.d(<span class="string">"setToolbarTitle"</span>, <span class="string">" WebDetailActivity "</span> + title);</span><br><span class="line">      <span class="keyword">if</span> (mToolbar != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mToolbar.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  mToolbar.setTitle(TextUtils.isEmpty(title) ? getString(R.string.loading) : title);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">      getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">          <span class="keyword">case</span> R.id.page_up:</span><br><span class="line">              Toast.makeText(getApplicationContext(), <span class="string">"页面向上"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">              mWebView.pageUp(<span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> R.id.page_down:</span><br><span class="line">              Toast.makeText(getApplicationContext(), <span class="string">"页面向下"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">              mWebView.pageDown(<span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> R.id.refresh:</span><br><span class="line">              Toast.makeText(getApplicationContext(), <span class="string">"刷新~"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">              mWebView.reload();</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果按下的是回退键且历史记录里确实还有页面</span></span><br><span class="line">      <span class="keyword">if</span> ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;</span><br><span class="line">          mWebView.goBack();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Toast.makeText(getApplicationContext(), <span class="string">"考试结束,恭喜您考试合格!"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图：</p><p>fuck，效果图太大压缩无望~~~ <a href="http://www.iqiyi.com/w_19rsx24znp.html" target="_blank" rel="noopener">效果图看外链视频吧</a></p><h2 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h2><p>好了，到此为止你已阅读完所有的指南，送你一辆车，上路吧。</p><p><img src="https://cloud.githubusercontent.com/assets/12692071/18089238/78f70d26-6ef1-11e6-8b7d-2b821fd92355.jpg" alt="车"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.android.com/guide/index.html" target="_blank" rel="noopener">Android官方文档</a></p><p><a href="http://tutorials.jenkov.com/android/android-web-apps-using-android-webview.html" target="_blank" rel="noopener">Android Web Apps Using Android WebView</a></p><p><a href="https://yq.aliyun.com/articles/32559" target="_blank" rel="noopener">史上最全webview详解</a></p><p><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=267" target="_blank" rel="noopener">H5 缓存机制浅析 移动端 Web 加载性能优化</a></p><p><a href="http://www.jianshu.com/p/427600ca2107" target="_blank" rel="noopener">WebView加载速度优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自&lt;a href=&quot;https://jiandanxinli.github.io/2016-08-31.html?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简单心理·技术团队 WebView·开车指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.由于WebView的用法实在太多，如果您只是想查询某个功能的使用——建议Ctrl+F（Commad+F）在本页面搜索关键字查找。&lt;/p&gt;
&lt;p&gt;2.文章给前半部分大多是方法的介绍，若嫌琐碎可直接拖到最后看代码演示。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
      <category term="转载" scheme="http://G96968586.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
