<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>箫鉴哥</title>
  <icon>https://www.gravatar.com/avatar/450d2f9c65192a3fc3f264439c8ae658</icon>
  <subtitle>如果没能一次成功，那就叫它1.0版吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://G96968586.github.io/"/>
  <updated>2018-06-05T08:54:08.734Z</updated>
  <id>http://G96968586.github.io/</id>
  
  <author>
    <name>箫鉴哥</name>
    <email>huijian.xhj@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Questions: Add Two Numbers</title>
    <link href="http://G96968586.github.io/2018/06/04/LeetCode-Questions-Add-Two-Numbers/"/>
    <id>http://G96968586.github.io/2018/06/04/LeetCode-Questions-Add-Two-Numbers/</id>
    <published>2018-06-04T15:29:46.000Z</published>
    <updated>2018-06-05T08:54:08.734Z</updated>
    
    <content type="html"><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><a id="more"></a><p>My answer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var addTwoNumbers = function(l1, l2) &#123;</span><br><span class="line">  // 进位</span><br><span class="line">  let carry = false;</span><br><span class="line">  // 先取第一个节点</span><br><span class="line">  let l1Node = l1;</span><br><span class="line">  let l2Node = l2;</span><br><span class="line">  // 临时节点</span><br><span class="line">  let tmpNode;</span><br><span class="line">  while(l1Node &amp;&amp; l2Node || carry) &#123;</span><br><span class="line">      let sum = 0;</span><br><span class="line">      if (l1Node) &#123;</span><br><span class="line">          sum += l1Node.val;</span><br><span class="line">      &#125;</span><br><span class="line">      if (l2Node) &#123;</span><br><span class="line">          sum += l2Node.val;</span><br><span class="line">      &#125;</span><br><span class="line">      // 此次运算是否需要进位加 1</span><br><span class="line">      if (carry) &#123;</span><br><span class="line">          sum += 1;</span><br><span class="line">          // 复位</span><br><span class="line">          carry = false;</span><br><span class="line">      &#125;</span><br><span class="line">      // 判断是否进位</span><br><span class="line">      if (sum &gt; 9) &#123;</span><br><span class="line">          sum -= 10;   </span><br><span class="line">          // 告知下一次循环需要进位</span><br><span class="line">          carry = true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (l1Node) &#123;</span><br><span class="line">        // 存放最后一个 l1Node 非空节点</span><br><span class="line">        tmpNode = l1Node;</span><br><span class="line">        l1Node.val = sum;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 如果 l1Node 为空，则拿它的前一个节点（这里是 tmpNode）的 next 拼接上新的节点</span><br><span class="line">        tmpNode.next = new ListNode(sum);</span><br><span class="line">        tmpNode = tmpNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      // 取链表下一个节点</span><br><span class="line">      l1Node = l1Node &amp;&amp; l1Node.next;</span><br><span class="line">      l2Node = l2Node &amp;&amp; l2Node.next;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果较长链表 是 l2，则链接在 l1 的末端</span><br><span class="line">  if (l2Node) &#123;</span><br><span class="line">    tmpNode.next = l2Node;</span><br><span class="line">  &#125;</span><br><span class="line">    return l1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gw.alicdn.com/tfs/TB1fLSZvTtYBeNjy1XdXXXXyVXa-2332-792.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;br&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;p&gt;Example&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: 342 + 465 = 807.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://G96968586.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://G96968586.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Questions: Two Sum</title>
    <link href="http://G96968586.github.io/2018/05/19/LeetCode-Questions-Two-Sum/"/>
    <id>http://G96968586.github.io/2018/05/19/LeetCode-Questions-Two-Sum/</id>
    <published>2018-05-19T05:41:35.000Z</published>
    <updated>2018-05-19T05:43:38.938Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gw.alipayobjects.com/zos/skylark/53af2bf7-990e-4ae7-9e4e-d63ff79cba28/2018/png/4feccaef-8798-47a9-977a-c383315bf53e.png" alt="img"></p><a id="more"></a><p>My answer: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    // my answer</span><br><span class="line">    var result = [];</span><br><span class="line">    var length = nums.length;</span><br><span class="line">    if (length &gt; 0) &#123;</span><br><span class="line">        for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            var tmp = target - nums[i];</span><br><span class="line">            var tmpIndex = nums.lastIndexOf(tmp);</span><br><span class="line">            if (tmpIndex &gt; 0) &#123;</span><br><span class="line">                result = [i, tmpIndex];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gw.alipayobjects.com/zos/skylark/488e5f55-0272-4a56-bf46-6b6d6bed9327/2018/png/40c9eae9-4d97-4276-a13b-64744fd20025.png" alt="img"></p><p>You can see, my runtime is 207ms, see another best answer:</p><p><img src="https://gw.alipayobjects.com/zos/skylark/7156a3f7-7caa-4a90-905c-2fc8c4a6e59b/2018/png/1d87cfb2-3c31-46ac-bfb0-74fba0d20a93.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/53af2bf7-990e-4ae7-9e4e-d63ff79cba28/2018/png/4feccaef-8798-47a9-977a-c383315bf53e.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://G96968586.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://G96968586.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Composition 事件</title>
    <link href="http://G96968586.github.io/2018/05/17/%E6%B5%85%E6%9E%90-composition-%E4%BA%8B%E4%BB%B6/"/>
    <id>http://G96968586.github.io/2018/05/17/浅析-composition-事件/</id>
    <published>2018-05-17T08:59:56.000Z</published>
    <updated>2018-05-18T04:53:45.810Z</updated>
    
    <content type="html"><![CDATA[<p>今天开会时听同事分享了用 Composition 事件解决输入法的问题，在这里跟大家分享下。</p><p>也许你还不清楚什么是 Composition 事件，别着急，在这里，我先跟大家说说我们碰到的输入法问题是什么，这是一个很常见的问题。</p><a id="more"></a><p>以微博为例子，我们知道，一条微博最多只能输入 140 个字，这就需要我们实时去计算输入框的字数，输入内容超过长度以后不允许输入，这是一个很常见的功能需求。但实际上，在输入法输入过程中和输入完成时的统计结果有可能是不一致的。</p><p>见下面的 Demo ：</p><p><img src="https://gw.alicdn.com/tfs/TB1kiwJr7CWBuNjy0FaXXXUlXXa-2878-284.png" alt="img"></p><p><img src="https://gw.alicdn.com/tfs/TB1ofoBr7yWBuNjy0FpXXassXXa-2876-280.png" alt="img"></p><p>另一个例子，比如：输入框输入一二三四五六七八九十。现在已经输入了一二三四五六七八九。如果是实时的去判断并过滤超长内容的话，想要通过输入 shi 来输出十几乎是做不到的，它总是被截断为 sh。这时候我们就可以通过 Composition 事件来解决以上的问题。Composition 的具体介绍可以看比较权威的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent" target="_blank" rel="noopener">MDN Composition</a>。它主要是用来监听输入法的事件。</p><p>composition event在keydown事件之后被触发，触发的是 compositionstart、compositionupdate 还是 compositionend 事件则取决于当时输入法编辑器的状态。你可以通过这个<a href="https://dvcs.w3.org/hg/d4e/raw-file/tip/key-event-test.html" target="_blank" rel="noopener">在线示例</a>来观察键盘的事件和顺序。</p><p>Ok, 下面我们可以通过编程来直接解决上面的问题了。</p><p>在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" target="_blank" rel="noopener">keyboard event</a> 文档中可以找到 isComposing 事件属性。在 compositionstart 和 compositionend 之间其值为 true。但遗憾的是在目前测试的几个浏览器中，isComposing 的值始终是 undefined。所以需要另觅方法，最容易想到的就是利用 compositionstart 和 compositionend 事件来模拟出 isComposing 这个状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var isComposing = false;</span><br><span class="line">$input.on(&apos;input&apos;, function() &#123;</span><br><span class="line">    if(isComposing) return;</span><br><span class="line">    console.log(&apos;value change&apos;);</span><br><span class="line">&#125;).on(&apos;compositionstart compositionend&apos;, function(ev) &#123;</span><br><span class="line">    isComposing = ev.type === &quot;compositionstart&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上处理在不支持 composition event 的浏览器上也不会出错。</p><p>另外，composition 事件有一个 data 属性表示当前的输入值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$input.on(&apos;compositionstart compositionupdate compositionend&apos;, function(ev) &#123;</span><br><span class="line">    if(ev.type === &quot;compositionstart&quot;) &#123;</span><br><span class="line">        // 此时表示进入输入法的开始编辑状态，这个时候ev.data表示输入框中选择的内容，即会被替换掉的内容。</span><br><span class="line">    &#125;else if(ev.type === &quot;compositionupdate&quot;) &#123;</span><br><span class="line">        // 此时表示在输入法开始编辑状态之后，新的键入操作。此时 ev.data 为当前输入法编辑器中的内容。</span><br><span class="line">    &#125;else if(ev.type === &quot;compositionend&quot;) &#123;</span><br><span class="line">        // 此时表示退出了输入法编辑状态。ev.data 值为即将输出的实际内容。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Demo 解决方案可参考 <a href="https://codepen.io/g96968586/pen/aGQaNE" target="_blank" rel="noopener">CodePan</a>.</p><p>React 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class InputText extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    textLength: 100,</span><br><span class="line">    value: &apos;&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onChange = (e) =&gt; &#123;</span><br><span class="line">    const &#123; isComposing &#125; = e.nativeEvent;</span><br><span class="line">    const &#123; value &#125; = e.target;</span><br><span class="line">    const &#123; textLength &#125; = this.state;</span><br><span class="line">    let text = value.replace(/^\s+|\s+$/gmi, &apos;&apos;);</span><br><span class="line">    this.setState(&#123; value: text &#125;);</span><br><span class="line">    if (!isComposing) &#123;</span><br><span class="line">      if (text.length &gt; 100) &#123;</span><br><span class="line">        text = text.substring(0, 100);</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        textLength: 100 - text.length,</span><br><span class="line">      &#125;)  </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onComposition = (e) =&gt; &#123;</span><br><span class="line">    if (e.type === &apos;compositionend&apos;) &#123;</span><br><span class="line">      const &#123; value &#125; = e.target;</span><br><span class="line">      let text = value.replace(/^\s+|\s+$/gmi, &apos;&apos;);</span><br><span class="line">      if (text.length &gt; 100) &#123;</span><br><span class="line">        text = text.substring(0, 100);</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        textLength: 100 - text.length,</span><br><span class="line">        value: text,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=&quot;right&quot;&gt;还可以输入 &lt;strong&gt;&#123;this.state.textLength&#125;&lt;/strong&gt; 个字  &lt;/div&gt;</span><br><span class="line">        &lt;TextArea</span><br><span class="line">          placeholder=&quot;字数限制100&quot;</span><br><span class="line">          autosize=&#123;&#123; minRows: 2, maxRows: 6 &#125;&#125;</span><br><span class="line">          onChange=&#123;this.onChange&#125;</span><br><span class="line">          onCompositionStart=&#123;this.onComposition&#125;</span><br><span class="line">          onCompositionUpdate=&#123;this.onComposition&#125;</span><br><span class="line">          onCompositionEnd=&#123;this.onComposition&#125;</span><br><span class="line">          value=&#123;this.state.value&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图见下面：</p><p><img src="https://gw.alicdn.com/tfs/TB16NiLsntYBeNjy1XdXXXXyVXa-2878-284.png" alt="img"></p><p><img src="https://gw.alicdn.com/tfs/TB14NiLsntYBeNjy1XdXXXXyVXa-2878-282.png" alt="img"></p><p>注意!!! 在移动端（ios7、android4.3）对于输入法几乎都不响应 keyup 事件。而开启计时器来做判断的话，在 IOS6 以下会有些莫名的问题。所以移动端慎用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开会时听同事分享了用 Composition 事件解决输入法的问题，在这里跟大家分享下。&lt;/p&gt;
&lt;p&gt;也许你还不清楚什么是 Composition 事件，别着急，在这里，我先跟大家说说我们碰到的输入法问题是什么，这是一个很常见的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前端与交互设计" scheme="http://G96968586.github.io/categories/Front-end/"/>
    
    
      <category term="前端与交互设计" scheme="http://G96968586.github.io/tags/%E5%89%8D%E7%AB%AF%E4%B8%8E%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅谈智能语音交互</title>
    <link href="http://G96968586.github.io/2018/04/04/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92/"/>
    <id>http://G96968586.github.io/2018/04/04/浅谈智能语音交互/</id>
    <published>2018-04-04T03:19:37.000Z</published>
    <updated>2018-05-10T03:21:14.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近两年，人工智能发展迅猛，语音识别作为人工智能最成熟的技术之一，现已成为很多智能设备甚至是 App 的标配。各大科技巨头也相继推出了具有代表性的智能语音产品，比如，国外有亚马逊的 <a href="https://www.amazon.com/Amazon-Echo-Bluetooth-Speaker-with-WiFi-Alexa/dp/B00X4WHP5E" target="_blank" rel="noopener">Amazon Echo</a>、微软的 <a href="https://www.microsoft.com/en-us/search/result.aspx?q=cortana#nav-downloads" target="_blank" rel="noopener">Cortana</a>、谷歌的 <a href="https://assistant.google.com/" target="_blank" rel="noopener">Google Assistant</a>、脸书的 <a href="https://www.theguardian.com/technology/2015/aug/27/facebook-m-virtual-assistant-siri-google-now" target="_blank" rel="noopener">Facebook M</a> 等，国内有阿里巴巴的 <a href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.676e5549peca3Q&amp;id=557856671085&amp;skuId=3572248181527&amp;user_id=3081047815&amp;cat_id=2&amp;is_b=1&amp;rn=ab5f34354c32a735c187eb22609ca729" target="_blank" rel="noopener">天猫精灵</a> 、百度的 <a href="https://dueros.baidu.com/" target="_blank" rel="noopener">度秘</a> 以及科大讯飞的 <a href="http://www.xfyun.cn/" target="_blank" rel="noopener">智能语音输入法</a> 等等。<br><a id="more"></a><br>目前，市面上最常见的语音交互使用场景还是语音助手。语音助手主要提供的是事务处理和知识服务。比如：询问天气预报、提供位置导航服务、推荐周边好吃的东西、播放想听的音乐、设定闹钟、问答等等，这些都是大家熟悉的不能再熟悉的例子了。有些语音助手，一出生就是为了解决某类行业的问题，就会推出专属领域的版本，比如百度地图的 “小度”，贴心解决用户的出行问题；阿里的小蜜，致力于成为会员的购物私人助理，等等。</p><p>在当今的移动互联网+大数据时代，智能语音交互技术将架起用户跟成千上万的互联云端服务之间的桥梁，成为下一个必争的入口。</p><h2 id="语音交互能给用户带来巨大的体验优化"><a href="#语音交互能给用户带来巨大的体验优化" class="headerlink" title="语音交互能给用户带来巨大的体验优化"></a>语音交互能给用户带来巨大的体验优化</h2><ul><li><p>服务直达</p><ul><li>在设备上众多的 App 中通过语音操纵某个 App 完成一系列的相关操作。<br>  例如：对着手机说 “使用高德地图导航去阿里巴巴西溪园区”，手机就会打开高德地图，自动进入导航页面，开始播放语音导航指引；又或者对着手机说 “用支付宝给某某转账 100 元”，就可以直接打开支付宝，把转账金额和对象确定好，等待用户确认就可以完成转账。</li><li>在客服服务中心通话过程中直接用语音直达适合自己的服务选项<br>  例如：用户致电淘宝客服说 “我要退货”，系统就会直接把用户转接到“退货退款”相关技能组，并把相关信息展示给客服小二。</li></ul></li><li><p>操作便利</p><ul><li>穿戴设备如手环，手表，都有屏幕小，触控不便的弱点，加上语音交互必然会带来很大的便利性。</li><li>蓝牙耳机，若内置语音识别功能，从此听歌切歌、调音量、接电话再也不需要手动操作。现在的耳机很多都带存储卡，通过简单的语音口令，控制播放本地音乐，摆脱对手机和网络的依赖。</li><li>通过智能音箱或是其他的语音控制中心来操纵智能家具。</li></ul></li><li><p>挖掘价值</p><ul><li>很多的录音数据很难直接被利用和分析，若通过语音识别将录音转成文字，就可以利用自然语言处理技术和算法模型来发掘价值了</li></ul></li><li><p>改变智能客服机器人的交互方式</p><ul><li>市面上智能客服机器人已经很常见了，但大多都是文字聊天式的。如果能在电话通信服务这块加入语音识别交互，利用实时识别技术将通信语音转为文字，在服务端通过语义理解、语言模型处理和语音合成技术做到模拟真人回复用户，这将给智能客服机器人带来一种全新的交互方式。</li></ul></li></ul><h2 id="语音识别原理"><a href="#语音识别原理" class="headerlink" title="语音识别原理"></a>语音识别原理</h2><p>智能语音关键技术在语音识别这一块。顾名思义，语音识别是以语音作为研究对象，通过信号处理技术和模式识别让机器能够自动识别和理解人类口述的语言。</p><p>语音其实就是一种声波，怎么将这种波转换成机器可以识别的内容，这是第一步，也叫特征提取。但一般在特征提取之前，我们会对语音进行预处理，通过信号处理的一些技术对其收尾端的静音进行切除，降低对后续步骤造成的干扰。对静音切除的这一操作，一般叫做 <a href="https://en.wikipedia.org/wiki/Voice_activity_detection" target="_blank" rel="noopener">VAD</a>。如下面波形图所示：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/a8aa217b-c19c-4ff7-bf6c-8756e1be58b9/2018/png/bd4ef7d2-d4ff-4e36-bbf0-ddae1214c417.png" alt="image | center | 520x132"></p><p>这里我们对波的处理必须是未经过压缩的纯波形文件，像 mp3、ogg 等因为是压缩过的格式文件，所以是不能被选为波处理输入源文件。这也就是为什么我们在进行模型训练时都选择 <a href="https://en.wikipedia.org/wiki/WAV" target="_blank" rel="noopener">wav</a> 格式的音频文件。wav 文件除了文件头携带的一些信息外，剩下的就是声音波形的一个个纯点了。接下来，需要对声音进行分帧，即把声音分成一小段一小段，每一小段我们称为一帧。分帧的操作是通过移动 <a href="https://en.wikipedia.org/wiki/Window_function" target="_blank" rel="noopener">窗函数</a> 来实现的。一般帧与帧之间存在着交叠，如下图红色区块所示：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/a639a306-1e1a-432b-959c-f90b6e541c18/2018/png/7afea443-3142-41ff-a1ec-7328a10a6057.png" alt="image | center | 415x216"></p><p>可以看出，每一帧的长度为 25 ms，红色部分为交叠部分，长度为 15 ms，即帧移为 10 ms。对于这种分帧，我们称为以帧长25ms、帧移 10ms 分帧。分帧后，语音变成了很多小段。由于分帧后的波形在时域上几乎没描述能力，接着还需对其波形进行变换，这一过程叫做声学特征提取。常见的一种变换方法是提取 MFCC 特征。根据人耳的生理特性，把每一帧波形变成一个多维向量，我们可以简单地理解为这个向量包含了这帧语音的内容信息。假设声学特征是 12 维，声音就成了一个 12 行、N（总帧数）列的一个矩阵，我们称之为观察序列。如下图所示，每一帧都用一个 12 维的向量表示，色块的颜色深浅表示向量值的大小。</p><p><img src="https://gw.alipayobjects.com/zos/skylark/c55ebbde-4618-4737-a595-56dc2657c2d0/2018/png/162b512d-f482-49ff-9530-b336682ba86c.png" alt="image | center | 225x237"></p><p>到此，特征提取已经完成。接下来就要考虑怎样把这个矩阵变成文本，即建立语音模版。先了解两个概念：</p><ul><li><p>音素：单词的发音由音素构成。对英语，一种常用的音素集是卡内基梅隆大学的一套由 39 个音素构成的音素集，具体可参见 <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict" target="_blank" rel="noopener">The CMU Pronouncing Dictionary</a>。汉语一般直接用全部声母和韵母作为音素集，另外，汉语识别还分有调无调，这里不进一步详述。</p></li><li><p>状态：简单理解成比音素更细致的语音单位，通常把一个音素划分成 3 个状态。</p></li></ul><p>语音识别通常是这样工作的，将帧识别成状态，这一步是难点，然后把状态组合成音素，再把音素组合成单词，我们来看下面这张图：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/65cbd905-adf7-41f5-ad48-1c9e36116831/2018/png/ae27524f-adbf-4047-bb89-9640575daf31.png" alt="image | center | 361x205"></p><p>图中每个竖条代表一帧，S1029、S124 等是状态，ay 是音素。可以发现，状态由若干帧组合成，音素则由三个状态组合成。现在，我们可以知道，只需要能找到每一帧所对应的状态，也就可以识别出结果了。有一个方法，就是看帧对应哪个状态的概率最大，那这帧就属于那个状态（注：一帧可以对应多个状态）。<br><img src="https://gw.alipayobjects.com/zos/skylark/b1e344b0-8d52-4038-9cfd-334935359769/2018/png/ae20359d-3de4-47eb-87e6-edc087e376fc.png" alt="image | center"></p><p>上图一帧对应了 S1 ～ S5 五个状态，可以看出该帧在 S3 所处的概率最大，所以该帧的状态就为 S3。那这些状态的概率是哪来的呢？这就要提到模型库中的声学模型了。声学模型里有一大堆的参数，从这些参数里可以找到帧与状态对应的概率。这一大堆的参数是通过海量的语音数据训练得到的。</p><p>现在又有一个新的问题，因为每一帧都会得到一个状态号，所以最后整个语音就会得到一堆乱七八糟的状态号，相邻两帧间的状态号基本都不相同。假设语音有 1000 帧，每帧对应 1 个状态，每 3 个状态组合成一个音素，那么大概会组合成 300 个音素，但这段语音其实根本没有这么多音素。如果真这么做，得到的状态号可能根本无法组合成音素。实际上，相邻帧的状态应该大多数都是相同的才合理，因为每帧很短。解决这个问题需要用到隐马尔可夫模型，求最大似然状态路径。对于不了解隐马尔可夫模型的同学，可以参见这篇知乎问答<a href="https://www.zhihu.com/question/20962240" target="_blank" rel="noopener">《如何用简单易懂的例子解释隐马尔可夫模型》</a>，这里不做过多解释。</p><p>在语音识别中应用隐马尔可夫模型的整个过程，我们称之为“解码”。首先，需要搭建一个状态网络（由单词级网络展开成音素网络，再由音素网络展开称状态网络）。如果我们要识别任意的文本，则必须要保证这个状态网络足够的大，但这个网络越大，想要达到比较好的识别准确率就越难。所以要根据实际任务的需求，合理选择网络大小和结构。其次，则是在这个状态网络中寻找与声音最匹配的路径，语音识别过程其实就是在状态网络中搜索一条最佳路径，语音对应这条路径的概率最大。</p><p>前面所说的概率，由三部分构成，分别是：观察概率（每帧和每个状态对应的概率）、转移概率（每个状态转移到自身或转移到下个状态的概率）和语言概率（根据语言统计规律得到的概率）。前两种概率从声学模型中获取，最后一种概率从语言模型中获取。语言模型是使用大量的文本训练出来的，可以利用某门语言本身的统计规律来帮助提升识别正确率。语言模型很重要，如果不使用语言模型，当状态网络较大时，识别出的结果基本是一团遭。<br>至此，语音识别的过程就完成了。</p><p>简单的总结，语音从输入到被识别出来，会经历：语音信号预处理 -&gt; 特征提取 -&gt; 模式匹配 -&gt; 参考模型库 -&gt; 识别结果。基本结构如下图所示：<br><img src="https://gw.alipayobjects.com/zos/skylark/23156966-fda4-45f7-a413-015c79eb79e1/2018/png/69d5f6b4-01f5-4845-8531-567882a58c7f.png" alt="image | center"></p><h2 id="业务思考"><a href="#业务思考" class="headerlink" title="业务思考"></a>业务思考</h2><p>利用创新技术去推动优化产品，充分发挥技术的价值。这里以 <a href="http://h5.m.taobao.com/job/cloud-work/index.html" target="_blank" rel="noopener">阿里众包</a> 为例，我们可以利用创新技术去做哪些改进。</p><p>阿里众包有 B、C 端两个产品，B 端用于发布工作，招募人员来完成工作并给出约定的报酬。C 端用户可以根据自己的兴趣去报名工作，然后申领任务并完成，最终拿取薪资报酬。众包有一种语音类型的工作，这类工作主要是收集符合条件的语音用于特定模型的训练。举个例子，如图所示：</p><p><img src="https://gw.alipayobjects.com/zos/skylark/d8a74614-c392-43c9-9a4e-212676868b03/2018/png/533f4c96-055f-4020-8bc6-535e19515359.png" alt="image | center | 290x512"></p><p>有商家发布了《粤语朗读-xc》的语音任务，上面有该任务的报名基本要求，工作简介里面写的是任务要求，也就是用户在录音时需要注意的地方。现在我已经成功报了名，并完成了一些任务，正处于等待任务验收的阶段，等众包工作人员审核通过后，我就可以拿到属于我的报酬了。</p><p><img src="https://gw.alipayobjects.com/zos/skylark/909097ce-f5c2-48c5-9d7d-2168a584e85d/2018/png/3e322ea7-b2e2-4138-9d02-096a0801e562.png" alt="image | center | 289x511"></p><p>然而，在这个流程当中存在着两个痛点，一是产品前端保证不了用户按照任务要求录入语音，这样会给后端的质检工作人员带来额外的工作量，导致任务质检的时间增多。下图是当前用户端做任务的流程图：</p><p><img src="https://cdn.yuque.com/lark/2018/png/16729/1522501096484-f26337bb-4e9a-41a1-b11a-f37a8584c483.png" alt="老流程.png | left | 650x40"></p><p>二是任务的数量原本就是有限的，这样会降低任务的完成率，导致后面商家不得不再重新发布一次任务收集语音样本，造成了额外的时间和人力成本。</p><p>我们是否可以借助智能语音识别技术，去做一些流程上的优化呢？拿前面的流程图，稍微做如下的改造，<br><img src="https://cdn.yuque.com/lark/2018/png/16729/1522502253994-af13d286-7a30-40f4-80e0-126f6aab4997.png" alt="a.png | center | 619x357"></p><p>我们在产品前端加上了语音识别模块，在用户提交结果前先把用户朗读的语音样本转为文本，做一次样本质量校验，比如，判断用户是否读错字或者漏字，或者拉长音、咬字不清等。如果不符合任务要求，则提示用户重做任务；如果部分不符合要求，比如存在停顿、噪音等问题，我们可以通过技术去优化。这样既提高了产品使用体验，也大大提高了任务的完成率和后面的质检效率，一举多得。</p><p>当然，由于任务的工种很多，有一些工种是不需要对用户的语音输入文本进行校验的，业务方要的就是参差不齐的语料，所以我们还得在前面增加一个流程，控制是否走语音校验。</p><p>另外，众包也可以考虑推出自己的专属产品智能语音助手，在用户做任务的过程中提供全方位的智能服务。比如：用户可以直接通过询问众包助手附近是否有可以做的任务，众包助手就可以根据用户的需求给他们筛选出距离近薪资高的任务并推荐给用户；又比如众包助手可以每天分析天气情况，若查到今天会下雨，提前提示用户备好雨具；在用户做任务的过程中，给出一些关心的贴心话语，比如“亲，您已经连续做任务2个小时了，该休息下啦”、“亲，月底已到，小包提醒您来看看这个月的收入啦”等等，增加产品的亲合力。我们有很多的地方都可以去做得更好。</p><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>现在市面上有很多成熟的智能语音技术解决方案，想要让我们的产品支持智能语音能力门槛不高，这里以阿里云提供的语音服务为例，简单跟大家介绍一下。因为本人是 Android 开发者，所以下面内容以 Android Demo 为例。</p><p>使用阿里云的服务前，你需要先注册阿里云账号并开通智能语音交互 <a href="https://data.aliyun.com/product/nls?spm=5176.doc30437.2.4.V1fz8y" target="_blank" rel="noopener">服务</a>，获取Access Key ID和Access Key Secret两个数加认证参数。详情可参见文档<a href="https://help.aliyun.com/document_detail/30437.html?spm=5176.doc30422.2.4.5ArQSd" target="_blank" rel="noopener">《账号和服务申请》</a>。</p><p>阿里云的语音识别提供了三种服务：一句话识别、实时语音识别和录音文件识别。具体可根据语音的使用场景来选择 <a href="https://data.aliyun.com/product/nls?spm=5176.doc30437.2.4.jCYNfj" target="_blank" rel="noopener">开通</a> 哪个服务。</p><table><thead><tr><th style="text-align:left">服务</th><th style="text-align:left">时效性</th><th style="text-align:left">支持的语音格式</th><th style="text-align:left">支持调用方式</th></tr></thead><tbody><tr><td style="text-align:left">一句话识别 SDK</td><td style="text-align:left">实时识别</td><td style="text-align:left">PCM/WAV/SPEEX/OPUS</td><td style="text-align:left">Java/C++/Android/iOS</td></tr><tr><td style="text-align:left">实时语音识别</td><td style="text-align:left">实时识别</td><td style="text-align:left">PCM/WAV</td><td style="text-align:left">Java/C++/Android/iOS</td></tr><tr><td style="text-align:left">录音文件识别</td><td style="text-align:left">非实时，免费版24小时内（这里区分免费版）</td><td style="text-align:left">支持大部分常见编码格式，WAV/MP3效果最佳</td><td style="text-align:left">HTTP RESTful API</td></tr></tbody></table><ul><li>一句话识别<br>一句话识别 SDK 支持的语言有：汉语普通话，东北、河南、四川等方言，粤语，英语。支持的结果返回模式有”流式”和”普通”两种模式。“流式”模式就是用户一边说话一边返回识别结果，“普通”模式就是用户整句话说完后返回识别结果。</li></ul><p>由于语音识别服务为了提高语音识别准确率，对用户的使用场景抽象成了不同的模型，需要我们通过 app_key 参数来选择具体使用哪个模型。详情见下表。</p><p><img src="https://gw.alipayobjects.com/zos/skylark/8355e878-2d6d-4e7f-b0bf-6489ca0655b1/2018/png/5dfa81f0-0504-4635-9b23-48ec08b415bc.png" alt="image | center"></p><p>集成和 API 的详细使用可见 <a href="https://help.aliyun.com/document_detail/30417.html?spm=5176.doc30420.6.548.3bTbet#h2-u91CDu8981u63A5u53E3u8BF4u660E6" target="_blank" rel="noopener">官方文档</a>。<br>简单 Demo 示例：</p><p><a href="https://lark.alipay.com/attachments/lark/2018/mp4/5f1e9720-17e8-41c8-9d96-57187eac779f.mp4" title="align:center" target="_blank" rel="noopener">embed: 32f3f23c0e1fd7e8ad5f0cb93da64013_3548406206174834041.mp4</a></p><ul><li>实时语音识别<br>实时语音识别，提供了实时录音识别为文字的能力。我们常用于短视频、直播、会议等应用场景。同样，实时语音识别也提供了多种场景模型的选择，如下表。</li></ul><p><img src="https://lark.alipay.com/api/filetransfer?url=https%3A%2F%2Fprivate-alipayobjects.alipay.com%2Falipay-rmsdeploy-image%2Fskylark%2Fpng%2F036b8315-b165-4267-af9f-0c871519279f.png" alt="image | center"></p><p>集成方法、注意事项、API 的使用和完整的示例，可见 <a href="https://help.aliyun.com/document_detail/53288.html?spm=5176.doc30417.6.557.SdQKMn#h2-u91CDu8981u63A5u53E3u8BF4u660E" target="_blank" rel="noopener">官方文档</a>。<br>简单 Demo 示例：</p><p><a href="https://lark.alipay.com/attachments/lark/2018/mp4/4993fc11-347a-4e1c-8ff0-d6cb14f0947e.mp4" title="align:center" target="_blank" rel="noopener">embed: 5552fa62455002a7048d2b0203fd07f2_4124779407680446069.mp4</a></p><ul><li>语音合成服务<br>语音合成服务是在阿里云服务端完成的，客户端将文本内容发送到服务端，服务端合成语音后，以语音数据流的形式返回给客户端 SDK，SDK 再进行播放和存储。阿里云语音合成服务提供了丰富的接口，可以设置不同的发音人、语速、音量等，获取的语音形式也很丰富，包括 PCM、WAV、MP3 等格式。</li></ul><p>同样的，语音合成也需要选择场景模型，它所支持的 app_key 跟前面一句话识别 SDK 的 app_key 一致。若单独使用「语音合成」，官方推荐使用 nls-service。</p><p><img src="https://lark.alipay.com/api/filetransfer?url=https%3A%2F%2Fprivate-alipayobjects.alipay.com%2Falipay-rmsdeploy-image%2Fskylark%2Fpng%2Ffb4c77f6-ca2e-4f19-8220-cf4f21bcdcb2.png" alt="image | center"></p><p>语音合成的 API 和完整示例，可以参见 <a href="https://help.aliyun.com/document_detail/30419.html?spm=5176.doc30422.6.573.5ArQSd#h2-u91CDu8981u63A5u53E3u8BF4u660E6" target="_blank" rel="noopener">官方的文档。</a><br>简单 Demo 示例：</p><p><a href="https://lark.alipay.com/attachments/lark/2018/mp4/71a59925-ae00-4c88-9255-e8077acc214a.mp4" title="align:center" target="_blank" rel="noopener">embed: 9cc33ef06134d9233db2c96cea78c59e_4122492212436376180.mp4</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.zhihu.com/question/20398418" target="_blank" rel="noopener">语音识别的技术原理是什么？</a></li><li><a href="http://www.eepw.com.cn/article/201612/342190.htm" target="_blank" rel="noopener">玩人工智能的你必须知道的语音识别技术原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/27741586" target="_blank" rel="noopener">「翻译」史上最全人工智能产品清单（1/3）</a></li><li><a href="https://zhuanlan.zhihu.com/p/23176664" target="_blank" rel="noopener">“识别一秒钟，线下十年功” —— 语音输入如何一分钟400字</a></li><li><a href="https://help.aliyun.com/product/30413.html?spm=a2c4g.11186623.3.1.lavc1m" target="_blank" rel="noopener">阿里云智能语音交互</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近两年，人工智能发展迅猛，语音识别作为人工智能最成熟的技术之一，现已成为很多智能设备甚至是 App 的标配。各大科技巨头也相继推出了具有代表性的智能语音产品，比如，国外有亚马逊的 &lt;a href=&quot;https://www.amazon.com/Amazon-Echo-Bluetooth-Speaker-with-WiFi-Alexa/dp/B00X4WHP5E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Amazon Echo&lt;/a&gt;、微软的 &lt;a href=&quot;https://www.microsoft.com/en-us/search/result.aspx?q=cortana#nav-downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cortana&lt;/a&gt;、谷歌的 &lt;a href=&quot;https://assistant.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Assistant&lt;/a&gt;、脸书的 &lt;a href=&quot;https://www.theguardian.com/technology/2015/aug/27/facebook-m-virtual-assistant-siri-google-now&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Facebook M&lt;/a&gt; 等，国内有阿里巴巴的 &lt;a href=&quot;https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.676e5549peca3Q&amp;amp;id=557856671085&amp;amp;skuId=3572248181527&amp;amp;user_id=3081047815&amp;amp;cat_id=2&amp;amp;is_b=1&amp;amp;rn=ab5f34354c32a735c187eb22609ca729&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;天猫精灵&lt;/a&gt; 、百度的 &lt;a href=&quot;https://dueros.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;度秘&lt;/a&gt; 以及科大讯飞的 &lt;a href=&quot;http://www.xfyun.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智能语音输入法&lt;/a&gt; 等等。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://G96968586.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>有关 PWA 的几个宝贵实践经验</title>
    <link href="http://G96968586.github.io/2017/11/29/%E6%9C%89%E5%85%B3-PWA-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AE%9D%E8%B4%B5%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    <id>http://G96968586.github.io/2017/11/29/有关-PWA-的几个宝贵实践经验/</id>
    <published>2017-11-29T07:42:37.000Z</published>
    <updated>2018-05-06T15:43:11.916Z</updated>
    
    <content type="html"><![CDATA[<p>日常的技术调研、新技术的尝鲜，我们更多的关注点是在技术本身上。但是，如果涉及到技术的具体落地，关联到线上生产环境，我们要考虑的因素就多了。这里以 PWA 为例，如果我们的产品使用了 PWA 技术，在将其部署到生产环境之前，我们需要做什么准备呢？需要提前考虑到哪些因素呢？下面是总结饿了么 M 站的一些宝贵实践经验，这里拿来跟大家分享。<br><a id="more"></a></p><h2 id="提供降级方案"><a href="#提供降级方案" class="headerlink" title="提供降级方案"></a>提供降级方案</h2><p>Service Worker 直接在浏览器网络层工作，脱离页面生命周期，提供资源预加载和强大的离线缓存能力，因此，如果 Service Worker 内部存在 bug，很大情况下 bug 会被放大，比如：</p><ul><li>由于缓存的原因，bug 也被缓存起来了，不能及时的修复</li><li>如果 Service Worker 的缓存策略存在 bug，用户可能就无法更新页面了，这种情况开发者也不易察觉到</li><li>Service Worker 的错误可能会导致整个页面无法工作，给业务带来灾难性的影响</li></ul><p>而且，国内市面上各种各样的浏览器和系统，对 Service Worker 的能力支持各不相同，功能适配和兼容性问题给我们国内开发者写出 bug-free 代码带来了很大的难度。<br>所以，万一出现重大 bug 了，怎么在最短时间内解决呢？当然是降级啦，所以提供降级方案非常有必要！那 PWA 怎么降级呢？<br><a href="http://chuansong.me/n/1676119852913" target="_blank" rel="noopener">饿了么 M 站</a> 提供了一个简单又粗暴的方法，就是降级开关。一旦发现事情不妙，开启降级就可以了。具体做法是，页面先请求开关接口，若降级，则不安装并且<strong>注销</strong>所有 Service Worker。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (支持SW) &#123;</span><br><span class="line">  fetch(开关接口)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (降级) &#123;</span><br><span class="line">      <span class="comment">// 注销所有已安装的 SW</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 注册 SW</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几点要注意的：</p><ul><li>降级不是简单的不安装，而是要注销掉。原因是降级前可能已经有用户访问过网站，导致 Service Worker 被安装，不注销的话降级开关对这部分用户是不起作用的。</li><li>降级开关不能被缓存，需要具备即时性。服务端和 Service Worker 都不该缓存该接口。</li><li>出现问题并降级后，可能影响问题的排查，因此可以考虑加入对用户隐蔽的 debug 模式（如 url 传入特定字段），debug 模式中忽略降级接口。</li></ul><h2 id="接入错误监控"><a href="#接入错误监控" class="headerlink" title="接入错误监控"></a>接入错误监控</h2><p>由于 Service Worker 运行在 worker 线程里，所以抛出的错误页面是捕捉不到的，因此需要在 Service Worker 里引入错误监控方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'error'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上报错误信息</span></span><br><span class="line">  <span class="comment">// 常用的属性：</span></span><br><span class="line">  <span class="comment">// event.message</span></span><br><span class="line">  <span class="comment">// event.filename</span></span><br><span class="line">  <span class="comment">// event.lineno</span></span><br><span class="line">  <span class="comment">// event.colno</span></span><br><span class="line">  <span class="comment">// event.error.stack</span></span><br><span class="line">&#125;)</span><br><span class="line">self.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上报错误信息</span></span><br><span class="line">  <span class="comment">// 常用的属性：</span></span><br><span class="line">  <span class="comment">// event.reason</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>Service Worker 大部分 API 都是 promise-based 的，promise 里未处理的错误触发的不是 error 事件，而是 unhandledrejection 事件。</li><li>这两个事件都只能在 worker 线程的 initial 生命周期里注册。（否则会失败，控制台可看到警告）</li></ul><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>每一个产品都需要数据统计，目的是为了帮助我们更好的理解用户，为业务增长提供数据支撑。同时，其曲线抖动也可以辅助错误监控为生产环境提供监控保障。当然，数据也可以协助运营提供更加好的产品运营解决方案。</p><h2 id="开发单页面-PWA-应用"><a href="#开发单页面-PWA-应用" class="headerlink" title="开发单页面 PWA 应用"></a>开发单页面 PWA 应用</h2><p>前面的准备工作做完后，就可以开始专心写代码了。单页面架构的应用，你只需要：</p><ul><li>用几个 Service Worker 的库，比如：<a href="https://github.com/goldhand/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a></li><li>找个 manifest.json 抄一下，比如<a href="">饿了么 M 站</a>的 <a href="https://h5.ele.me/manifest.json" target="_blank" rel="noopener">manitest.json</a></li><li>使用 lighthouse 跑一下页面，按照提示改进</li><li>对比谷歌的 PWA <a href="https://developers.google.com/web/progressive-web-apps/checklist" target="_blank" rel="noopener">Checklist </a>，按照提示改进</li><li>国内各大浏览器 Debug 测试：微信、QQ 浏览器、UC 浏览器、百度浏览器、360 浏览器、猎豹浏览器</li><li>在 10 台安卓机上 Debug 以下系统自带的浏览器</li></ul><p>以上基本就 OK 了。</p><h2 id="开发多页面-PWA-应用"><a href="#开发多页面-PWA-应用" class="headerlink" title="开发多页面 PWA 应用"></a>开发多页面 PWA 应用</h2><p>多页应用会面临更多的问题，比如多页面切换成本高，即使对所有资源都进行了缓存，消除了网络延时，但浏览器销毁页面、解析 HTML、执行 JS、渲染新页面等一系列动作的耗时仍然很高，且几乎无法避免。所以多页应用页面渲染流程的优化，尽可能提高首屏渲染速度是首先要做的事情。</p><h2 id="用-App-Shell-提高首屏渲染速度"><a href="#用-App-Shell-提高首屏渲染速度" class="headerlink" title="用 App Shell 提高首屏渲染速度"></a>用 App Shell 提高首屏渲染速度</h2><p>提高首屏渲染速度的一个主流方法是使用 <a href="https://lark.alipay.com/fgt-mobile/be9mcc/epod4g/edit" target="_blank" rel="noopener">App Shell</a>。那怎样优雅地写一个 App Shell 呢？既然要求在 JS 加载之前渲染，那是不是意味着只能动手写 DOM？不是的，Vue 2 引入了服务端 Server Side Rendering，简称 SSR。它能够在 Node.js 里渲染 vue 组件并输出为 HTML 片段。因此我们可以在构建阶段调用 Vue SSR 进行 App Shell 的渲染，这也就是所谓的 prerendering。具体的做法可以参考<a href="https://www.npmjs.com/package/vue-server-renderer" target="_blank" rel="noopener"> vue-server-renderer</a> 和 <a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-hackernews</a>。<br>然而，饿了么 M 站在实践中发现 App Shell 的渲染比预计的要慢：它总是在同步的 JS 解析完成之后才渲染。不过这里有一个简单而行之有效的方法：把耗时的操作推迟到 Event Loop 的任务队列中，等待主调用栈清空后才执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 把初始化渲染放到 setTimeout 里</span></span><br><span class="line">  <span class="keyword">new</span> Vue()</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>虽然只是几行代码的 hack ，但是对 App Shell 的渲染提升是极大的。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/jpeg/257f24ab-aaa8-44af-ae11-5fa9c31e6aca.jpeg" alt="image.jpeg | center | 600x348"><br>可以看到，加入 App Shell 并且优化后，在主流手机设备上，首屏 App Shell 的渲染时间在 500ms 以下，再加上 SW 对 HTML 的缓存，页面的切换体验可以比较贴近单页应用了。</p><h2 id="一些踩坑经验"><a href="#一些踩坑经验" class="headerlink" title="一些踩坑经验"></a>一些踩坑经验</h2><p>下面是饿了么 M 站在 PWA 改造过程中遇到的坑以及相应的解决方案：</p><ul><li>Android WebView 中 UserAgent 不正确，cookies 丢失<blockquote><p>在我们实验性地上线 PWA 后，大数据的同事向我们反馈，他们的统计数据中有有一部分「不正常的 UA」涌入，根据来源分析，这部分 UA 应该是「饿了么 APP」的自定义 UA ，而统计到的数据却为安卓系统默认的 WebView UA。<br>同一时间，我们还在服务监控中，观察到了某些接口的 401 状态异常上涨。而 401 状态意味着用户认证失败，据此我们推断是 SW 导致 cookies 丢失。<br>后来我们及时降级 PWA，并与谷歌合作排查，最终确定了 bug 的来源，且将 bug 提交给了 Chrome 团队： <a href="">698175 - User agent string not set correctly when Service Worker makes a fetch request - chromium - Monorail</a><br>在 WebView 修复之前，你可以通过避免在 SW 里代理需要 UA 和 cookies 的请求（通常是API请求）来避开这个 bug。</p></blockquote></li></ul><ul><li>X5 内核部分请求发送 q-sid 头<blockquote><p>在开启 SW 后，微信和 QQ 浏览器都出现了白屏现象。我们利用调试工具观察到部分资源的请求多了一个 q-sid essay-header，这导致浏览器向 CDN 服务器发送 OPTIONS 请求并且遭到拒绝，所以导致页面无法打开。<br>我们向 X5 内核的团队反馈了这个问题，并且很快得到了技术支持：X5 内核将在新版(4311)中修复这个问题，在此之前，我们可以在服务端设置允许 q-sid 的自定义头部来避开这个问题。</p></blockquote></li></ul><ul><li>UC 浏览器中 301 跳转问题<blockquote><p>同样，我们的页面在 UC 浏览器中也出现了白屏现象，但是 bug 的原因不同：我们发现 SW 抓取的资源中，带 301 跳转的资源请求总是失败的。在向 UC 团队反馈后，我们得到了 bug 的确认，这是内核对 fetch API 的实现基于早期不完善的规范导致的，UC 团队将积极推进内核版本的升级和 bug 的修复。在修复之前，可以采用临时的解决方案：服务端避免 301 跳转，或者 SW 中对存在 301 跳转情况的资源做特殊处理。</p></blockquote></li></ul><ul><li>其他细节：<blockquote><p>低版本 chromium 不支持 cache.addAll，可以考虑引入带有 polyfill 的库；<br>UC 浏览器不支持 cache.add ，请用 cache.put 代替；<br>部分低版本微信浏览器中，UA 是 Chrome 30+ 但存在 navigator.serviceWorker，因此不要依赖 <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">isserviceworkerready</a> 用版本检测代替功能检测；</p></blockquote></li></ul><p>##参考文章<br><a href="http://chuansong.me/n/1676119852913" target="_blank" rel="noopener">PWA 在饿了么的实践经验</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文会不定期更新，欢迎关注！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常的技术调研、新技术的尝鲜，我们更多的关注点是在技术本身上。但是，如果涉及到技术的具体落地，关联到线上生产环境，我们要考虑的因素就多了。这里以 PWA 为例，如果我们的产品使用了 PWA 技术，在将其部署到生产环境之前，我们需要做什么准备呢？需要提前考虑到哪些因素呢？下面是总结饿了么 M 站的一些宝贵实践经验，这里拿来跟大家分享。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA 添加 Web Push 通知</title>
    <link href="http://G96968586.github.io/2017/11/29/PWA-%E6%B7%BB%E5%8A%A0-Web-Push-%E9%80%9A%E7%9F%A5/"/>
    <id>http://G96968586.github.io/2017/11/29/PWA-添加-Web-Push-通知/</id>
    <published>2017-11-29T07:38:03.000Z</published>
    <updated>2018-05-06T15:42:49.967Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何往 PWA 中添加推送通知功能，如果你有兴趣想了解更多关于 Web Push 技术，可以阅读这篇文章<a href="">《PWA系列 - Web Push 技术》</a>，看一篇抵过 n 篇 Google 的文档。<br><a id="more"></a><br>OK，下面我们进入主题。同样，你需要先做一些准备工作，可以参考这篇<a href="">《搭建你的第一个 PWA》</a>文章。然后下载示例代码：<br><a href="">download: push-notifications-master.zip</a></p><h2 id="注册-Service-Worker"><a href="#注册-Service-Worker" class="headerlink" title="注册 Service Worker"></a>注册 Service Worker</h2><p>解压示例代码，在 app 目录下有一个 sw.js 的文件，打开你会发现里面除了一些注释和一行 <code>use strict;</code>外什么都没有，后面我们会不断往里面添加代码的，因为这个文件是我们的服务工作线程。<br>现在，打开 scripts/main.js，这是示例程序的入口，在文件的末尾添加下面代码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Service Worker and Push is supported'</span>);</span><br><span class="line"></span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">swReg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Service Worker is registered'</span>, swReg);</span><br><span class="line"></span><br><span class="line">    swRegistration = swReg;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Service Worker Error'</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'Push messaging is not supported'</span>);</span><br><span class="line">  pushButton.textContent = <span class="string">'Push Not Supported'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一段注册服务工作线程的代码，但你会发现这段代码跟前面文章所介绍的注册服务工作线程有些不太一样，是的，我们这里同时检查了浏览器是否支持推送消息： ‘PushManager’ in window。<br>打开 Web Server for Chrome，选择访问目录为 app，<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/e32187ca-e5c1-4071-b1d1-024b0c17621a.png" alt="屏幕快照 2017-09-17 下午10.23.33.png | center | 644x680"></p><p>在浏览器打开网址 <strong>127.0.0.1:8887 </strong>访问我们的示例应用。如果你前面阅读过 <a href="https://lark.alipay.com/fgt-mobile/be9mcc/dt2egy" target="_blank" rel="noopener">《调试 Service Workers》</a>，并在自己的电脑上做过调试，你也许会访问到这个页面，<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/40be4c5b212b8e6e.png" alt="image | center"></p><p>这是因为前面我们缓存了一些资源文件，你可以打开开发者工具，切换到 Application 视图 Clear storage 选项，点击 Clear site data，清除缓存再次刷新页面，当你访问到下面这个绿色主题的页面，说明你前面操作成功！<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/dc930520-3d40-409a-be0b-c5855057ae78.png" alt="屏幕快照 2017-09-17 下午10.29.06.png | center | 2878x1536"></p><h3 id="获取应用服务器密钥"><a href="#获取应用服务器密钥" class="headerlink" title="获取应用服务器密钥"></a>获取应用服务器密钥</h3><p>使用示例代码，我们还需要生成一些应用服务器密钥，访问示例代码配套网站：<a href="https://web-push-codelab.appspot.com/?hl=zh-cn" target="_blank" rel="noopener">https://web-push-codelab.appspot.com/</a>，我们可以在这里生成一个公私密钥对。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/7a6cf3b7-be1b-4841-b7c8-ef274ad7862a.png" alt="屏幕快照 2017-09-17 下午10.39.05.png | center | 2876x1180"></p><p>点击 refresh keys 按钮，然后将公钥复制到<code>scripts/main.js</code>替换<code>&lt;Your Public Key&gt;</code>值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerPublicKey = <span class="string">'&lt;Your Public Key&gt;'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h2><p>你可以发现，目前我们的示例程序页面上的那个按钮不可点击。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/5d381b34-e1ca-4fc4-a182-4536976f60e3.png" alt="屏幕快照 2017-09-17 下午11.43.42.png | center | 754x300"></p><p>因为默认情况下最好禁用推送按钮。如果检测到当前浏览器环境支持推送功能，并且当前用户订阅了推送消息，我们再启用此按钮。<br>下面我们在 scripts/main.js 里面添加两个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前用户有没有订阅消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialiseUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Set the initial subscription value</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    isSubscribed = !(subscription === <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User IS subscribed.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User is NOT subscribed.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将启用推送按钮，以及更改用户是否订阅的文本，在 initialiseUI 里调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Disable Push Messaging'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Enable Push Messaging'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushButton.disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注册服务工作线程时调用 initialiseUI() 函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">swReg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Service Worker is registered'</span>, swReg);</span><br><span class="line"></span><br><span class="line">  swRegistration = swReg;</span><br><span class="line">  <span class="comment">// 这里调用</span></span><br><span class="line">  initialiseUI();</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>刷新页面，可以看到此时页面上的按钮变成可点击状态了，从 console 控制台上可以看到下面的输出，注意到其中有一句是 <code>User is NOT subscribed</code>，下面我们开始来订阅消息。<br><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/f51f662b-28d4-4b1b-9c92-ae5e76df6a82.png" alt="屏幕快照 2017-09-18 上午10.08.52.png | center | 2880x1600"></p><h2 id="用户订阅"><a href="#用户订阅" class="headerlink" title="用户订阅"></a>用户订阅</h2><p>在 initialiseUI() 函数里添加点击事件监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialiseUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用户点击按钮后，我们先设置按钮处于不可点击状态，防止用户重复订阅消息</span></span><br><span class="line">    pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Unsubscribe user</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      subscribeUser();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the initial subscription value</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    isSubscribed = !(subscription === <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 注意，这里新增了一行代码</span></span><br><span class="line">    updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User IS subscribed.'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'User is NOT subscribed.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 scripts/main.js 里添加 subscribeUser 函数，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);</span><br><span class="line">  swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">    userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">    applicationServerKey: applicationServerKey</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User is subscribed:'</span>, subscription);</span><br><span class="line"></span><br><span class="line">    updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Failed to subscribe the user: '</span>, err);</span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数的作用是，先获取应用服务器的公钥（base64 网址安全编码），然后将其转换为 UInt8Array。转换后，我们调用 swRegistration.pushManager 的 subscribe() 方法，把应用服务器的公钥和 userVisibleOnly: true 传进去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);</span><br><span class="line">swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">  userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">  applicationServerKey: applicationServerKey</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>userVisibleOnly 表示在发送推送时显示我们的消息通知。<br>调用 subscribe() 方法后会返回一个 promise：</p><ol><li>用户已授权显示通知</li><li>浏览器已向推送服务发送网络请求，以便获取详细信息来生成 PushSubscription</li></ol><p>如果这些步骤成功执行，我们可以在 then 回调里对 subscription 进行解析，如果用户未授权，或者出现其他问题，我们需要在 catch 里做错误处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">swRegistration.pushManager.subscribe(&#123;</span><br><span class="line">  userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">  applicationServerKey: applicationServerKey</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'User is subscribed:'</span>, subscription);</span><br><span class="line"></span><br><span class="line">  updateSubscriptionOnServer(subscription);</span><br><span class="line"></span><br><span class="line">  isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  updateBtn();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Failed to subscribe the user: '</span>, err);</span><br><span class="line">  updateBtn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以收到订阅，并将用户标记为已订阅用户。成功或出错我们都调用 updateBtn 函数来修改按钮文案。下面在 scripts/main.js 里添加 updateSubscriptionOnServer 方法，将订阅发送到后端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSubscriptionOnServer</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Send subscription to application server</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscriptionJson = <span class="built_in">document</span>.querySelector(<span class="string">'.js-subscription-json'</span>);</span><br><span class="line">  <span class="keyword">const</span> subscriptionDetails =</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'.js-subscription-details'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subscription) &#123;</span><br><span class="line">    subscriptionJson.textContent = <span class="built_in">JSON</span>.stringify(subscription);</span><br><span class="line">    subscriptionDetails.classList.remove(<span class="string">'is-invisible'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscriptionDetails.classList.add(<span class="string">'is-invisible'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候刷新页面，点击订阅按钮，会看到下面的权限提示，</p><p><img src="https://gw.alicdn.com/tfs/TB1fr7YazuhSKJjSspmXXcQDpXa-2874-1720.png" alt="image | center"></p><p>点击允许，可以看到 console 控制台输出了 User is subscribe，同时页面底部出现了订阅信息。</p><p><img src="https://gw.alicdn.com/tfs/TB1qj89eMMPMeJjy1XdXXasrXXa-2872-1652.png" alt="image | center"></p><h2 id="处理拒绝的权限"><a href="#处理拒绝的权限" class="headerlink" title="处理拒绝的权限"></a>处理拒绝的权限</h2><p>我们还需要处理当用户点击拒绝的情况。因为如果用户拒绝了我们的推送，我们的页面是无法重新显示权限提示的，所以，这里的做法是禁止推送按钮。</p><p>在 updateBtn() 里检查 Notification.permission 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果权限为 denied，就无法订阅用户，并且我们无法执行其他操作，因此，停用此按钮是最好的做法</span></span><br><span class="line">  <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span>) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Push Messaging Blocked.'</span>;</span><br><span class="line">    pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">    updateSubscriptionOnServer(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Disable Push Messaging'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pushButton.textContent = <span class="string">'Enable Push Messaging'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushButton.disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到浏览器，刷新页面，点击网址栏的圆圈中的 <strong>i</strong>，将通知权限更改为 <em>Use global default (Ask)</em> 。</p><p><img src="https://gw.alicdn.com/tfs/TB1_dQ1aqagSKJjy0FbXXa.mVXa-2876-1320.png" alt="image | center"></p><p>重新加载页面，点击订阅按钮，选择禁止，发现按钮的文案现在改为 Push Messaging Blocked，并且处于不可点击状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Y7mgX2NNTKJjSspfXXbXIFXa-2880-1488.png" alt="image | center"></p><h2 id="处理推送事件"><a href="#处理推送事件" class="headerlink" title="处理推送事件"></a>处理推送事件</h2><p>在 sw.js 文件添加下面的推送事件监听器，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Push Received.'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[Service Worker] Push had this data: "<span class="subst">$&#123;event.data.text()&#125;</span>"`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> title = <span class="string">'Push Codelab'</span>;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    body: <span class="string">'Yay it works.'</span>,</span><br><span class="line">    icon: <span class="string">'images/icon.png'</span>,</span><br><span class="line">    badge: <span class="string">'images/badge.png'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  event.waitUntil(self.registration.showNotification(title, options));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在我们触发推送消息后，浏览器会收到推送消息，再唤醒相应的服务线程并分配推送事件。我们需要监听此事件，并将通知显示出来。</p><p>收到推送消息后，会触发推送事件监听，我们通过在注册时调用 showNotification() 来创建通知并将其显示出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="string">'Push Codelab'</span>;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  body: <span class="string">'Yay it works.'</span>, <span class="comment">// 消息正文</span></span><br><span class="line">  icon: <span class="string">'images/icon.png'</span>, <span class="comment">// 图标</span></span><br><span class="line">  badge: <span class="string">'images/badge.png'</span> <span class="comment">// 标志</span></span><br><span class="line">&#125;;</span><br><span class="line">self.registration.showNotification(title, options);</span><br></pre></td></tr></table></figure><p>现在我们来测试一下，刷新浏览器，并将通知权限更改为 Use global default (Ask)，选择允许，然后在 Application 视图 Service Workers 选项下点击右边的 Push 按钮，发送模拟通知。</p><p><img src="https://gw.alicdn.com/tfs/TB1K8Z7aqagSKJjy0FhXXcrbFXa-2880-1488.png" alt="image | center"></p><p>会收到类似如下的通知：</p><p><img src="https://gw.alicdn.com/tfs/TB1HImKeMoQMeJjy0FpXXcTxpXa-716-148.png" alt="image | center"></p><h2 id="通知点击处理"><a href="#通知点击处理" class="headerlink" title="通知点击处理"></a>通知点击处理</h2><p>我们都希望用户收到通知后，去点击它，并作出一些行为，比如，打开一个链接。现在我们来加上这个处理逻辑。</p><p>在 sw.js 添加 notificationclick 事件的监听，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'notificationclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Notification click Received.'</span>);</span><br><span class="line"></span><br><span class="line">  event.notification.close();</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    clients.openWindow(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当用户点击通知时，会调用 notificationclick 事件监听器，打开淘宝首页。</p><h2 id="发送推送消息"><a href="#发送推送消息" class="headerlink" title="发送推送消息"></a>发送推送消息</h2><p>下面我们来发送实际的推送消息了。回到配套网站 <a href="https://web-push-codelab.appspot.com/?hl=zh-cn%EF%BC%8C%E5%88%B7%E6%96%B0%E5%AF%86%E9%92%A5" target="_blank" rel="noopener">https://web-push-codelab.appspot.com/?hl=zh-cn，刷新密钥</a>(因为前面的 key 可能会失效，导致发送消息不成功)，更新 scripts/main.js  的 applicationServerPublicKey，然后回到示例页面，在 Application 视图里切到 Clear storage 选项，点击下边的 Clear site data，刷新页面重新订阅消息。</p><p>复制下面这段 Json 字符串，</p><p><img src="https://gw.alicdn.com/tfs/TB1NWOTeMMPMeJjy1XcXXXpppXa-2880-1658.png" alt="image | center"></p><p>然后粘贴到配套网站的 <em>Subscription to Send To</em> 文本区域：</p><p><img src="https://gw.alicdn.com/tfs/TB1LnGTeMMPMeJjy1XcXXXpppXa-2880-1498.png" alt="image | center"></p><p>点击 send push message 按钮，回到我们的示例页面，在控制台可以看到有一句 Push had this data: “This is a test!” 说明我们已经收到了推送消息。</p><p>上面的配套网站其实就是使用 <a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">web-push 库</a> 发送消息的节点服务器。我们可以查看 <a href="https://github.com/web-push-libs/" target="_blank" rel="noopener">Github 上的 web-push-libs org</a>，看看有哪些库可以发送推送消息。</p><h2 id="取消订阅用户"><a href="#取消订阅用户" class="headerlink" title="取消订阅用户"></a>取消订阅用户</h2><p>下面介绍如何取消用户的推送消息订阅。我们需要对 PushSubscription 调用 unsubscribe()。</p><p>在 scripts/main.js 里将 initialiseUI() 中 pushButton 的点击事件修改为下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pushButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushButton.disabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isSubscribed) &#123;</span><br><span class="line">    unsubscribeUser();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    subscribeUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>unsubscribeUser 方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsubscribeUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，我们通过调用 getSubscription() 获取当前的订阅</span></span><br><span class="line">  swRegistration.pushManager.getSubscription()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 subscription 存在，调用其 unsubscribe 方法</span></span><br><span class="line">    <span class="keyword">if</span> (subscription) &#123;</span><br><span class="line">      <span class="keyword">return</span> subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error unsubscribing'</span>, error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSubscriptionOnServer(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'User is unsubscribed.'</span>);</span><br><span class="line">    isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    updateBtn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在来试一试，刷新页面，点击 <em>Disable Push Messaging</em>，可以看到控制台输出了：</p><p><img src="https://gw.alicdn.com/tfs/TB1bLmBeMMPMeJjy1XdXXasrXXa-1878-294.png" alt="image | center"></p><p>OK，教程到这里就结束了，如果你想继续深入了解，可以点击下面这两个链接</p><ul><li>Web Fundamentals 上的 <a href="https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/?hl=zh-cn" target="_blank" rel="noopener">网络推送通知</a> 文档</li><li><a href="https://github.com/web-push-libs/" target="_blank" rel="noopener">网络推送库</a> - 网络推送库包括 Node.js、PHP、Java 和 Python。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何往 PWA 中添加推送通知功能，如果你有兴趣想了解更多关于 Web Push 技术，可以阅读这篇文章&lt;a href=&quot;&quot;&gt;《PWA系列 - Web Push 技术》&lt;/a&gt;，看一篇抵过 n 篇 Google 的文档。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>App Shell 模型介绍</title>
    <link href="http://G96968586.github.io/2017/11/29/App-Shell-%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/11/29/App-Shell-模型介绍/</id>
    <published>2017-11-29T07:35:43.000Z</published>
    <updated>2018-05-06T15:42:14.938Z</updated>
    
    <content type="html"><![CDATA[<p>App Shell 是构建 PWA 的一种常用的技术方法，同时，App Shell 也是提高页面首次渲染速度的主流方法之一。通过 App Shell 我们的应用（Web App）能够做到像 Native App 一样可靠、即时地加载到用户设备屏幕上，极大的提高了用户体验。<br><a id="more"></a><br>其实 App Shell 就是一个能够被缓存的、轻量级的界面框架，它往往是纯 HTML 片段，只包括内联 CSS 和 base64 图片，不依赖于 JS 框架，可以在加载、解析、执行 JS 之前就渲染出来，几乎消除了白屏时间，大大提高用户体验。<br>结合服务工作线程 Service Worker 的 Cache API 缓存技术，App Shell 在没有网络或弱网络的情况下能表现的非常出色。它能够将一些初始 HTML 片段快速加载到屏幕上，并从缓存获取数据渲染到页面上，整个过程不需等待，带来了类似 Native App 的流畅过渡体验。<br><img src="https://gw.alicdn.com/tfs/TB1CG2IdgMPMeJjy1XdXXasrXXa-743-550.png" alt="image | center"></p><h2 id="构建自己的-App-Shell"><a href="#构建自己的-App-Shell" class="headerlink" title="构建自己的 App Shell"></a>构建自己的 App Shell</h2><p>前面说过 App Shell 是一个轻量级界面框架，它将应用核心基础架构和 UI 同数据分离出来。因此，在构建我们的 App Shell 之前，需要明确区分页面 Shell 和动态数据。<br>理想的 App Shell 具备下面的特点：</p><ul><li>快速加载</li><li>尽可能使用较少的数据</li><li>使用本地静态缓存资源</li><li>将内容与页面导航分离开</li><li>检索和显示特定页面的内容（HTML、JSON 等）</li><li>缓存动态资源（可选）</li></ul><p>这里有一个使用 App Shell 模型的 PWA 例子可以作为参考，Jake Archibald 的<a href="https://wiki-offline.jakearchibald.com/wiki/Rick_and_Morty" target="_blank" rel="noopener">离线维基百科应用</a>。它能在用户重复访问时即时加载到屏幕上，同时使用 JS 动态获取数据，并在稍后离线缓存数据内容，供后面访问使用。下面是截图示例。<br><img src="https://gw.alicdn.com/tfs/TB1Q5g7dgMPMeJjy1XdXXasrXXa-1796-1280.jpg" alt="image | center"></p><h3 id="App-Shell-的-HTML-示例"><a href="#App-Shell-的-HTML-示例" class="headerlink" title="App Shell 的 HTML 示例"></a>App Shell 的 HTML 示例</h3><p>这里我们让示例应用初始加载时尽可能的简单，在访问示例应用时仅显示页面布局，至于数据，有些来自index 文件(内联 DOM、样式)，有些来自外部脚本、样式表。<br>所有页面 UI 和基础架构都通过服务工作线程缓存在本地，这样，后面再次访问我们的应用时，将仅检索新数据或发生改变的数据，而不需要去加载所有的数据。<br>下面是示例代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles/inline.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"header__title"</span>&gt;</span>App Shell<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog-container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loader"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Show a spinner or placeholders for content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  if ('serviceWorker' in navigator) &#123;</span></span><br><span class="line"><span class="undefined">    navigator.serviceWorker.register('/sw.js').then(function(registration) &#123;</span></span><br><span class="line"><span class="undefined">      // Registration was successful</span></span><br><span class="line"><span class="undefined">      console.log('ServiceWorker registration successful with scope: ', registration.scope);</span></span><br><span class="line"><span class="undefined">    &#125;).catch(function(err) &#123;</span></span><br><span class="line"><span class="undefined">      // registration failed :(</span></span><br><span class="line"><span class="undefined">      console.log('ServiceWorker registration failed: ', err);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其实就是一个普通的 HTML 页面，由于篇幅，这里把一些代码省略掉了。纵观整个页面，包括了下面三个部分：</p><ul><li>页面主干：由 HTML 和 CSS 构成的页面导航以及一些内容展示块</li><li>用于处理导航和 UI 逻辑的外部 JavaScript 文件 app.js</li><li>网络应用清单 manifest.json 和用于启用离线功能的服务工作线程加载程序 sw.js</li></ul><p>说到这，App Shell 也没有什么神秘的地方，简单理解就是 HTML 页面 + 逻辑处理文件 app.js + 服务工作线程 service-worker.js 。App Shell 也可以通过使用任意内容库或框架去编写。</p><h3 id="缓存-App-Shell"><a href="#缓存-App-Shell" class="headerlink" title="缓存 App Shell"></a>缓存 App Shell</h3><p>缓存 App Shell 实际上是通过服务工作线程来实现的。<a href="">《Service Workers 介绍》</a> 以及<a href="">《调试 Service Workers》</a> 都介绍过，这里就不多说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App Shell 是构建 PWA 的一种常用的技术方法，同时，App Shell 也是提高页面首次渲染速度的主流方法之一。通过 App Shell 我们的应用（Web App）能够做到像 Native App 一样可靠、即时地加载到用户设备屏幕上，极大的提高了用户体验。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>调试 Service Workers</title>
    <link href="http://G96968586.github.io/2017/11/29/%E8%B0%83%E8%AF%95-Service-Workers/"/>
    <id>http://G96968586.github.io/2017/11/29/调试-Service-Workers/</id>
    <published>2017-11-29T07:35:21.000Z</published>
    <updated>2018-05-06T15:43:19.099Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们来一起探讨如何使用 Chrome DevTools 中新增的 Application 面板调试和检查 Service Workers（服务工作线程）。<br><a id="more"></a><br>首先，你需要做一些准备工作，可以参考这篇<a href="https://lark.alipay.com/fgt-mobile/be9mcc/oeeik3" target="_blank" rel="noopener">《搭建你的第一个 PWA》</a>文章。为了便于调试，这里我们去 Google 实验室下载测试 Demo: <a href="https://github.com/googlecodelabs/debugging-service-workers/archive/master.zip" target="_blank" rel="noopener">debugging-service-worker</a>。<br>解压 Demo，打开 Web Server，点击 Choose Folder 将当前文件路径定位到 Demo 目录下的 work 目录。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/6b911bfcf3bcf47b.png" alt="img"></p><p>我们然后关掉 Web Server，重新再打开，在 Chrome 地址栏输入 <a href="http://127.0.0.1:8887/" target="_blank" rel="noopener">http://127.0.0.1:8887</a> （当然，前提你没有更新 Web Server 默认的端口），你可以见到下图的页面。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/40be4c5b212b8e6e.png" alt="img"></p><p>好了，进入我们的主题：Debuging Service Workers。</p><h2 id="Inspect-Manifest"><a href="#Inspect-Manifest" class="headerlink" title="Inspect Manifest"></a>Inspect Manifest</h2><p>构建 PWA 需要结合多种不同的核心技术，包括 Service Workers、Network Manifest 以及有用的技术支持，比如由：Cache Storage API、IndexedDB、Push Notifications 。Chrome DevTools 给我们提供了 Application 调试窗口，并为每种技术提供了检查器，使我们能够轻松获得各种技术的协调视图。<br>回到前面的页面，打开 DevTools ，然后选中 Application。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/15fdfa68d4a7b572.png" alt="img"></p><p>可以看到右边视图显示的是与 manifest.json 文件有关的重要信息，包括应用名称、启动网址、图标、图标大小等。你还可以发现这里有一个 <strong>Add to homescreen</strong> 按钮，它可用于模拟添加应用到用户主屏幕的效果。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/cbb979db1fdbbeb2.png" alt="img"></p><h2 id="Inspect-Service-Workers"><a href="#Inspect-Service-Workers" class="headerlink" title="Inspect Service Workers"></a>Inspect Service Workers</h2><p>检查服务工作线程，首先选中 Manifest 下方的 Service Workers 菜单项，切换到 Service Workers 视图，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/8b1f630f29fa4b88.png" alt="img"></p><p>最顶部有四个复选框，Offline、Update on reload、Bypass for network 和 Show all。</p><ul><li><strong>Offline</strong>：模拟断开网络连接。有助于快速验证服务工作线程的 fetch 事件是否正常运行。</li><li><strong>Update on reload</strong>：将用新的服务工作线程强制替换当前服务工作线程（如果开发者已更新<code>service-worker.js</code>）。通常情况下，浏览器不会强制替换，将进入等待状态，直到用户关闭包含当前网站的所有标签。</li><li><strong>Bypass for network</strong>：将强制浏览器忽略所有活动服务工作线程并从网络中获取资源。这有助于我们使用 CSS 或 JavaScript 而不需担心服务工作线程意外缓存或返回旧文件。</li><li><strong>Show all</strong>- 在不考虑来源的情况下，显示所有活动服务工作线程。</li></ul><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/6e1b168b208b2f6b.png" alt="img"></p><p> Status 字段显示当前服务工作线程的状态，绿色表示一切正常。绿色圆圈后面的数字是当前活动服务工作线程的 ID。橙色圆圈则代表有新的服务工作线程进入等待状态。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fa8a52334757c2a4.png" alt="img"></p><p>现在打开 work 目录下的 service-worker.js 文件，添加几行代码进去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Service Worker installing.&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Service Worker activating.&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>切换回 DevTools 窗口，刷新页面，可以看到控制台有日志输出，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/8ca61141042f9492.png" alt="img"></p><p> 再回到 service-worker.js 文件，我们修改一下打印的信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123; </span><br><span class="line">    console.log(&apos;A new Service Worker is installing.&apos;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123; </span><br><span class="line">    console.log(&apos;Finally active. Ready to start serving content!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刷新页面看控制台输出信息，发现只输出了一句 “A new Service Worker is installing.”。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/707c8831d42cac1d.png" alt="img"></p><p> 我们发现右边视图出现两个状态指示灯，前面提过橙色说明有新的服务工作线程进入等待状态，点击 skipWaiting 按钮强制激活新的服务工作线程。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fa7fbe42997f12db.png" alt="img"></p><p>这时候控制台输出了来自 activate 事件的处理消息 “Finally active. Ready to start serving content!”。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/677c034de2a9387a.png" alt="img"></p><p> 我们也可以不必每次都点击 skipWaiting 按钮，只需要你勾选上 Update on reload，每次刷新页面浏览器都会强制最新的服务工作线程。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/49c682842694be19.png" alt="img"></p><h2 id="Browser-Cache"><a href="#Browser-Cache" class="headerlink" title="Browser Cache"></a>Browser Cache</h2><p>服务工作线程具备强大的离线缓存文件能力。<strong>Application</strong> 视图有很多有用的工具，用于浏览和修改存储的资源，这些工具在开发期间对我们非常有用。<br>为服务工作线程添加缓存，需要添加一些代码来存储一些文件。在服务工作线程的 install 阶段，预缓存文件是一种有用的技术，可以确保在用户即将离线时关键资源可用。<br>回到 service-worker.js 文件，更新代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var CACHE_NAME = &apos;my-site-cache-v1&apos;;</span><br><span class="line">var urlsToCache = [</span><br><span class="line">  &apos;/&apos;,</span><br><span class="line">  &apos;/styles/main.css&apos;,</span><br><span class="line">  &apos;/scripts/main.js&apos;,</span><br><span class="line">  &apos;/images/smiley.svg&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  // Perform install steps</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(function(cache) &#123;</span><br><span class="line">        return cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;Finally active. Ready to start serving content!&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刷新页面，在 Application 视图左边栏选中 Cache Storage 菜单项，</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/c161899c1a25be78.png" alt="img"></p><p>点击 my-site-cache-v1，可以看到由服务工作线程缓存的所有文件。如果你需要从缓存中移除文件，可以右键点击该文件，然后从上下文菜单中选择 <strong>delete </strong>选项。同样，你也可以通过右键点击 my-site-cache-v1，然后选择 delete 删除整个缓存。<br>也许你已经注意到了，除 <strong>Cache Storage</strong>，还有一些与存储资源有关的其他菜单项：Local Storage、Session Storage、IndexedDB、Web SQL、Cookie 以及 Application Cache (“AppCache”)。在一个面板中精细控制每个资源是非常有用的！但是如果你想删除所有的存储资源，依次访问每个菜单项并删除其内容是相当繁琐的。更好的做法是，你可以使用 <strong>Clear storage</strong> 选项来一次性清理缓存（请注意这也将注销所有的服务工作线程）。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/ec0d649fc0854861.png" alt="img"></p><p>什么是齿轮⚙️？<br>切换到 Network 视图，刷新页面，可以看到下面图示的结果，带有齿轮图标的是第二轮请求，这些请求似乎要获取相同的资源。那齿轮代表的是什么呢？</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/198bc2a7b8f1e974.png" alt="img"></p><p> 齿轮图标表示这些请求来自服务工作线程本身。具体而言，这些是由服务工作线程的<code>install</code>处理程序提出以填充离线缓存的请求。</p><h2 id="模拟不同网络条件"><a href="#模拟不同网络条件" class="headerlink" title="模拟不同网络条件"></a>模拟不同网络条件</h2><h3 id="离线时提供请求服务"><a href="#离线时提供请求服务" class="headerlink" title="离线时提供请求服务"></a>离线时提供请求服务</h3><p>服务工作线程的杀手锏功能之一是即使在用户离线时，它们也能够为其提供缓存内容。要验证这一切是否正常运行，我们可以通过 Chrome 提供的一些网络节流工具来进行测试。<br>首先，在 service-worker.js 文件里添加下面代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        // Cache hit - return response</span><br><span class="line">        if (response) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        return fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接着切换到 Application 视图，确保 Update on reload 处于勾选状态，刷新页面，重新安装新的服务工作线程，然后取消 Update on reload，勾选上 Offline 复选框。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/edaebdd8-bd67-4b31-9c9f-bf7562989b28.png" alt="img"></p><p>你可以发现 Network 前面有一个黄色警告标志，表示当前已离线。这时候刷新页面，一切顺利的话，你应该还能看到整个网站内容。切换到 Network 视图，验证 Cache Storage 是否提供所有资源。这里的 Size 表示这些资源来自 <code>(from Service Worker)</code>。表明我们的服务工作线程拦截了请求，并提供了来自缓存的响应而不是来自网络。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/c5d6c262-a2d8-4507-b08f-32d187049603.png" alt="img"></p><h3 id="测试不同网络"><a href="#测试不同网络" class="headerlink" title="测试不同网络"></a>测试不同网络</h3><p>目前很多地方 3G 和 2G 网络仍是常态。所以我们应该测试在这些弱网络的情况下，我们的应用是否还能保持高性能正常运行。</p><p>Chrome 提供了工具方便我们测试不同的网络情况。在 Application 视图下，取消 Offline，勾选上 Bypass for network。Bypass for network 将告诉浏览器，当需要发出网络请求时跳过我们的服务工作线程。这就意味着 Cache Storage 将不提供任何内容，就好像我们没有安装任何服务工作线程一样。</p><p>接下来，切换到 Network 视图，使用 Network Throttle 下拉菜单将网络速度设置为 Slow 3G。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/f9c71344-48a6-473d-9fa5-ba6136ef1774.png" alt="img"></p><p>刷新页面，现在每个资源的下载需要 2 秒左右的时间。</p><p> <img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/da7400ae-abe5-4adf-84fa-36bb379464aa.png" alt="img"></p><p>现在，取消 Bypass for network，刷新页面，看看服务工作线程在后台运行时有何不同。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/fe9a1af5-00b4-4c90-9a3c-e70e2ff64892.png" alt="img"></p><p>很明显，响应时间急速下降至每个资源仅需几毫秒。对于网络速度较慢的用户来说，这是天壤之别！</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>服务工作线程实际上就是常规的 JavaScript 文件，我们可以使用现有的工具（如 debugger 语句和断点）来调试。</p><p> 现在我们来调试 install 处理程序。</p><p>在 service-worker.js 中 install 处理程序的开头添加一个 debugger 语句。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">  debugger;</span><br><span class="line">  // Perform install steps</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(function(cache) &#123;</span><br><span class="line">        return cache.addAll(urlsToCache);</span><br><span class="line">      &#125;)</span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>切换到 Application 视图，刷新页面，点击 skipWaiting 激活新的服务工作线程。再次刷新页面触发 fetch 处理程序运行。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/0bf1ac58-5c29-4d7d-ab9e-398035751095.png" alt="img"></p><p>页面自动跳转到 Sources 视图，并在 debugger 行处于暂停状态。右下方的 Scope 检查器，可以看到当前函数作用域内对象的当前状态。</p><p>点击 event:InstallEvent 下拉菜单，可以了解有关当前作用域内对象的各种有用的信息。例如，查看 type 字段，可以验证当前事件对象是否为 install 事件。</p><p><img src="https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/2f188875-8250-49fd-bd50-0b88f7b5f31a.png" alt="img"></p><p>当然，我们也可以使用断点来调试，这样会更加方便。</p><h2 id="测试推送通知"><a href="#测试推送通知" class="headerlink" title="测试推送通知"></a>测试推送通知</h2><p>也许你已经发现了页面中心有一个 <strong>Subscribe for Push Notifications</strong> 按钮，它要求用户订阅推送通知。此按钮已被远程配置，以在用户点击时请求推送通知权限。 </p><p>现在添加推送支持，打开 service-worker.js ，然后在 fetch 处理程序后添加以下几行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;push&apos;, function(event) &#123;  </span><br><span class="line">  var title = &apos;Yay a message.&apos;;  </span><br><span class="line">  var body = &apos;We have received a push message.&apos;;  </span><br><span class="line">  var icon = &apos;/images/smiley.svg&apos;;  </span><br><span class="line">  var tag = &apos;simple-push-example-tag&apos;;</span><br><span class="line">  event.waitUntil(  </span><br><span class="line">    self.registration.showNotification(title, &#123;  </span><br><span class="line">      body: body,  </span><br><span class="line">      icon: icon,  </span><br><span class="line">      tag: tag  </span><br><span class="line">    &#125;)  </span><br><span class="line">  );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>处理程序就绪后，就可以很轻松地模拟推送事件。切换到 Application 视图，刷新页面，点击 skipWaiting 按钮，安装最新服务工作线程，点击 Subscribe for Push Notifications 按钮，接收权限提示。</p><p><img src="https://developers.google.com/web/fundamentals/getting-started/codelabs/debugging-service-workers/img/a8a8fa8d35b0667a.png?hl=zh-cn" alt="img"></p><p>最后，点击 <strong>Update</strong> 和 <strong>Unregister</strong> 旁边的 <strong>Push</strong> 按钮，现在应该会看到在屏幕的右上角，出现一个确认服务工作线程是否按预期处理 <code>push</code> 事件的推送通知。</p><p><img src="https://developers.google.com/web/fundamentals/getting-started/codelabs/debugging-service-workers/img/eacd4c5859f5f3ff.png?hl=zh-cn" alt="img"></p><p>OK，本文就到这，后面带来《向网络应用添加推送通知》、Cache API 和构建 App Shell 有关的分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我们来一起探讨如何使用 Chrome DevTools 中新增的 Application 面板调试和检查 Service Workers（服务工作线程）。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA Cache API 介绍</title>
    <link href="http://G96968586.github.io/2017/11/15/PWA-Cache-API-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/11/15/PWA-Cache-API-介绍/</id>
    <published>2017-11-15T09:28:14.000Z</published>
    <updated>2018-05-06T15:42:19.681Z</updated>
    
    <content type="html"><![CDATA[<p>本文重点介绍 Cache 相关技术，不对 Cache 的背景做过多的介绍。希望通过该文能够让读者对 Cache 技术有更进一步的了解。<br>CacheStorage 同 App Cache、IndexedDB、LocalStorage 等一样，也是一种数据存储机制，但它能够提供精细的存储控制能力，常与 Fetch API 结合，让页端具备了完全操控请求，响应，缓存的能力，这正是页端一直非常缺乏的能力。在 PWA 中结合 Service Workers ，能够给应用带来更好的离线体验。<br><a id="more"></a></p><h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><p>CacheStorage 管理一系列 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">Cache</a> 对象，它提供了多个 JS 方法用于操作 Cache 对象。Cache 跟 Worker 一样，也是暴露在 window 作用域下。下面我们开始介绍 CacheStorage、Cache 的 API 使用。</p><h3 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a>CacheStorage</h3><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener">CacheStorage.open()</a> 用于获取一个 Cache 对象实例，结果通过一个 Promise 返回。  </p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "caches" is a global read-only variable, which is an instance of CacheStorage</span></span><br><span class="line">caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with your cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response;</span><br><span class="line"><span class="comment">// 先从缓存中取</span></span><br><span class="line"><span class="keyword">var</span> cachedResponse = caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取不到缓存再去发起网络请求</span></span><br><span class="line">  <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  response = r;</span><br><span class="line">  <span class="comment">// 成功之后再把数据缓存起来</span></span><br><span class="line">  caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    cache.put(event.request, response);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> response.clone();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match" target="_blank" rel="noopener">CacheStorage.match()</a> 用于检查 CacheStorage 中是否存在以 Request 为 Key 的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.match(request, options).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with the response</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response || fetch(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, r);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> r.clone();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/keys" target="_blank" rel="noopener">CacheStorage.keys()</a> 用于返回 CacheStorage 中所有 Cache 对象的 Key 列表，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something with your keyList</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/has" target="_blank" rel="noopener">CacheStorage.has()</a> 用于检查是否存在指定名称的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.has(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// true: your cache exists!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caches.has(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">hasCache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasCache) &#123;</span><br><span class="line">    someCacheSetupfunction();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(myAssets);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Handle exception here.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/delete" target="_blank" rel="noopener">CacheStorage.delete()</a> 用于删除指定名称的 Cache 对象，结果通过一个 Promise 返回。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.delete(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your cache is now deleted</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache 提供了已缓存的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Request</a> / <a href="https://fetch.spec.whatwg.org/#response" target="_blank" rel="noopener">Response</a> 对象体的存储管理机制。CacheStorage.open() 开发者可以使用它来获取 Cache 对象实例，使用该实例的方法去管理已缓存的 Request / Response 对象体。</p><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/put" target="_blank" rel="noopener">Cache.put()</a> 用于把 Request / Response 对象体放进指定的 Cache。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.put(request, response).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request/response pair has been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Bad response status'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.put(url, response);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> response;</span><br><span class="line"><span class="keyword">var</span> cachedResponse = caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  response = r;</span><br><span class="line">  caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    cache.put(event.request, response);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="keyword">return</span> response.clone();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> caches.match(<span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/add" target="_blank" rel="noopener">Cache.add()</a> 用于获取一个 Request 的 Response，并将 Request / Response 对象体放进指定的Cache。等价于 fetch(request) + cache.put(request, response)。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cache.add(request).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// request has been added to the cache</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于下面</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad response status'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.put(url, response);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.add(<span class="string">'/sw-test/index.html'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" target="_blank" rel="noopener">Cache.addAll()</a> 用于获取一组 Request 的 Response，并将该组 Request / Response 对象体放进指定的Cache。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.addAll(requests[]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// requests have been added to the cache</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>  Examples：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'/sw-test/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/index.html'</span>,</span><br><span class="line">        <span class="string">'/sw-test/style.css'</span>,</span><br><span class="line">        <span class="string">'/sw-test/app.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/image-list.js'</span>,</span><br><span class="line">        <span class="string">'/sw-test/star-wars-logo.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/bountyHunters.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/myLittleVader.jpg'</span>,</span><br><span class="line">        <span class="string">'/sw-test/gallery/snowTroopers.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/match" target="_blank" rel="noopener">Cache.match()</a> 用于查找是否存在以 Request 为 Key 的 Cache 对象。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.match(request, &#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with the response</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We only want to call event.respondWith() if this is a GET request for an HTML document.</span></span><br><span class="line">  <span class="keyword">if</span> (event.request.method === <span class="string">'GET'</span> &amp;&amp;</span><br><span class="line">      event.request.headers.get(<span class="string">'accept'</span>).indexOf(<span class="string">'text/html'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling fetch event for'</span>, event.request.url);</span><br><span class="line">    event.respondWith(</span><br><span class="line">      fetch(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'Fetch failed; returning offline page instead.'</span>, e);</span><br><span class="line">        <span class="keyword">return</span> caches.open(OFFLINE_CACHE).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cache.match(OFFLINE_URL);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/matchAll" target="_blank" rel="noopener">Cache.matchAll()</a> 用于查找是否存在一组以 Request 为Key的 Cache 对象组。</p><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.matchAll(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something with the response array</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.matchAll(<span class="string">'/images/'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">      cache.delete(element);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank" rel="noopener">Cache.delete()</a> 用于删除以 Request 为 Key 的 Cache Entry。注意，Cache 不会过期，只能显式<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank" rel="noopener">删除</a> 。<br>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.delete(request,&#123;options&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">true</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//your cache entry has been deleted</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">  cache.delete(<span class="string">'/images/image.png'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    someUIUpdateFunction();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">MDN Cache API</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">MDN CacheStorage API</a><br><a href="https://www.atatech.org/articles/74883" target="_blank" rel="noopener">PWA系列 - Cache 技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文重点介绍 Cache 相关技术，不对 Cache 的背景做过多的介绍。希望通过该文能够让读者对 Cache 技术有更进一步的了解。&lt;br&gt;CacheStorage 同 App Cache、IndexedDB、LocalStorage 等一样，也是一种数据存储机制，但它能够提供精细的存储控制能力，常与 Fetch API 结合，让页端具备了完全操控请求，响应，缓存的能力，这正是页端一直非常缺乏的能力。在 PWA 中结合 Service Workers ，能够给应用带来更好的离线体验。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Service Workers 介绍</title>
    <link href="http://G96968586.github.io/2017/10/25/Service-Workers-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://G96968586.github.io/2017/10/25/Service-Workers-介绍/</id>
    <published>2017-10-25T09:08:27.000Z</published>
    <updated>2018-05-06T15:43:00.249Z</updated>
    
    <content type="html"><![CDATA[<p>PWA 具备丰富的离线体验、定期的后台同步以及原生应用的推送通知功能，离不开 Service Workers 在背后提供的技术基础。<br><a id="more"></a></p><h2 id="什么是-Service-Workers"><a href="#什么是-Service-Workers" class="headerlink" title="什么是 Service Workers"></a>什么是 Service Workers</h2><p>Service Workers，即服务工作线程，是浏览器在后台独立于网页运行的脚本，它不受页面窗口生命周期的限制。因为 Service Workers 是一种事件驱动型的 worker，生命周期与页面无关. 关联页面未关闭时, 它也可以退出, 没有关联页面时, 它也可以启动。</p><h2 id="Service-Workers-生命周期"><a href="#Service-Workers-生命周期" class="headerlink" title="Service Workers 生命周期"></a>Service Workers 生命周期</h2><p>Service Workers 初始化安装时的简化生命周期图：<br><img src="https://gw.alicdn.com/tfs/TB12CznbwMPMeJjy1XdXXasrXXa-702-685.png" alt="image | center"></p><p>Service Workers 生命周期的目的：</p><ul><li>实现离线优先</li><li>在不打断现有 Service Workers 的情况下，准备好一个新的 Service Workers</li><li>Service Workers 注册的作用域下的页面, 同一时间只由一个 Service Workers 控制</li><li>确保你的网站只有一个版本在运行</li></ul><p>Service Workers 注册成功，即 <code>navigator.serviceWorker.register</code> 返回成功，并不意味着它已经完成安装或已经激活，只能说明 worker 的脚本被成功解析，此时处于 installing 状态，install 事件被触发，一般在 install 事件的回调处理函数中提前缓存相关的静态文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'xxx'</span>;</span><br><span class="line">...</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果文件缓存失败，那安装步骤将会失败，Service Workers 也无法激活。如果发生这种情况，也不必担心，它下次会再试一次。如果安装成功，Service Workers 将会进入 installed / waiting 状态，此时，已准备好接管页面已有的 Service Workers，从而控制页面。<br>Service Workers 满足下面条件其中之一，就会进入 activating 状态：</p><ul><li>当前没有 active worker 在运行</li><li>代码调用了 self.skipWaiting() 跳过 waiting 状态</li><li>用户关闭页面, 释放了当前处于 active 状态的 worker</li><li>系统在一定时间后释放了当前处于 active 状态的 worker</li></ul><p>在 activating 状态，activate 事件被触发，一般在 activate 事件的回调处理函数中清除旧缓存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'pages-cache-v1'</span>, <span class="string">'blog-posts-cache-v1'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果 Service Workers 激活成功，将会进入 activated 状态，此时，该 worker 将会对其作用域内的所有页面进行控制，可以处理一些功能事件, 比如 fetch, push, message。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// Do stuff with fetch events</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// Do stuff with postMessages received from document</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Service Workers 对页面进行控制后，并不会一直保持着 Running 状态。它会处于两种状态的互换：</p><ul><li>为了节省内存，不需要处理事件和消息的 Service Workers 会处于 Stopped 状态，即使关联页面未关闭</li><li>页面发出网络请求或消息后，Service Workers 会处于 Running 状态，处理 fetch 和 message 事件，即使全部关联文档都已关闭</li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>目前除了 Chrome 之外，Firefox 和 Opera 也已经支持 Service Workers。Edge、Safari 当前正在开发中。<a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">is ServiceWork ready</a> 这里可以查看所有浏览器的支持情况。</p><h3 id="需要-Https"><a href="#需要-Https" class="headerlink" title="需要 Https"></a>需要 Https</h3><p>本地开发可以通过 localhost 使用 Service Workers，但部署到线上环境需要服务器支持 Https。</p><h2 id="注册-Service-Workers"><a href="#注册-Service-Workers" class="headerlink" title="注册 Service Workers"></a>注册 Service Workers</h2><p>首先检查浏览器是否支持 Service Worker API ，如果支持，则注册 Service Worker。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">             .register(<span class="string">'./service-worker.js'</span>)</span><br><span class="line">             .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); </span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>页面正常加载时，就会调用 register()，注意 register 方法参数所传的脚本路径，这里注册的 service-worker.js 脚本位于根目录下，这意味着 Service Worker 的作用域将是整个来源。换句话说，Service Worker 将接收此网站上所有事项的 fetch 事件。如果我们在 /example/service-worker.js 处注册Service Worker 文件，则 Service Worker 将只能看到网址以 /example/ 开头（即 /example/page1/、/example/page2/）的页面的 fetch 事件。<br>这时候可以通过在 Chrome 浏览器输入 chrome://inspect/#service-workers 来检查 Service Worker 是否已启用。</p><h2 id="安装服务工作线程"><a href="#安装服务工作线程" class="headerlink" title="安装服务工作线程"></a>安装服务工作线程</h2><p>前面提到过，Service Workers 注册成功，说明 service-worker.js 脚本被成功解析，此时处于 installing 状态，install 事件被触发，此时我们可以在 install 事件回调里决定想要缓存哪些文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'weatherPWA'</span>;</span><br><span class="line"><span class="keyword">var</span> filesToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/styles/main.css'</span>,</span><br><span class="line">  <span class="string">'/script/main.js'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform install steps</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>首先，我们需要通过 caches.open() 打开缓存并提供一个缓存名称。缓存打开后，我们便可调用 cache.addAll()，这个带有网址列表参数的方法随即从服务器获取文件，并将响应添加到缓存内。event.waitUntil() 方法带有 promise 参数并使用它来判断安装所花费的时间以及安装是否成功。</p><h2 id="缓存和返回请求"><a href="#缓存和返回请求" class="headerlink" title="缓存和返回请求"></a>缓存和返回请求</h2><p>Service Workers 激活后，开始处理一些功能事件。下面提供一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Cache hit - return response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里添加了 fetch 事件的监听，在 event.respondWith() 里传入 caches.match() 方法，caches.match() 会对 fetch 请求事件进行分析，检查它是否位于缓存内，并从 Service Workers 所创建的任何缓存中查找缓存的结果。如果发现匹配的响应，就返回缓存的值，否则，将调用 fetch 发出网络请求，并将请求拿到的数据作为结果返回。<br>如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Cache hit - return response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IMPORTANT: Clone the request. A request is a stream and</span></span><br><span class="line">        <span class="comment">// can only be consumed once. Since we are consuming this</span></span><br><span class="line">        <span class="comment">// once by cache and once by the browser for fetch, we need</span></span><br><span class="line">        <span class="comment">// to clone the response.</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone();</span><br><span class="line"><span class="comment">// 在 fetch 请求中添加对 .then() 的回调。</span></span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确保响应有效，检查并确保响应的状态为 200，确保响应类型为 basic，亦即由自身发起的请求。 这意味着，对第三方资产的请求不会添加到缓存</span></span><br><span class="line">            <span class="keyword">if</span>(!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IMPORTANT: Clone the response. A response is a stream</span></span><br><span class="line">            <span class="comment">// and because we want the browser to consume the response</span></span><br><span class="line">            <span class="comment">// as well as the cache consuming the response, we need</span></span><br><span class="line">            <span class="comment">// to clone it so we have two streams.</span></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="更新-Service-Workers"><a href="#更新-Service-Workers" class="headerlink" title="更新 Service Workers"></a>更新 Service Workers</h2><p>前面提到的 service-worker.js 会在什么情况下请求更新呢？一般有两种更新方式。</p><ul><li>强制更新<br>距离上一次更新检查已超过24小时, 会忽略浏览器缓存, 强制到服务器更新一次</li><li>检查更新<ul><li>第一次访问作用域里的页面</li><li>距离上一次更新检查已超过24小时</li><li>有功能性事件发生, 比如 push, sync</li><li>在 Service Worker URL 发生变化时调用了.register()方法</li><li>service-worker.js 的缓存时间已超出其头部的 max-age 设置的时间 (注: max-age 大于24小时, 会使用24小时作为其值).</li><li>service-worker.js 的代码只要有一个字节发生了变化, 就会触发更新, 将其视为“新服务工作线程”</li></ul></li></ul><p>一个新的 Service Worker 启动时，将会触发 install 事件，但由于旧的 Service Worker 仍然控制着当前的页面，因此，新的 Service Worker 进入了 waiting 状态。当网站上当前打开的页面关闭时，旧的 Service Worker 就会终止，新的 Service Worker 将会取得控制权，此时会触发 activate 事件。<br>在 activate 回调中的一个常见任务是缓存管理。原因在于，如果在安装步骤中清除了任何旧的缓存，则继续控制所有当前页面的任何旧的 Service Worker 将突然无法从缓存中提供文件。<br>举个例子，比如说我们有一个名为 ‘my-site-cache-v1’ 的缓存，我们想要将该缓存拆分为一个页面缓存和一个博文缓存。这就意味着在安装步骤中我们创建了两个缓存：‘pages-cache-v1’ 和 ‘blog-posts-cache-v1’，且在激活步骤中我们要删除旧的 ‘my-site-cache-v1’。</p><p>以下代码将执行此操作，具体做法为：遍历服务工作线程中的所有缓存，并删除未在缓存白名单中定义的任何缓存。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'pages-cache-v1'</span>, <span class="string">'blog-posts-cache-v1'</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Service-Workers-的退出"><a href="#Service-Workers-的退出" class="headerlink" title="Service Workers 的退出"></a>Service Workers 的退出</h2><p>Service Workers 在什么情况下会被停止呢？</p><p>（1）ServiceWorker JS 有任何异常，都会导致 ServiceWorker 线程退出。包括但不限于，JS 文件存在语法错误， ServiceWorker 安装失败/ 激活失败，ServiceWorker JS 执行时出现未捕获的异常。</p><p>（2）ServiceWorker 功能事件处理完成，处于空闲状态，ServiceWorker 线程会自动退出。</p><p>（3）ServiceWorker JS 执行时间过长，ServiceWorker 线程会自动退出。比如， ServiceWorker JS 执行时间超过30秒，或 Fetch 请求在5分钟内还未完成。</p><p>（4）浏览器会周期性检查各个 ServiceWorker 线程是否可以退出， 一般在启动ServiceWorker线程时会检查一次。</p><p>（5）为了方便开发者调试， Chromium 进行了特殊处理， 在连上 devtools 之后，ServiceWorker 线程不会退出。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.atatech.org/articles/78747" target="_blank" rel="noopener">PWA系列 - Service Workers 生命周期</a><br><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">Service Workers: an Introduction</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PWA 具备丰富的离线体验、定期的后台同步以及原生应用的推送通知功能，离不开 Service Workers 在背后提供的技术基础。&lt;br&gt;
    
    </summary>
    
      <category term="PWA" scheme="http://G96968586.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>学习搭建你的第一个 PWA</title>
    <link href="http://G96968586.github.io/2017/10/25/PWA/"/>
    <id>http://G96968586.github.io/2017/10/25/PWA/</id>
    <published>2017-10-25T07:28:03.000Z</published>
    <updated>2018-05-06T13:28:47.291Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 PWA ？ PWA 有哪些特点？PWA 在国内的发展情况怎么样？相对传统的 web 页面，PWA 能够给我们带来更多什么优势？想了解这些问题，可以看看这篇文章<a href="https://huangxuan.me/2017/02/09/nextgen-web-pwa/" target="_blank" rel="noopener">《下一代 Web 应用模型 —— Progressive Web App》</a>。本文的目的是教你如何搭建一个 PWA 应用，带你从中了解到 PWA 的一些技术实现细节和注意事项。<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Chrome 52 或更高版本</li><li>安装 <a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=zh-cn" target="_blank" rel="noopener">Web Server for Chrome</a> <img src="https://gw.alicdn.com/tfs/TB1OkN2SpXXXXcJaFXXXXXXXXXX-350-228.png_100x100.jpg" alt="image | center"><br>，当然，或使用自己选择的网络服务器</li><li>IDE 或文本编辑器</li><li>官方示例代码 <a href="https://github.com/googlecodelabs/your-first-pwapp/archive/master.zip" target="_blank" rel="noopener">-&gt;传送门</a></li></ul><h2 id="解压代码"><a href="#解压代码" class="headerlink" title="解压代码"></a>解压代码</h2><p>解压官方代码，你会发现在文件夹 your-first-pwapp-master 里有下面的目录结构：</p><p>├── <a href="http://CONTRIBUTING.md" target="_blank" rel="noopener">CONTRIBUTING.md</a><br>├── final<br>├── LICENSE<br>├── <a href="http://README.md" target="_blank" rel="noopener">README.md</a><br>├── resources<br>├── step-02<br>├── step-04<br>├── step-05<br>├── step-06<br>├── step-07<br>├── step-08<br>├── work<br>│    ├── favicon.ico<br>│    ├── images<br>│    ├── index.html -&gt; 后面会提到的 App Shell<br>│    ├── scripts<br>│    ├── styles</p><h2 id="验证-Web-Server-for-Chrome"><a href="#验证-Web-Server-for-Chrome" class="headerlink" title="验证 Web Server for Chrome"></a>验证 Web Server for Chrome</h2><p>首次安装完 Web Server for Chrome 后，打开它，会看到下面的窗口，<br><img src="https://gw.alicdn.com/tfs/TB1kXGVSpXXXXXsXXXXXXXXXXXX-1728-1436.png_500x500.jpg" alt="image | center"></p><p>点击 choose folder 按钮，然后选择 work 文件夹，<br><img src="https://gw.alicdn.com/tfs/TB1Ps5vSpXXXXcrXFXXXXXXXXXX-918-456.png_500x500.jpg" alt="image | center"></p><p>在 Options 下，选中“Automatically show index.html”旁边的框，如下所示：<br><img src="https://gw.alicdn.com/tfs/TB1_fCvSpXXXXckXFXXXXXXXXXX-580-712.png_400x400.jpg" alt="image | center"></p><p>你也可以修改默认的端口号：8887<br>然后将标记为“Web Server:STARTED”的切换按钮向左滑动，然后向右滑动，停止并重启服务器。<br>现在打开 Chrome，按住 option + command + I 进入开发者工具模式，再按住 shift + command + M进入移动端模式，访问 <a href="http://127.0.0.1:8887" target="_blank" rel="noopener">http://127.0.0.1:8887</a> ，将会看到下面的页面，<br><img src="https://gw.alicdn.com/tfs/TB1fzSJSpXXXXX7XpXXXXXXXXXX-758-1340.png_500x500.jpg" alt="image | center"></p><p>有一个转不停的菊花。</p><h2 id="构建-App-Shell"><a href="#构建-App-Shell" class="headerlink" title="构建 App Shell"></a>构建 App Shell</h2><p>App Shell 是一个能够被缓存的、轻量级的界面框架，它往往是纯 HTML 片段，只包括内联 CSS 和 base64 图片，不依赖于 JS 框架，是确保获得可靠而又出色性能的组件之一。它的第一次加载速度非常快，并且能够立即缓存。“缓存”意味着 Shell 文件一旦通过网络完成加载，就会保存到本地设备中。以后每当用户打开应用时，就会自动从本地设备的缓存中打开 Shell 文件，这样应用就能超快启动。<br><img src="https://gw.alicdn.com/tfs/TB1KXmVSpXXXXXBXXXXXXXXXXXX-1249-923.jpg" alt="image | center"></p><p>App Shell 将核心应用基础架构、 UI 与数据分离。所有 UI 和基础架构都利用服务工作线程缓存在本地，这样在后续加载时，PWA 只需检索必要的数据，而不必加载所有内容。换句话讲，App Shell 就类似于你在开发 Native 应用时需要向应用商店发布的一组代码。它是让你的应用成功起步所需的核心组件，但可能并不包含数据。</p><h3 id="设计-App-Shell"><a href="#设计-App-Shell" class="headerlink" title="设计 App Shell"></a>设计 App Shell</h3><p>第一步是将设计细分成其核心组件。</p><p>问问自己：</p><ul><li><p>哪些内容需要立即呈现在屏幕上？</p></li><li><p>还有哪些其他 UI 组件对我们的应用很重要？</p></li><li><p>App Shell 需要哪些支持资源？例如图像、JavaScript、样式等。</p></li></ul><p>示例代码是一个天气应用，将其作为我们的第一个 Progressive Web App。其关键组件将包括：</p><ul><li>标头，其中包含标题和添加/刷新按钮</li><li>预报卡片容器</li><li>预报卡片模板</li><li>用于添加新城市的对话框</li><li>加载指示器</li></ul><h3 id="实现-App-Shell"><a href="#实现-App-Shell" class="headerlink" title="实现 App Shell"></a>实现 App Shell</h3><p>在示例代码 work 目录下，找到 index.html，这是一个实现好的 App Shell，里面已经完成了大部分的 UI，接下来，可以着手连接代码，让一切运转起来！</p><p>在 work 目录下找到 script/app.js，打开 app.js 可以找到以下内容：</p><ul><li>一个 <code>app</code> 对象，其中包含应用所需的一些关键信息。</li><li>标头中所有按钮 (<code>add/refresh</code>) 和“Add City”对话框中所有按钮 (<code>add/cancel</code>) 的事件侦听器。</li><li>一个用于添加或更新预报卡片的方法 (<code>app.updateForecastCard</code>)。</li><li>一个用于从 Firebase Public Weather API 获取最新天气预报数据的方法 (<code>app.getForecast</code>)。</li><li>一个用于遍历现有卡片并调用 <code>app.getForecast</code> 以获取最新预报数据的方法 (<code>app.updateForecasts</code>)。</li><li>可用来快速测试渲染效果的一些虚假数据 (<code>initialWeatherForecast</code>)。</li></ul><p>示例代码提供了 mock 的天气预报数据，为了了解数据是如何渲染的，我们取消 <code>index.html</code> 文件底部的以下行的注释：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;script src="scripts/app.js" async&gt;&lt;/script&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，取消 <code>app.js</code> 文件底部的以下行的注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.updateForecastCard(initialWeatherForecast);</span></span><br></pre></td></tr></table></figure><p>刷新浏览器，你将看到如下图所示的界面：</p><p><img src="https://gw.alicdn.com/tfs/TB14XC0SpXXXXXHXXXXXXXXXXXX-754-1338.png_500x500.jpg" alt="image | center"></p><h2 id="从快速首次加载开始"><a href="#从快速首次加载开始" class="headerlink" title="从快速首次加载开始"></a>从快速首次加载开始</h2><p>Progressive Web App 应启动迅速，并且立即就能使用。在目前状态下，我们的天气应用虽启动迅速，却无法使用，因为没有任何数据。我们可以发出 AJAX 请求来获取该数据，但那会额外增加一个请求，使首次加载时间变得更长。可以改为在首次加载时提供真实数据。</p><h3 id="注入天气预报数据"><a href="#注入天气预报数据" class="headerlink" title="注入天气预报数据"></a>注入天气预报数据</h3><p>在示例代码中，模拟服务器将天气预报直接注入 JavaScript 中，但在生产应用中，最新天气预报数据将由服务器根据用户的 IP 地址地理定位进行注入。</p><p>代码已经包含我们即将注入的数据。这就是前面步骤中使用的 <code>initialWeatherForecast</code>。</p><h3 id="区分首次运行"><a href="#区分首次运行" class="headerlink" title="区分首次运行"></a>区分首次运行</h3><p>我们怎么知道什么时候显示这些信息呢？因为未来加载时天气应用将从缓存中获取，届时这些信息可能不再相关了。比如，用户在后续访问时加载应用，他们可能已改换城市，因此，我们需要加载的是这些城市的信息，而不一定是他们查询过的第一个城市。</p><p>用户首选项（比如用户订阅的城市列表）应利用 IndexedDB 或其他快速存储机制存储在本地。为尽可能简化此代码实验室，我们使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>，但它并非生产应用的理想选择，因为它是一种封闭的同步存储机制，在某些设备上可能会运行得非常缓慢。</p><p>首先，让我们添加必要的代码来保存用户首选项。在 app.js 文件中，找到下面的 TODO 注释，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add saveSelectedCities function here</span></span><br></pre></td></tr></table></figure><p>在注释下方添加下面的代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save list of cities to localStorage.</span></span><br><span class="line">  app.saveSelectedCities = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> selectedCities = <span class="built_in">JSON</span>.stringify(app.selectedCities);</span><br><span class="line">    localStorage.selectedCities = selectedCities;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>接下来，添加启动代码，以检查用户是否保存了任何城市并渲染这些城市，或使用注入的数据。找到以下注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add startup code here</span></span><br></pre></td></tr></table></figure><p>并在注释下方添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Code required to start the app</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">NOTE:</span>To simplify this codelab, we've used localStorage.</span></span><br><span class="line"><span class="comment">   *   localStorage is a synchronous API and has serious performance</span></span><br><span class="line"><span class="comment">   *   implications.It should not be used in production applications!</span></span><br><span class="line"><span class="comment">   *   Instead, check out IDB (https://www.npmjs.com/package/idb) or</span></span><br><span class="line"><span class="comment">   *   SimpleDB (https://gist.github.com/inexorabletash/c8069c042b734519680c)</span></span><br><span class="line"><span class="comment">   ************************************************************************/</span></span><br><span class="line"></span><br><span class="line">  app.selectedCities = localStorage.selectedCities;</span><br><span class="line">  <span class="keyword">if</span> (app.selectedCities) &#123;</span><br><span class="line">    app.selectedCities = <span class="built_in">JSON</span>.parse(app.selectedCities);</span><br><span class="line">    app.selectedCities.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">      app.getForecast(city.key, city.label);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* The user is using the app for the first time, or the user has not</span></span><br><span class="line"><span class="comment">     * saved any cities, so show the user some fake data.A real app in this</span></span><br><span class="line"><span class="comment">     * scenario could guess the user's location via IP lookup and then inject</span></span><br><span class="line"><span class="comment">     * that data into the page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app.updateForecastCard(initialWeatherForecast);</span><br><span class="line">    app.selectedCities = [</span><br><span class="line">      &#123;<span class="attr">key</span>: initialWeatherForecast.key, <span class="attr">label</span>: initialWeatherForecast.label&#125;</span><br><span class="line">    ];</span><br><span class="line">    app.saveSelectedCities();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动代码会检查本地存储中是否存储了任何城市。如果存储了城市，它就会解析本地存储数据，然后为保存的每个城市显示预报卡片。如果没有存储城市，启动代码会使用虚假的预报数据，并将其保存为默认城市。</p><p>最后，我们需要修改“Add City”按钮处理程序，以便将所选的城市添加到本地存储。</p><p>更新 <code>butAddCity</code> 点击处理程序，以便匹配以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'butAddCity'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Add the newly selected city</span></span><br><span class="line">    <span class="keyword">var</span> select = <span class="built_in">document</span>.getElementById(<span class="string">'selectCityToAdd'</span>);</span><br><span class="line">    <span class="keyword">var</span> selected = select.options[select.selectedIndex];</span><br><span class="line">    <span class="keyword">var</span> key = selected.value;</span><br><span class="line">    <span class="keyword">var</span> label = selected.textContent;</span><br><span class="line">    <span class="keyword">if</span> (!app.selectedCities) &#123;</span><br><span class="line">      app.selectedCities = [];</span><br><span class="line">    &#125;</span><br><span class="line">    app.getForecast(key, label);</span><br><span class="line">    app.selectedCities.push(&#123;<span class="attr">key</span>: key, <span class="attr">label</span>: label&#125;);</span><br><span class="line">    app.saveSelectedCities();</span><br><span class="line">    app.toggleAddDialog(<span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>新添加的内容是 <code>app.selectedCities</code> 的初始化，以及对 <code>app.selectedCities.push()</code> 和 <code>app.saveSelectedCities()</code> 的调用。</p><p>OK，再次刷新浏览器，运行时，应用应该会立即向用户显示来自 <code>initialWeatherForecast</code> 的天气预报数据。点击右上角的图标，增加新的城市，并验证应用是否加载了两个天气预报卡片并显示了最新信息。</p><h2 id="利用-Service-Worker-预缓存-App-Shell"><a href="#利用-Service-Worker-预缓存-App-Shell" class="headerlink" title="利用 Service Worker 预缓存 App Shell"></a>利用 Service Worker 预缓存 App Shell</h2><p>Progressive Web App 必须快速并且可安装，这意味着它们能够在在线、离线以及间歇性、弱网络连接下工作。要实现此目标，我们需要利用服务工作线程缓存我们的 App Shell，让其始终都能快速而又可靠地投入使用。</p><h3 id="在服务工作线程可用时注册它"><a href="#在服务工作线程可用时注册它" class="headerlink" title="在服务工作线程可用时注册它"></a>在服务工作线程可用时注册它</h3><p>使应用离线工作的第一步是注册一个 Service Worker 服务工作线程，这是一个无需打开网页或用户交互便可实现后台功能的脚本。</p><p>只需要两步骤：</p><ul><li>让浏览器将 JavaScript 文件注册为服务工作线程</li><li>创建包含此服务工作线程的 JavaScript 文件</li></ul><p>首先我们需要检查浏览器是否支持服务工作线程，如果支持，则注册服务工作线程。在 app.js 找到下面注释之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO add service worker code here</span></span><br></pre></td></tr></table></figure><p>添加下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">             .register(<span class="string">'./service-worker.js'</span>)</span><br><span class="line">             .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存网站资源"><a href="#缓存网站资源" class="headerlink" title="缓存网站资源"></a>缓存网站资源</h3><p>注册服务工作线程后，用户首次访问页面时将会触发安装事件。在此事件处理程序内，我们将缓存应用所需的全部资源。触发服务工作线程时，它会打开 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener">caches</a> 对象并为其填充加载 App Shell 所需的资源。在 work 目录下，创建 service-worker.js 文件，这个文件之所以必须位于应用的根文件夹内，是因为服务工作线程的作用域由该文件所在的目录定义。在 service-worker.js 添加下面代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'weatherPWA-step-6-1'</span>;</span><br><span class="line"><span class="keyword">var</span> filesToCache = [];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Install'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先，我们需要通过 <code>caches.open()</code> 打开缓存并提供一个缓存名称。提供缓存名称可让我们对文件进行版本控制，或将数据与 App Shell 分开，以便我们能轻松地更新某个数据，而不会影响其他数据。</p><p>缓存打开后，我们便可调用 <code>cache.addAll()</code>，这个带有网址列表参数的方法随即从服务器获取文件，并将响应添加到缓存内。遗憾的是，<code>cache.addAll()</code> 具有原子性，如果任何一个文件失败，整个缓存步骤也将失败！</p><h3 id="使用-DevTools-了解和调试服务工作线程"><a href="#使用-DevTools-了解和调试服务工作线程" class="headerlink" title="使用 DevTools 了解和调试服务工作线程"></a>使用 DevTools 了解和调试服务工作线程</h3><p>重新加载页面之前，打开 DevTools，转至 <strong>Application </strong>面板的 <strong>Service Worker </strong>窗口，如下所示：</p><p><img src="https://gw.alicdn.com/tfs/TB1it5fSpXXXXceapXXXXXXXXXX-632-419.png" alt="image | center"></p><p>如果看到类似于这样的空白页面，就表示当前打开的页面没有注册服务工作线程。</p><p>现在，重新加载页面。Service Worker 窗口现在应该像下面这样，表示页面正在运行服务工作线程。</p><p><img src="https://gw.alicdn.com/tfs/TB1jgh6SpXXXXayaVXXXXXXXXXX-1490-858.png_600x600" alt="image | center"></p><p>现在，我们将要插入一点其他内容，说明我们在开发服务工作线程时可能会遇到的 Gotcha。为了说明这一问题，需要在 <code>service-worker.js</code> 文件中的 <code>install</code> 侦听器下面添加 <code>activate</code> 事件侦听器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>activate</code> 事件会在服务工作线程启动时触发。</p><p>打开 DevTools Console，重新加载页面，切换到 Application 面板中的 Service Worker 窗口，然后点击激活的服务工作线程上的 Inspect。可以看到 <code>[ServiceWorker] Activate</code> 消息记录到控制台，但并没有发生。请查看 Service Worker 窗口，我们会看到新的服务工作线程（包含激活事件侦听器）处于“等待”状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Hd1HSpXXXXa5XFXXXXXXXXXX-1494-534.png_600x600" alt="image | center"></p><p>从根本上说，只要页面有打开的标签，以前的服务工作线程就会继续控制页面。因此，你可以关闭然后重新打开页面，或者按 <strong>skipWaiting </strong>按钮，但是更长期的解决方案只需启用 DevTools 的 Service Worker 窗口上的 <strong>Update on Reload </strong>复选框。如果启用此复选框，服务工作线程会在每次页面重新加载时强制更新。</p><p>现在启用 <strong>update on reload </strong>复选框，并重新加载页面，以确认新的服务工作线程被激活。</p><p><strong>注：</strong> 你可能会在 Application 面板的 Service Worker 窗口中发到一个错误（类似于以下内容），完全可以忽略此错误。</p><p><img src="https://gw.alicdn.com/tfs/TB1v.KDSpXXXXcCXFXXXXXXXXXX-424-73.png" alt="image | center"></p><p>有关在 DevTools 中检查和调试服务工作线程的内容就到此结束。现在，我们来展开 <code>activate</code> 事件侦听器，添加以下逻辑来更新缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== cacheName) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Removing old cache'</span>, key);</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> self.clients.claim();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码可以确保我们的服务工作线程在任何 App Shell 文件更改时更新其缓存。为了使其工作，我们需要在服务工作线程文件的顶部增加 <code>cacheName</code> 变量。</p><p>最后，我们更新 App Shell 所需的文件列表。在数组中，我们需要加入应用所需的全部文件，包括图像、JavaScript、样式表等。在接近 <code>service-worker.js</code> 文件顶部的地方，使用以下代码替换 <code>var filesToCache = [];</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filesToCache = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">'/index.html'</span>,</span><br><span class="line">  <span class="string">'/scripts/app.js'</span>,</span><br><span class="line">  <span class="string">'/styles/inline.css'</span>,</span><br><span class="line">  <span class="string">'/images/clear.png'</span>,</span><br><span class="line">  <span class="string">'/images/cloudy-scattered-showers.png'</span>,</span><br><span class="line">  <span class="string">'/images/cloudy.png'</span>,</span><br><span class="line">  <span class="string">'/images/fog.png'</span>,</span><br><span class="line">  <span class="string">'/images/ic_add_white_24px.svg'</span>,</span><br><span class="line">  <span class="string">'/images/ic_refresh_white_24px.svg'</span>,</span><br><span class="line">  <span class="string">'/images/partly-cloudy.png'</span>,</span><br><span class="line">  <span class="string">'/images/rain.png'</span>,</span><br><span class="line">  <span class="string">'/images/scattered-showers.png'</span>,</span><br><span class="line">  <span class="string">'/images/sleet.png'</span>,</span><br><span class="line">  <span class="string">'/images/snow.png'</span>,</span><br><span class="line">  <span class="string">'/images/thunderstorm.png'</span>,</span><br><span class="line">  <span class="string">'/images/wind.png'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>现在应用现在还不能离线运行。我们虽然已缓存了 App Shell 组件，但仍需从本地缓存加载它们。</p><h3 id="从缓存提供-App-Shell"><a href="#从缓存提供-App-Shell" class="headerlink" title="从缓存提供 App Shell"></a>从缓存提供 App Shell</h3><p>服务工作线程提供了拦截 Progressive Web App 发出的请求并在服务工作线程内对它们进行处理的能力。这意味着我们可以决定想要如何处理请求，并可提供我们自己的已缓存响应。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something interesting with the fetch here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在我们从缓存提供 App Shell。将以下代码添加到 <code>service-worker.js</code> 文件的底部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Fetch'</span>, e.request.url);</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>caches.match()</code> 会由内而外对触发<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener"> fetch </a>事件的网络请求进行评估，并检查以确认它是否位于缓存内。它随即使用已缓存版本作出响应，或者利用 <code>fetch</code> 从网络获取一个副本。<code>response</code> 通过 <code>e.respondWith()</code> 传回至网页。</p><p>又到测试环节了，现在我们的应用可以离线运行了。重新加载页面，然后转至 DevTools 的 <strong>Application</strong> 面板的 <strong>Cache Storage</strong> 窗口。展开这个部分，可以看到左侧列出的 App Shell 缓存的名称。当我们点击 App Shell 缓存后，可以看到它当前缓存的所有资源。</p><p><img src="https://gw.alicdn.com/tfs/TB1EXiaSpXXXXabaFXXXXXXXXXX-1466-862.png_600x600" alt="image | center"></p><p>现在，测试一下离线模式。回到 DevTools 的 <strong>Service Worker</strong> 窗口，然后勾上 <strong>Offline</strong> 复选框。启用后，可以看到 <strong>Network</strong> 面板标签旁边显示很小的黄色警告图标。这表示当前正处于离线状态。</p><p><img src="https://gw.alicdn.com/tfs/TB1Zo1oSpXXXXcdaXXXXXXXXXXX-1292-524.png_600x600" alt="image | center"></p><p>重新刷新页面，你会发现天气预报卡片还是出来了！请注意它加载初始（虚假）天气数据的方式。</p><p><img src="https://gw.alicdn.com/tfs/TB1l3udSpXXXXbRapXXXXXXXXXX-752-898.png_400x400" alt="image | center"></p><p>下一步就是修改应用和服务工作线程逻辑，以便能够缓存天气数据，并在应用处于离线状态时从缓存中返回最新数据。</p><p>如果要开始刷新和清除已保存的所有数据（localStoarge、indexedDB 数据、缓存文件）以及移除任何服务工作线程，请使用 Application 标签中的 Clear storage。</p><h2 id="使用-Service-Worker-缓存天气预报数据"><a href="#使用-Service-Worker-缓存天气预报数据" class="headerlink" title="使用 Service Worker 缓存天气预报数据"></a>使用 Service Worker 缓存天气预报数据</h2><h3 id="拦截网络请求并缓存响应"><a href="#拦截网络请求并缓存响应" class="headerlink" title="拦截网络请求并缓存响应"></a>拦截网络请求并缓存响应</h3><p>我们需要修改服务工作线程，以拦截发给 weather API 的请求，并将其响应存储在缓存内，以便我们在稍后访问它们。</p><p>我们在服务工作线程中添加一个 <code>dataCacheName</code>，以便将应用数据与 App Shell 分离。更新 App Shell 并清除较旧缓存时，我们的数据将保持不变，可随时用于实现超快速加载。注意，如果未来你的数据格式发生变化，你需要相应的处理手段，并且需要确保 App Shell 和内容保持同步。</p><p>在 <code>service-worker.js</code> 文件顶部添加下面一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataCacheName = <span class="string">'weatherData-v1'</span>;</span><br></pre></td></tr></table></figure><p>然后，更新 <code>activate</code> 事件处理程序，使其不会在清除 App Shell 缓存时删除数据缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key !== cacheName &amp;&amp; key !== dataCacheName) &#123;</span><br></pre></td></tr></table></figure><p>最后，更新 <code>fetch</code> 事件处理程序，将发给 data API 的请求与其他请求分开处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Fetch'</span>, e.request.url);</span><br><span class="line">  <span class="keyword">var</span> dataUrl = <span class="string">'https://query.yahooapis.com/v1/public/yql'</span>;</span><br><span class="line">  <span class="keyword">if</span> (e.request.url.indexOf(dataUrl) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the request URL contains dataUrl, the app is asking for fresh</span></span><br><span class="line"><span class="comment">     * weather data. In this case, the service worker always goes to the</span></span><br><span class="line"><span class="comment">     * network and then caches the response. This is called the "Cache then</span></span><br><span class="line"><span class="comment">     * network" strategy:</span></span><br><span class="line"><span class="comment">     * https://jakearchibald.com/2014/offline-cookbook/#cache-then-network</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    e.respondWith(</span><br><span class="line">      caches.open(dataCacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetch(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">          cache.put(e.request.url, response.clone());</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The app is asking for app shell files. In this scenario the app uses the</span></span><br><span class="line"><span class="comment">     * "Cache, falling back to the network" offline strategy:</span></span><br><span class="line"><span class="comment">     * https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    e.respondWith(</span><br><span class="line">      caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码会拦截请求，并检查网址是否以 weather API 的地址开头。如果是，我们将使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">fetch</a> 发出请求。返回请求后，我们的代码会打开缓存，克隆响应，将其存储在缓存内，最后将响应返回给原始请求者。</p><p>我们的应用还不能完全离线工作。我们已经实现了 App Shell 的缓存和检索，但尽管我们缓存了数据，应用也没有查看缓存来看看其中是否有任何天气数据。</p><h3 id="发出请求"><a href="#发出请求" class="headerlink" title="发出请求"></a>发出请求</h3><p>如前面所述，应用需要发起两个异步请求，一个发向缓存，一个发向网络。应用利用 <code>window</code> 中提供的 <code>caches</code> 对象来访问缓存和检索最新数据。这是“渐进式增强”的一个典范，因为可能并非所有浏览器都提供 <code>caches</code> 对象，即使没有该对象，网络请求仍应正常工作。</p><p>为此，我们需要做的是：</p><ol><li>检查全局 <code>window</code> 对象中是否提供了 <code>caches</code> 对象</li><li>从缓存请求数据</li><li>如果服务器请求仍未完成，则用缓存的数据更新应用</li><li>从服务器请求数据</li><li>保存数据以便稍后快速访问</li><li>使用来自服务器的最新数据更新应用</li></ol><h3 id="从缓存获取数据"><a href="#从缓存获取数据" class="headerlink" title="从缓存获取数据"></a>从缓存获取数据</h3><p>接下来，我们需要检查并确保 <code>caches</code> 对象存在，并从该对象请求最新数据。找到 <code>app.getForecast()</code> 中的 <code>TODO add cache logic here</code> 注释，然后在注释下方添加以下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Check if the service worker has already cached this city's weather</span></span><br><span class="line"><span class="comment">      * data. If the service worker has the data, then display the cached</span></span><br><span class="line"><span class="comment">      * data while the app fetches the latest data.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     caches.match(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (response) &#123;</span><br><span class="line">         response.json().then(<span class="function"><span class="keyword">function</span> <span class="title">updateFromCache</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> results = json.query.results;</span><br><span class="line">           results.key = key;</span><br><span class="line">           results.label = label;</span><br><span class="line">           results.created = json.query.created;</span><br><span class="line">           app.updateForecastCard(results);</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们的天气应用现在会发出两个异步数据请求，一个去请求 <code>cache</code> ，一个去请求远程 API 数据，一般情况下缓存请求会先把结果返回，此时我们的页面将以极快的速度（几十微秒）渲染，并更新卡片。随后，远程返回响应后将直接使用 weather API 的最新数据更新卡片。</p><p>请注意缓存请求和 XHR 请求都以更新预报卡片的调用结束。应用如何知道它是否显示了最新数据？<code>app.updateForecastCard</code> 中的以下代码会处理这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cardLastUpdatedElem = card.querySelector(<span class="string">'.card-last-updated'</span>);</span><br><span class="line">    <span class="keyword">var</span> cardLastUpdated = cardLastUpdatedElem.textContent;</span><br><span class="line">    <span class="keyword">if</span> (cardLastUpdated) &#123;</span><br><span class="line">      cardLastUpdated = <span class="keyword">new</span> <span class="built_in">Date</span>(cardLastUpdated);</span><br><span class="line">      <span class="comment">// Bail if the card has more recent data then the data</span></span><br><span class="line">      <span class="keyword">if</span> (dataLastUpdated.getTime() &lt; cardLastUpdated.getTime()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每次更新卡片时，应用都会在卡片上隐藏的属性中存储数据的时间戳。仅当卡片上已经存在的时间戳晚于传递给函数的数据时，应用才会释放。</p><p>现在应用应能完全离线运行了。保存两个城市，按应用上的 refresh 按钮获取最新的天气数据，然后转为离线状态并重新加载页面。</p><p>转至 DevTools 的 <strong>Application</strong> 面板的 <strong>Cache Storage</strong> 窗口。展开这个部分，你可以看到左侧列出的 App Shell 和数据缓存的名称。如果每个城市存储有数据，即可打开数据缓存。</p><p><img src="https://gw.alicdn.com/tfs/TB1mRGRSpXXXXaZXpXXXXXXXXXX-1662-816.png_600x600" alt="image | center"></p><h2 id="添加至主屏幕"><a href="#添加至主屏幕" class="headerlink" title="添加至主屏幕"></a>添加至主屏幕</h2><p>通过 Add To Home Screen 功能，我们可以像从应用商店安装本机应用那样，选择为设备添加一个快捷链接，并且过程要顺畅得多。</p><h3 id="通过-manifest-json-文件声明应用清单"><a href="#通过-manifest-json-文件声明应用清单" class="headerlink" title="通过 manifest.json 文件声明应用清单"></a>通过 manifest.json 文件声明应用清单</h3><p>网络应用清单是一个简单的 JSON 文件，利用网络应用清单，你的网络应用可以：</p><ul><li>在用户的 Android 主屏幕进行丰富的呈现</li><li>在没有网址栏的 Android 设备上以全屏模式启动</li><li>控制屏幕方向以获得最佳查看效果</li><li>定义网站的“启动画面”启动体验和主题颜色</li><li>追踪你是从主屏幕还是从网址栏启动</li></ul><p>在 work 文件夹中创建名称为 manifest.json 的文件，并复制/粘贴以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Weather"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"Weather"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [&#123;</span><br><span class="line">    <span class="attr">"src"</span>: <span class="string">"images/icons/icon-128x128.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"128x128"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-144x144.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-152x152.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"152x152"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-192x192.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"192x192"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-256x256.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"256x256"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;],</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/index.html"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#3E4EB8"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#2F3BA2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此清单支持一组适用于各种屏幕尺寸的图标。</p><p>现在将以下行添加到 <code>index.html</code> 文件中的 <code>&lt;head&gt;</code> 元素底部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最佳做法：</p><ul><li>在你网站的所有网页上放置该清单链接，这样一来，无论用户首次访问时登陆哪个网页，Chrome 都会立即检索到它。</li><li>在 Chrome 上首选使用 <code>short_name</code>，如果存在，则优先于 name 字段使用。</li><li>为不同密度的屏幕定义图标集。Chrome 会尝试使用最接近 48dp 的图标，例如它会在 2 倍像素的设备上使用 96px，在 3 倍像素的设备上使用 144px。</li><li>请记得提供尺寸对启动画面而言合理的图标，并且别忘了设置 <code>background_color</code>。</li></ul><p>在 <code>index.html</code> 中，向 <code>&lt;head&gt;</code> 元素底部添加以下代码，以适配 iOS Safari：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Add to home screen for Safari on iOS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"Weather PWA"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"images/icons/icon-152x152.png"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试验证，打开 DevTool，切换到 <strong>Application </strong>面板上的 <strong>Manifest </strong>窗口，</p><p><img src="https://gw.alicdn.com/tfs/TB1NzqASpXXXXcVXpXXXXXXXXXX-1894-1258.png_600x600" alt="image | center"></p><p>发现浏览器已经将其解析出来了。切换到 Web Server for Chrome，勾上<code>Accessible on local network</code> 选项</p><p><img src="https://gw.alicdn.com/tfs/TB1rPOPSpXXXXXzXpXXXXXXXXXX-700-1212.png_600x600" alt="image | center"></p><p>将网络服务器切换到 <code>STOPPED</code>，然后重新切换到 <code>STARTED</code>。你会看到在 Web Server URL(s) 下面有一个可以远程访问的地址，使用手机访问这个页面，就可以在手机上体验这个 PWA 了。</p><p>如果使用这种测试方式，你会在控制台中看到服务工作线程错误，这是因为未通过 HTTPS 提供服务工作线程。</p><p>在移动 Android 设备上使用 Chrome，尝试将应用添加到主屏幕并验证启动屏幕能否正确显示以及使用的图标是否正确。</p><h2 id="部署到-Firebase"><a href="#部署到-Firebase" class="headerlink" title="部署到 Firebase"></a>部署到 Firebase</h2><p>如果你从未接触过 Firebase，需要先创建你的帐户并安装一些工具。</p><ol><li>在 <a href="https://firebase.google.com/console/?hl=zh-cn" target="_blank" rel="noopener">https://firebase.google.com/console/</a> 上创建一个 Firebase 帐户</li><li>通过 npm 安装 Firebase：<code>npm install -g firebase-tools</code></li></ol><p>创建帐户并登录后，便可随时进行部署！</p><ol><li><p>在 <a href="https://firebase.google.com/console/?hl=zh-cn" target="_blank" rel="noopener">https://firebase.google.com/console/</a> 上创建一个新应用，这里我创建了一个叫 PWA Demo 的应用</p><p><img src="https://gw.alicdn.com/tfs/TB1ly9fSpXXXXcBapXXXXXXXXXX-1970-566.png" alt="image | center"></p></li></ol><ol start="2"><li><p>如果你近期未登录 Firebase 工具，需要重新登录：<code>firebase login</code></p></li><li><p>初始化你的应用，并提供你完成的应用所在的目录（我们的示例 Demo 是 <code>work</code>）： <code>firebase init</code></p><p><img src="https://gw.alicdn.com/tfs/TB1QByCSpXXXXXHXVXXXXXXXXXX-2448-1328.png_600x600" alt="image | center"></p></li></ol><ol start="4"><li><p>最后，将应用部署到 Firebase： <code>firebase deploy</code></p><p><img src="https://gw.alicdn.com/tfs/TB1Ahh6SpXXXXbeaVXXXXXXXXXX-2420-914.png_600x600" alt="image | center"></p></li></ol><ol start="5"><li>大功告成。 操作完成！我们的应用将部署到以下网域：<code>https://YOUR-FIREBASE-APP.firebaseapp.com</code></li></ol><p>测试，尝试将应用添加到主屏幕，然后断开网络并验证应用能够按照预期离线工作。当然，你可以选择部署到集团 CDN 上，这里就不演示了。</p><p>OK，就到这吧，后面再给大家带来详细的《调试服务工作线程》和 《向网络应用添加推送通知》的分享。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 PWA ？ PWA 有哪些特点？PWA 在国内的发展情况怎么样？相对传统的 web 页面，PWA 能够给我们带来更多什么优势？想了解这些问题，可以看看这篇文章&lt;a href=&quot;https://huangxuan.me/2017/02/09/nextgen-web-pwa/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《下一代 Web 应用模型 —— Progressive Web App》&lt;/a&gt;。本文的目的是教你如何搭建一个 PWA 应用，带你从中了解到 PWA 的一些技术实现细节和注意事项。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
      <category term="PWA" scheme="http://G96968586.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>weekly-1125 </title>
    <link href="http://G96968586.github.io/2016/11/27/weekly-1125/"/>
    <id>http://G96968586.github.io/2016/11/27/weekly-1125/</id>
    <published>2016-11-27T15:46:11.000Z</published>
    <updated>2018-05-02T09:44:49.288Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Android Logcat的Material颜色主题</li></ul><p>要改变 Android Studio 的 Logcat 你需要这样做：进入 Preferences ( Windows 上是 Settings / Linux machines ) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色(foreground)。</p><p><img src="http://p3.pstatp.com/large/10f3000b2045b867f40e" alt="img"></p><a id="more"></a><p>我使用的material颜色：</p><p>Assert #BA68C8</p><p>Debug #2196F3</p><p>Error #F44336</p><p>Info #4CAF50</p><p>Verbose #BBBBBB</p><p>Warning #FF9800</p><p>注意里面有几个现有的主题，可以直接修改现有主题(不建议)，或者点击save as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。</p><ul><li>防止当前应用崩溃时 Logcat 清除 log</li></ul><p>在 Android Monitor 面板的右上方点击下拉菜单中的 choose Edit filter configuration：</p><p><img src="http://p1.pstatp.com/large/11af000b840a002fe833" alt="img"></p><ul><li>无干扰模式</li></ul><p>你可以到 View → Enter Distraction Free Mode 里启用它</p><p><img src="http://p1.pstatp.com/large/10f3000b2046565442d3" alt="img"></p><p>在无干扰模式下，编辑器占据了整个IntelliJ IDEA窗口，没有任何tab或者工具按钮。代码居中显示。[ IntelliJ Idea Viewing Modes ]</p><p><img src="http://p3.pstatp.com/large/10e6000fb226567e1a0f" alt="img"></p><ul><li>使用 Live Templates</li></ul><p>你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。</p><p><img src="http://p3.pstatp.com/large/11b100005c12e0ddbb70" alt="img"></p><p>可以使用已经定义好了的 Live Templates，比如 Toasts 或者 if 语句。</p><p>可以使用自定义的 templates。这里是 Reto Meier 的一篇不错的参考文章。你也可以参考 IntelliJ IDEA 的文档。</p><ul><li>option + enter</li></ul><p>把一个硬编码的字符串放到资源文件中：option + enter (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图：</p><p><img src="http://p3.pstatp.com/large/10f3000b2047df7703c4" alt="img"></p><ul><li>查看远程分支</li></ul><p>git branch -a</p><ul><li>查看本地分支</li></ul><p>git branch</p><ul><li>CSS实现单行、多行文本溢出显示省略号（…）</li></ul><p>如果实现单行文本的溢出显示省略号同学们应该都知道用 text-overflow:ellipsis 属性来，当然还需要加宽度 width 属来兼容部分浏览。</p><p>实现方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="http://www.daqianduan.com/wp-content/uploads/2015/10/dome1.png" alt=""></p><p>但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。</p><p>接下来重点说一说多行文本溢出显示省略号，如下。</p><p>实现方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><p>效果图：<br><img src="http://www.daqianduan.com/wp-content/uploads/2015/10/dome2.png" alt=""></p><p>适用范围：<br>因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；</p><p>注：</p><p>-webkit-line-clamp;<br>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。</p><p>常见结合属性：</p><p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p><p>-webkit-box-orient; 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p><ul><li>input 输入框点击时去掉外边框方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  outline: white ;<span class="comment">/* 颜色随便设置 */</span></span><br><span class="line">  border: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Android Logcat的Material颜色主题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要改变 Android Studio 的 Logcat 你需要这样做：进入 Preferences ( Windows 上是 Settings / Linux machines ) → Editor → Colors &amp;amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色(foreground)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/10f3000b2045b867f40e&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ADB 常用命令</title>
    <link href="http://G96968586.github.io/2016/10/23/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://G96968586.github.io/2016/10/23/ADB-常用命令/</id>
    <published>2016-10-23T14:30:30.000Z</published>
    <updated>2018-05-02T12:37:06.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ADB-常用命令总结："><a href="#ADB-常用命令总结：" class="headerlink" title="ADB 常用命令总结："></a>ADB 常用命令总结：</h3><ul><li><p>显示系统全部的 Android 平台</p><p><code>android list targets</code></p><p>output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  android list targets</span><br><span class="line">Available Android targets:</span><br><span class="line">----------</span><br><span class="line">id: 1 or "android-21"</span><br><span class="line">     Name: Android 5.0.1</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 21</span><br><span class="line">     Revision: 2</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</span><br><span class="line"> Tag/ABIs : no ABIs.</span><br><span class="line">----------</span><br><span class="line">id: 2 or "android-22"</span><br><span class="line">     Name: Android 5.1.1</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 22</span><br><span class="line">     Revision: 2</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in, AndroidWearRound, AndroidWearRound400x400, AndroidWearRoundChin320x290, AndroidWearRoundChin360x325, AndroidWearRoundChin360x330, AndroidWearSquare, AndroidWearSquare320x320, AndroidWearRound, AndroidWearRound400x400, AndroidWearRoundChin320x290, AndroidWearRoundChin360x325, AndroidWearRoundChin360x330, AndroidWearSquare, AndroidWearSquare320x320</span><br><span class="line"> Tag/ABIs : android-tv/armeabi-v7a, android-tv/x86, android-wear/armeabi-v7a, android-wear/x86, default/armeabi-v7a, default/x86, default/x86_64</span><br><span class="line">----------</span><br><span class="line">id: 3 or "android-23"</span><br><span class="line">     Name: Android 6.0</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 23</span><br><span class="line">     Revision: 3</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</span><br><span class="line"> Tag/ABIs : no ABIs.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>安装应用</p><p><code>adb install xxx.apk</code><br>output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p>如果手机已经存在 newjob 应用，则会报</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure><p>这时候，加一个 -r 参数，代表重新安装，就不会报上面的错误了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb install -r newjob.apk</span><br><span class="line"><span class="meta">[100%</span>] /data/local/tmp/newjob.apk</span><br><span class="line">pkg: /data/local/tmp/newjob.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>Push 将文件写入手机存储系统</p><p><code>adb push &lt;local&gt; &lt;remote&gt;</code></p><p>只要拥有相应的权限，就可以把任何文件写入到手机的任何目录下。比如，前面我们通过 install 将一个 App 安装到手机上，这里，我们也可以把 Apk Push 到 Sdcard 再手动点击安装。</p><p><code>adb push ~/Desktop/newjob.apk /sdcard/</code></p><p>同理，既然可以将文件写入手机，也可以将手机里的文件取出来。</p></li><li><p>Pull 获取手机中的文件</p><p> <code>adb pull &lt;remote&gt; &lt;local&gt;</code>       </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  adb pull /sdcard/ newjob.apk</span><br></pre></td></tr></table></figure></li><li><p>查看 Log 日志</p><p> <code>adb shell</code>  进入 adb 命令行窗口，</p><p> <code>logcat | grep &quot;XX&quot;</code></p><p> eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell</span><br><span class="line"> shell@virgo:/ $ logcat | grep "NJ"</span><br><span class="line"> 10-21 11:18:34.767  2572  4823 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 14:12:03.610  2572  5054 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob/.module.main.NJMainActivity&#125; from uid 10154 on display 0</span><br><span class="line"> 10-21 15:49:33.229  2572  2659 I ActivityManager:   Force finishing activity ActivityRecord&#123;c06ee19 u0 com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity t673&#125;</span><br><span class="line"> 10-21 15:49:38.330  2572  5128 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 15:55:29.015  2572  5054 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br><span class="line"> 10-21 16:25:23.751  2572  4785 I ActivityManager: START u0 &#123;cmp=com.taobao.newjob.debug/com.taobao.newjob.module.main.NJMainActivity&#125; from uid 10151 on display 0</span><br></pre></td></tr></table></figure></li><li><p>卸载应用</p><p><code>adb uninstall 包名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb uninstall com.taobao.newjob</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>查看系统盘符</p><p><code>adb shell df</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell df</span><br><span class="line">Filesystem               Size     Used     Free   Blksize</span><br><span class="line">/dev                   800.0M   116.0K   799.9M   4096</span><br><span class="line">/var                     1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup           1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup/memory: Permission denied</span><br><span class="line">/mnt                     1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup           1.4G     0.0K     1.4G   4096</span><br><span class="line">/sys/fs/cgroup/memory: Permission denied</span><br><span class="line">/sys/fs/cgroup/freezer: Permission denied</span><br><span class="line">/system                  1.5G     1.3G   223.6M   4096</span><br><span class="line">/data                   12.2G     4.7G     7.5G   4096</span><br><span class="line">/cache                 377.8M     6.3M   371.5M   4096</span><br><span class="line">/persist                15.7M     4.1M    11.6M   4096</span><br><span class="line">/firmware               64.0M    53.1M    10.9M   16384</span><br><span class="line">/storage                 1.4G     0.0K     1.4G   4096</span><br><span class="line">/mnt/runtime/default/emulated: Permission denied</span><br><span class="line">/storage/emulated       12.2G     4.7G     7.5G   4096</span><br><span class="line">/mnt/runtime/read/emulated: Permission denied</span><br><span class="line">/mnt/runtime/write/emulated: Permission denied</span><br></pre></td></tr></table></figure></li><li><p>查看所有已安装的应用</p><p><code>adb shell pm list packages -f</code>，后面的参数追加 -s 表示列出系统应用，-3 表示列出三方应用，-f 表示列出应用关联的APK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜ adb shell pm list packages -f</span><br><span class="line">package:/data/app/com.homelink.android-1/base.apk=com.homelink.android</span><br><span class="line">package:/system/priv-app/TelephonyProvider/TelephonyProvider.apk=com.android.providers.telephony</span><br><span class="line">package:/system/app/PowerKeeper/PowerKeeper.apk=com.miui.powerkeeper</span><br><span class="line">package:/data/app/io.appium.settings-1/base.apk=io.appium.settings</span><br><span class="line">package:/system/priv-app/CalendarProvider/CalendarProvider.apk=com.android.providers.calendar</span><br><span class="line">package:/system/priv-app/MediaProvider/MediaProvider.apk=com.android.providers.media</span><br><span class="line">package:/system/app/MiLinkService/MiLinkService.apk=com.milink.service</span><br><span class="line">package:/system/priv-app/SpacesTrustAgent/SpacesTrustAgent.apk=com.securespaces.android.trustagent</span><br><span class="line">package:/system/app/XiaomiAccount/XiaomiAccount.apk=com.xiaomi.account</span><br><span class="line">package:/system/app/shutdownlistener/shutdownlistener.apk=com.qualcomm.shutdownlistner</span><br><span class="line">package:/system/priv-app/WallpaperCropper/WallpaperCropper.apk=com.android.wallpapercropper</span><br><span class="line">package:/system/priv-app/CNEService/CNEService.apk=com.quicinc.cne.CNEService</span><br><span class="line">package:/system/app/MiLivetalk/MiLivetalk.apk=com.miui.milivetalk</span><br><span class="line">package:/system/app/Updater/Updater.apk=com.android.updater</span><br><span class="line">package:/system/app/DocumentsUI/DocumentsUI.apk=com.android.documentsui</span><br><span class="line">package:/system/app/Galaxy4/Galaxy4.apk=com.android.galaxy4</span><br><span class="line">package:/system/priv-app/ExternalStorageProvider/ExternalStorageProvider.apk=com.android.externalstorage</span><br><span class="line">package:/system/priv-app/MiGameCenterSDKService/MiGameCenterSDKService.apk=com.xiaomi.gamecenter.sdk.service</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>模拟输入</p><p> <code>adb shell input keyevent code</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell input keyevent 3 (home)</span><br><span class="line">➜  adb shell input keyevent 4 (back)</span><br><span class="line">➜  adb shell input keyevent 19 (up)</span><br><span class="line">➜  adb shell input keyevent 20 (down)</span><br><span class="line">➜  adb shell input keyevent 21 (left)</span><br><span class="line">➜  adb shell input keyevent 22 (right)</span><br><span class="line">➜  adb shell input keyevent 82 (menu)</span><br><span class="line">...</span><br><span class="line">(其他请参考 API 文档)</span><br></pre></td></tr></table></figure></li><li><p>查看 Activity 运行状态</p><p> <code>adb shell dumpsys activity activities</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell dumpsys activity activities | grep "newjob"</span><br><span class="line"> * TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> userId=0 effectiveUid=u0a154 mCallingUid=u0a154 mCallingPackage=com.taobao.newjob</span><br><span class="line"> affinity=com.taobao.newjob</span><br><span class="line"> intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.taobao.newjob/.module.launch.LaunchActivity&#125;</span><br><span class="line"> realActivity=com.taobao.newjob/.module.launch.LaunchActivity</span><br><span class="line"> Activities=[ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;]</span><br><span class="line"> * Hist #0: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> packageName=com.taobao.newjob processName=com.taobao.newjob</span><br><span class="line"> launchedFromUid=10154 launchedFromPackage=com.taobao.newjob userId=0</span><br><span class="line"> app=ProcessRecord&#123;4340cfa 15047:com.taobao.newjob/u0a154&#125;</span><br><span class="line"> Intent &#123; flg=0x10000000 cmp=com.taobao.newjob/.module.main.NJMainActivity &#125;</span><br><span class="line"> frontOfTask=true task=TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> taskAffinity=com.taobao.newjob</span><br><span class="line"> realActivity=com.taobao.newjob/.module.main.NJMainActivity</span><br><span class="line"> baseDir=/data/app/com.taobao.newjob-1/base.apk</span><br><span class="line"> dataDir=/data/user/0/com.taobao.newjob</span><br><span class="line"> TaskRecord&#123;6a88af6 #752 A=com.taobao.newjob U=0 sz=1&#125;</span><br><span class="line"> Run #2: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> mResumedActivity: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br><span class="line"> mLastPausedActivity: ActivityRecord&#123;28c42b5 u0 com.taobao.newjob/.module.launch.LaunchActivity t752 f&#125;</span><br><span class="line"> mFocusedActivity: ActivityRecord&#123;b3c21c2 u0 com.taobao.newjob/.module.main.NJMainActivity t752&#125;</span><br></pre></td></tr></table></figure></li><li><p>列出前台 Activity</p><p><code>adb shell dumpsys activity activities | grep mFocusedActivity</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell dumpsys activity activities | grep mFocusedActivity</span><br><span class="line">   mFocusedActivity: ActivityRecord&#123;a798935 u0 com.taobao.taobao/com.taobao.tao.homepage.MainActivity3 t1023&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动一个 Activity</p><p><code>adb shell am start -n 包名/包名+类名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell am start -n com.taobao.newjob/com.taobao.newjob.module.launch.LaunchActivity</span><br><span class="line">Starting: Intent &#123; cmp=com.taobao.newjob/.module.launch.LaunchActivity &#125;</span><br></pre></td></tr></table></figure></li><li><p>启动一个 Service</p><p><code>adb shell am startservice -n 包名/包名+类名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  adb shell am startservice -n com.taobao.newjob.debug/com.taobao.newjob.services.NJRequestImageService</span><br><span class="line">Starting service: Intent &#123; cmp=com.taobao.newjob.debug/com.taobao.newjob.services.NJRequestImageService &#125;</span><br><span class="line">Error: Requires permission not exported from uid 10188</span><br><span class="line">// 这里因为我的 service 设置了 exported = false，所以启动失败</span><br></pre></td></tr></table></figure></li><li><p>发送指定的广播</p><p><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n 包名/包名+类名</code><br>我们可以在调试时，执行这个命令发送指定广播来 debug，特别是一些很难制作的情景的广播。</p></li><li><p>录制屏幕</p><p><code>adb shell screenrecord /路径/xxx/mp4</code></p></li><li><p>手机重新启动</p><p><code>adb reboot</code></p></li><li><p>当电脑上有多个设备 online 时，指定链接到某个设备向其发送命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb devices (先查看有哪些设备)</span><br><span class="line">List of devices attached</span><br><span class="line">192.168.57.101:5555     device</span><br><span class="line">1d760d8a        device</span><br></pre></td></tr></table></figure><p>​现在我们链接下面的那个设备 1d760d8a，通过<code>adb -s &lt;serial number&gt; cmd</code>指定向其发送 shell 命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb -s 1d760d8a shell</span><br><span class="line">shell@virgo:/ $</span><br></pre></td></tr></table></figure><p>导出一个应用的数据库到本地 Desktop 目录下面，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb -s 192.168.57.101:5555 pull /data/data/com.taobao.newjob.debug/databases/logdb.db ~/Desktop</span><br><span class="line"><span class="meta">[100%</span>] /data/data/com.taobao.newjob.debug/databases/logdb.db</span><br></pre></td></tr></table></figure><p>运行其它命令同上面。</p></li><li><p>启动/停止 adb</p><p><code>adb start-server</code> 和 <code>adb kill-server</code></p></li><li><p>清除 apk 数据</p><p><code>adb shell pm clear 包名</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell pm clear com.taobao.taobao</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></li><li><p>强行停止应用</p><p><code>adb shell am force-stop 包名</code></p></li><li><p>Android 日志</p><p><code>adb logcat [&lt;option&gt;] [&lt;filter-spec&gt;]</code></p></li><li><p>查看系统属性</p><p><code>adb shell cat /system/build.prop</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell cat /system/build.prop</span><br><span class="line"><span class="meta"> #</span> begin build properties</span><br><span class="line"><span class="meta"> #</span> autogenerated by buildinfo.sh</span><br><span class="line"> ro.build.id=MMB29M</span><br><span class="line"> ro.build.display.id=MMB29M</span><br><span class="line"> ro.build.version.incremental=6.10.13</span><br><span class="line"> ro.build.version.sdk=23</span><br><span class="line"> ro.build.version.preview_sdk=0</span><br><span class="line"> ro.build.version.codename=REL</span><br><span class="line"> ro.build.version.all_codenames=REL</span><br><span class="line"> ro.build.version.release=6.0.1</span><br><span class="line"></span><br><span class="line"> ro.build.version.security_patch=2016-09-01</span><br><span class="line"> ro.build.version.base_os=</span><br><span class="line"> ro.build.date=Thu Oct 13 12:11:20 CST 2016</span><br><span class="line"> ro.build.date.utc=1476331880</span><br><span class="line"> ro.build.type=user</span><br><span class="line"> ro.build.user=builder</span><br><span class="line"> ro.build.host=c3-miui-ota-bd22</span><br><span class="line"> ro.build.tags=release-keys</span><br><span class="line"> ro.build.flavor=virgo-user</span><br><span class="line"> ro.product.model=MI 3W</span><br><span class="line"> ro.product.brand=Xiaomi</span><br><span class="line"> ro.product.name=virgo</span><br><span class="line"> ro.product.device=virgo</span><br><span class="line"> ro.product.board=MSM8974</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li><li><p>屏幕截图</p><p>​<code>adb shell screencap -p /路径/xxx.png</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ADB-常用命令总结：&quot;&gt;&lt;a href=&quot;#ADB-常用命令总结：&quot; class=&quot;headerlink&quot; title=&quot;ADB 常用命令总结：&quot;&gt;&lt;/a&gt;ADB 常用命令总结：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;显示系统全部的 Android 平台&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Android" scheme="http://G96968586.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly 1014</title>
    <link href="http://G96968586.github.io/2016/10/13/weekly-1014/"/>
    <id>http://G96968586.github.io/2016/10/13/weekly-1014/</id>
    <published>2016-10-13T15:34:46.000Z</published>
    <updated>2018-05-02T12:42:07.001Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在 Andorid Studio 中查看 Gradle 添加的依赖时，只有平行的一级，看不出任何从属关系，</li></ul><p><img src="http://alphayang.github.io/img/graldle_flat_dep_tree.png" alt="img"></p><p>特别是出现依赖冲突的时候，在build.gradle 中根据没有添加的包，此时可以在项目根目录下的 build.gradle 中添加如下代码：<br><a id="more"></a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    task allDeps(<span class="string">type:</span> DependencyReportTask) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Terminal 下运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew allDeps</span><br></pre></td></tr></table></figure><p>就可以看到依赖树啦!</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">compile - Classpath <span class="keyword">for</span> compiling the main sources.</span><br><span class="line">...</span><br><span class="line">+--- com.android.<span class="string">support:</span><span class="string">design:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    \--- com.android.<span class="string">support:</span>support-<span class="string">annotations:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>recyclerview-<span class="string">v7:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    +--- com.android.<span class="string">support:</span>support-<span class="string">annotations:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|    |    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|    \--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|         +--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|         +--- com.android.<span class="string">support:</span>support-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|         |    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|         \--- com.android.<span class="string">support:</span>animated-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span></span><br><span class="line">|              \--- com.android.<span class="string">support:</span>support-vector-<span class="string">drawable:</span><span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>recyclerview-<span class="string">v7:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">24.0</span>.+ -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">+--- com.<span class="string">alibaba:</span><span class="string">fastjson:</span><span class="number">1.2</span><span class="number">.7</span></span><br><span class="line">+--- com.android.<span class="string">support:</span><span class="string">multidex:</span><span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">+--- com.<span class="string">nineoldandroids:</span><span class="string">library:</span><span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">+--- com.wang.<span class="string">avi:</span><span class="string">library:</span><span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">|    +--- com.android.<span class="string">support:</span>appcompat-<span class="string">v7:</span><span class="number">22.2</span><span class="number">.0</span> -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">|    \--- com.<span class="string">nineoldandroids:</span><span class="string">library:</span><span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">+--- me.drakeet.<span class="string">materialdialog:</span><span class="string">library:</span><span class="number">1.2</span><span class="number">.8</span></span><br><span class="line">+--- com.<span class="string">balysv:</span>material-<span class="string">ripple:</span><span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">+--- com.<span class="string">zhy:</span><span class="string">okhttputils:</span><span class="number">2.2</span><span class="number">.0</span></span><br><span class="line">|    \--- com.squareup.<span class="string">okhttp3:</span><span class="string">okhttp:</span><span class="number">3.0</span><span class="number">.1</span></span><br><span class="line">|         \--- com.squareup.<span class="string">okio:</span><span class="string">okio:</span><span class="number">1.6</span><span class="number">.0</span></span><br><span class="line">+--- com.czt.<span class="string">mp3recorder:</span><span class="string">library:</span><span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">|    \--- com.android.<span class="string">support:</span>support-<span class="string">v4:</span><span class="number">23.1</span><span class="number">.1</span> -&gt; <span class="number">24.0</span><span class="number">.0</span> (*)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>客户端本地使用 Android Studio 调试时出现 <strong>Failure [INSTALL_CANCELED_BY_USER]</strong> 的问题</li></ul><p>今天在我使用小米 Note 本地调试 app 时，每次在 Install app 环节就出现了 <strong>Failure [INSTALL_CANCELED_BY_USER]</strong> 的错误，字面意义很容易理解，被用户手动取消安装了，呵，说着倒是挺轻松的，可我压根就没有取消，查看手机开发者调试开关和 USB 开关都打开了，网上查了一下，大概有下面几种解决方法：</p><p>1.确保手机处于开发者模式</p><p>2.在手机上，勾选 系统设置 -&gt; 安全 -&gt; 未知来源</p><p>3.安装的时候手机是否处于锁屏状态，若是，取消锁屏</p><p>4.有的手机需要手动安装，比如小米3</p><p>5.手机内存空间可能不足</p><p>上面五种方法对我来说都没有用，正当我在烦恼的时候，我突然想起是不是我更新了 MIUI 系统的原因造成的，因为之前我是可以调试的。打开手机开发者选项，看到多出了很多的开关选项，其中有一个“允许通过USB安装应用”的开关，打开它，发现还需要小米账号登录，真烦，无奈，我还是登录了，然后把这个开关打开，重新通过 Android Studio 把 app 跑起来，结果可以了！</p><p>如果你在小米的手机上也遇到这个问题，不妨试试我的方法。</p><p><strong>注：更新后的小米系统版本如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Android 版本: 6.0.1 MMB29M</span><br><span class="line"></span><br><span class="line">MIUI 版本: MIUI 8.6.9.29|开发版 (靠，还是开发版)</span><br></pre></td></tr></table></figure><ul><li>Chrome 上模拟 UA</li></ul><p>打开开发者模式，More tools -&gt; Network conditions</p><p><img src="https://gw.alicdn.com/tps/TB1rfAfNFXXXXXrapXXXXXXXXXX-782-580.png" alt=""></p><p>进入下面的页面，</p><p><img src="https://gw.alicdn.com/tps/TB1PQ.qNFXXXXbJXVXXXXXXXXXX-1156-618.png" alt=""></p><p>去掉 Select automatically 选项，然后选择平台，下面的 UA 就可以根据你的需求更改了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在 Andorid Studio 中查看 Gradle 添加的依赖时，只有平行的一级，看不出任何从属关系，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://alphayang.github.io/img/graldle_flat_dep_tree.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;特别是出现依赖冲突的时候，在build.gradle 中根据没有添加的包，此时可以在项目根目录下的 build.gradle 中添加如下代码：&lt;br&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0708</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0708/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0708/</id>
    <published>2016-10-09T15:06:29.000Z</published>
    <updated>2018-05-02T09:57:59.107Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://www.codes51.com/article/detail_101733.html" target="_blank" rel="noopener">在WebView自身打开链接 – 关于 WebViewClient 类 shouldOverrideUrlLoading 的错误用法</a></p></li><li><p>Android 24之后(即 Android N)，可以很方便的查看自己 app 是否打开了消息通知开关</p><a id="more"></a><p>详情：<br>Now you can check it, as said in <a href="https://www.youtube.com/watch?v=w45y_w4skKs&amp;feature=youtu.be&amp;list=PLOU2XLYxmsILe6_eGvDN3GyiodoV3qNSC&amp;t=192" target="_blank" rel="noopener">this Google I/O 2016 video</a></p></li></ul><p>怎么使用呢？看下我的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isOpen = NotificationManagerCompat.from(<span class="keyword">this</span>).areNotificationsEnabled();</span><br></pre></td></tr></table></figure><p>这里需要注意的是，在 API 19 以下方法 areNotificationsEnabled 默认都返回 true，在 API 19+ (包括19)是有效果的。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.codes51.com/article/detail_101733.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在WebView自身打开链接 – 关于 WebViewClient 类 shouldOverrideUrlLoading 的错误用法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 24之后(即 Android N)，可以很方便的查看自己 app 是否打开了消息通知开关&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0715</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0715/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0715/</id>
    <published>2016-10-09T15:05:23.000Z</published>
    <updated>2018-05-02T09:58:35.921Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="http://www.jianshu.com/p/ea48332c82af" target="_blank" rel="noopener">落地——读《App研发录》</a></p></li><li><p><a href="https://segmentfault.com/a/1190000005864691" target="_blank" rel="noopener">Web App防坑手册</a></p></li><li><p>Android 从代码源头上 findbugs <a href="https://github.com/MasonLiuChn/AndroidCodeQuality" target="_blank" rel="noopener">《AndroidCodeQuality》库</a>，尝试了一下，会导致编译变慢好多，所以还是不引入众包项目了。</p><a id="more"></a></li><li><p><a href="https://github.com/mihaip/dex-method-counts" target="_blank" rel="noopener">dex-method-counts</a>,统计一个 apk 使用的方法数，它可以很详细的列出哪些包使用了多少方法，这个工具可以用来决定哪些类库可以在 65k 限制之下使用。</p></li><li><p>强烈推荐的一篇文章 <a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="noopener">《Android 开发最佳实践》</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/ea48332c82af&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;落地——读《App研发录》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005864691&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web App防坑手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android 从代码源头上 findbugs &lt;a href=&quot;https://github.com/MasonLiuChn/AndroidCodeQuality&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AndroidCodeQuality》库&lt;/a&gt;，尝试了一下，会导致编译变慢好多，所以还是不引入众包项目了。&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0722</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0722/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0722/</id>
    <published>2016-10-09T15:02:38.000Z</published>
    <updated>2018-05-02T09:58:44.593Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>了解下 box-sizing <a href="http://www.jiangweishan.com/article/boxSizing.html" target="_blank" rel="noopener">关于移动端Box-sizing的基本知识和应用</a></p></li><li><p><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">Android性能优化典范 - 第1季</a></p></li><li><p><a href="http://hukai.me/android-tips-for-reduce-apk-size/" target="_blank" rel="noopener">Android APK安装包瘦身</a></p><a id="more"></a></li><li><p><a href="http://www.html-js.com/article/Mobile-terminal-H5-mobile-terminal-HD-multi-screen-adaptation-scheme%203041" target="_blank" rel="noopener">移动端高清、多屏适配方案</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=2652261744&amp;idx=1&amp;sn=01fc945337c048735c8375d5a94fc4c8&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">Android :“万能” Activity 重构篇（上）</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&amp;mid=2652261744&amp;idx=2&amp;sn=caa8bd3502624385c789bc99bb605581&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">Android :“万能” Activity 重构篇（下）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解下 box-sizing &lt;a href=&quot;http://www.jiangweishan.com/article/boxSizing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于移动端Box-sizing的基本知识和应用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-performance-patterns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android性能优化典范 - 第1季&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-tips-for-reduce-apk-size/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android APK安装包瘦身&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 0729</title>
    <link href="http://G96968586.github.io/2016/10/09/weekly-0729/"/>
    <id>http://G96968586.github.io/2016/10/09/weekly-0729/</id>
    <published>2016-10-09T15:00:44.000Z</published>
    <updated>2018-05-02T09:58:56.535Z</updated>
    
    <content type="html"><![CDATA[<p>1、本地 git 切换到远程分支</p><p>首先，通过 git branch -va 查看本地 ＋ 远程的分支列表,比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master              0840594 merge master and 1.0.0</span><br><span class="line">remotes/origin/1.0.0  743012a 'update'</span><br><span class="line">remotes/origin/2.0.0  2787838 udpate</span><br><span class="line">remotes/origin/HEAD   -&gt; origin/master</span><br><span class="line">remotes/origin/master 0840594 merge master and 1.0.0</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果想切换到 origin/2.0.0 的分支，我们可以<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch remotes/origin/2.0.0</span><br></pre></td></tr></table></figure></p><p>不过结果并不如意：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* (detached from origin/2.0.0)</span><br><span class="line">master</span><br></pre></td></tr></table></figure></p><p>git branch 会看到上面的信息，这里还需要一步操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 2.0.0</span><br></pre></td></tr></table></figure><p>-b 的意思是 base，以当前分支为 base，新建一个名叫 2.0.0 的分支，这里当然也可以使用其他的命名。此时再执行 git branch 就能看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git br</span><br><span class="line">  master</span><br><span class="line">* 2.0.0</span><br></pre></td></tr></table></figure><p>最直接的方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t origin/2.0.0</span><br></pre></td></tr></table></figure><p>能够直接新建本地分支，将远程分支提取出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、本地 git 切换到远程分支&lt;/p&gt;
&lt;p&gt;首先，通过 git branch -va 查看本地 ＋ 远程的分支列表,比如：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* master              0840594 merge master and 1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/1.0.0  743012a &#39;update&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/2.0.0  2787838 udpate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/HEAD   -&amp;gt; origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remotes/origin/master 0840594 merge master and 1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>weekly 1008</title>
    <link href="http://G96968586.github.io/2016/10/08/weekly-1008/"/>
    <id>http://G96968586.github.io/2016/10/08/weekly-1008/</id>
    <published>2016-10-08T15:20:16.000Z</published>
    <updated>2018-05-02T09:59:54.535Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近在做 React 开发时，遇到了这样一个问题，<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    getInitialState()&#123;</span><br><span class="line">         <span class="comment">// some thing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>getInitialState 不会调用，浏览器输出了下面的信息，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: getInitialState was defined on TodoApp, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?</span><br></pre></td></tr></table></figure></p><p>上网查了一下，原来 React 在 ES6 的实现中去掉了 getInitialState 这个 hook 函数，规定 state 在 constructor 中实现，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class App extends Component &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">&#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Babel的Blog上还有一种实现方法，即直接使用赋值语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">state = &#123;&#125;    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最近在做 React 开发时，遇到了这样一个问题，&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TodoApp&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getInitialState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// some thing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="WeeklyTask" scheme="http://G96968586.github.io/categories/WeeklyTask/"/>
    
    
      <category term="每周总结" scheme="http://G96968586.github.io/tags/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>样式辅助文件 flexbox.scss</title>
    <link href="http://G96968586.github.io/2016/09/25/%E6%A0%B7%E5%BC%8F%E8%BE%85%E5%8A%A9%E6%96%87%E4%BB%B6flexbox-scss/"/>
    <id>http://G96968586.github.io/2016/09/25/样式辅助文件flexbox-scss/</id>
    <published>2016-09-25T15:50:21.000Z</published>
    <updated>2016-09-25T15:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.FBH</span>,</span><br><span class="line"><span class="selector-class">.FBV</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBV</span> &#123;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-box-<span class="attribute">direction</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAS</span> &#123;</span><br><span class="line">  -webkit-box-align: start;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: flex-start;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAC</span> &#123;</span><br><span class="line">  -webkit-box-align: center;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBAE</span> &#123;</span><br><span class="line">  -webkit-box-align: end;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: flex-end;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJS</span> &#123;</span><br><span class="line">  -webkit-box-pack: start;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJC</span> &#123;</span><br><span class="line">  -webkit-box-pack: center;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJE</span> &#123;</span><br><span class="line">  -webkit-box-pack: end;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBJ</span> &#123;</span><br><span class="line">  -webkit-box-pack: justify;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB1</span>, <span class="selector-class">.FB2</span>, <span class="selector-class">.FB3</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB1</span>,</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB2</span>,</span><br><span class="line"><span class="selector-class">.FBH</span> &gt; <span class="selector-class">.FB3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB1</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB2</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.FB3</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="CSS" scheme="http://G96968586.github.io/categories/CSS/"/>
    
    
      <category term="样式" scheme="http://G96968586.github.io/tags/%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="代码" scheme="http://G96968586.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
